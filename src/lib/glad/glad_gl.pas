{

    OpenGL ES loader generated by glad 0.1.36 on Tue Nov 26 19:28:06 2024.

    Language/Generator: Pascal
    Specification: gl
    APIs: gles2=3.0
    Profile: core
    Extensions:
        GL_AMD_compressed_3DC_texture,
        GL_AMD_compressed_ATC_texture,
        GL_AMD_framebuffer_multisample_advanced,
        GL_AMD_performance_monitor,
        GL_AMD_program_binary_Z400,
        GL_ANDROID_extension_pack_es31a,
        GL_ANGLE_depth_texture,
        GL_ANGLE_framebuffer_blit,
        GL_ANGLE_framebuffer_multisample,
        GL_ANGLE_instanced_arrays,
        GL_ANGLE_pack_reverse_row_order,
        GL_ANGLE_program_binary,
        GL_ANGLE_texture_compression_dxt3,
        GL_ANGLE_texture_compression_dxt5,
        GL_ANGLE_texture_usage,
        GL_ANGLE_translated_shader_source,
        GL_APPLE_clip_distance,
        GL_APPLE_color_buffer_packed_float,
        GL_APPLE_copy_texture_levels,
        GL_APPLE_framebuffer_multisample,
        GL_APPLE_rgb_422,
        GL_APPLE_sync,
        GL_APPLE_texture_format_BGRA8888,
        GL_APPLE_texture_max_level,
        GL_APPLE_texture_packed_float,
        GL_ARM_mali_program_binary,
        GL_ARM_mali_shader_binary,
        GL_ARM_rgba8,
        GL_ARM_shader_core_properties,
        GL_ARM_shader_framebuffer_fetch,
        GL_ARM_shader_framebuffer_fetch_depth_stencil,
        GL_ARM_texture_unnormalized_coordinates,
        GL_DMP_program_binary,
        GL_DMP_shader_binary,
        GL_EXT_EGL_image_array,
        GL_EXT_EGL_image_storage,
        GL_EXT_EGL_image_storage_compression,
        GL_EXT_YUV_target,
        GL_EXT_base_instance,
        GL_EXT_blend_func_extended,
        GL_EXT_blend_minmax,
        GL_EXT_buffer_storage,
        GL_EXT_clear_texture,
        GL_EXT_clip_control,
        GL_EXT_clip_cull_distance,
        GL_EXT_color_buffer_float,
        GL_EXT_color_buffer_half_float,
        GL_EXT_conservative_depth,
        GL_EXT_copy_image,
        GL_EXT_debug_label,
        GL_EXT_debug_marker,
        GL_EXT_depth_clamp,
        GL_EXT_discard_framebuffer,
        GL_EXT_disjoint_timer_query,
        GL_EXT_draw_buffers,
        GL_EXT_draw_buffers_indexed,
        GL_EXT_draw_elements_base_vertex,
        GL_EXT_draw_instanced,
        GL_EXT_draw_transform_feedback,
        GL_EXT_external_buffer,
        GL_EXT_float_blend,
        GL_EXT_fragment_shading_rate,
        GL_EXT_framebuffer_blit_layers,
        GL_EXT_geometry_point_size,
        GL_EXT_geometry_shader,
        GL_EXT_gpu_shader5,
        GL_EXT_instanced_arrays,
        GL_EXT_map_buffer_range,
        GL_EXT_memory_object,
        GL_EXT_memory_object_fd,
        GL_EXT_memory_object_win32,
        GL_EXT_multi_draw_arrays,
        GL_EXT_multi_draw_indirect,
        GL_EXT_multisampled_compatibility,
        GL_EXT_multisampled_render_to_texture,
        GL_EXT_multisampled_render_to_texture2,
        GL_EXT_multiview_draw_buffers,
        GL_EXT_multiview_tessellation_geometry_shader,
        GL_EXT_multiview_texture_multisample,
        GL_EXT_multiview_timer_query,
        GL_EXT_occlusion_query_boolean,
        GL_EXT_polygon_offset_clamp,
        GL_EXT_post_depth_coverage,
        GL_EXT_primitive_bounding_box,
        GL_EXT_protected_textures,
        GL_EXT_pvrtc_sRGB,
        GL_EXT_raster_multisample,
        GL_EXT_read_format_bgra,
        GL_EXT_render_snorm,
        GL_EXT_robustness,
        GL_EXT_sRGB,
        GL_EXT_sRGB_write_control,
        GL_EXT_semaphore,
        GL_EXT_semaphore_fd,
        GL_EXT_semaphore_win32,
        GL_EXT_separate_depth_stencil,
        GL_EXT_separate_shader_objects,
        GL_EXT_shader_framebuffer_fetch,
        GL_EXT_shader_framebuffer_fetch_non_coherent,
        GL_EXT_shader_group_vote,
        GL_EXT_shader_implicit_conversions,
        GL_EXT_shader_integer_mix,
        GL_EXT_shader_io_blocks,
        GL_EXT_shader_non_constant_global_initializers,
        GL_EXT_shader_pixel_local_storage,
        GL_EXT_shader_pixel_local_storage2,
        GL_EXT_shader_samples_identical,
        GL_EXT_shader_texture_lod,
        GL_EXT_shadow_samplers,
        GL_EXT_sparse_texture,
        GL_EXT_sparse_texture2,
        GL_EXT_tessellation_point_size,
        GL_EXT_tessellation_shader,
        GL_EXT_texture_border_clamp,
        GL_EXT_texture_buffer,
        GL_EXT_texture_compression_astc_decode_mode,
        GL_EXT_texture_compression_bptc,
        GL_EXT_texture_compression_dxt1,
        GL_EXT_texture_compression_rgtc,
        GL_EXT_texture_compression_s3tc,
        GL_EXT_texture_compression_s3tc_srgb,
        GL_EXT_texture_cube_map_array,
        GL_EXT_texture_filter_anisotropic,
        GL_EXT_texture_filter_minmax,
        GL_EXT_texture_format_BGRA8888,
        GL_EXT_texture_format_sRGB_override,
        GL_EXT_texture_mirror_clamp_to_edge,
        GL_EXT_texture_norm16,
        GL_EXT_texture_query_lod,
        GL_EXT_texture_rg,
        GL_EXT_texture_sRGB_R8,
        GL_EXT_texture_sRGB_RG8,
        GL_EXT_texture_sRGB_decode,
        GL_EXT_texture_shadow_lod,
        GL_EXT_texture_storage,
        GL_EXT_texture_storage_compression,
        GL_EXT_texture_type_2_10_10_10_REV,
        GL_EXT_texture_view,
        GL_EXT_unpack_subimage,
        GL_EXT_win32_keyed_mutex,
        GL_EXT_window_rectangles,
        GL_FJ_shader_binary_GCCSO,
        GL_IMG_bindless_texture,
        GL_IMG_framebuffer_downsample,
        GL_IMG_multisampled_render_to_texture,
        GL_IMG_program_binary,
        GL_IMG_read_format,
        GL_IMG_shader_binary,
        GL_IMG_texture_compression_pvrtc,
        GL_IMG_texture_compression_pvrtc2,
        GL_IMG_texture_filter_cubic,
        GL_INTEL_blackhole_render,
        GL_INTEL_conservative_rasterization,
        GL_INTEL_framebuffer_CMAA,
        GL_INTEL_performance_query,
        GL_KHR_blend_equation_advanced,
        GL_KHR_blend_equation_advanced_coherent,
        GL_KHR_context_flush_control,
        GL_KHR_debug,
        GL_KHR_no_error,
        GL_KHR_parallel_shader_compile,
        GL_KHR_robust_buffer_access_behavior,
        GL_KHR_robustness,
        GL_KHR_shader_subgroup,
        GL_KHR_texture_compression_astc_hdr,
        GL_KHR_texture_compression_astc_ldr,
        GL_KHR_texture_compression_astc_sliced_3d,
        GL_MESA_bgra,
        GL_MESA_framebuffer_flip_x,
        GL_MESA_framebuffer_flip_y,
        GL_MESA_framebuffer_swap_xy,
        GL_MESA_program_binary_formats,
        GL_MESA_sampler_objects,
        GL_MESA_shader_integer_functions,
        GL_NVX_blend_equation_advanced_multi_draw_buffers,
        GL_NV_bindless_texture,
        GL_NV_blend_equation_advanced,
        GL_NV_blend_equation_advanced_coherent,
        GL_NV_blend_minmax_factor,
        GL_NV_clip_space_w_scaling,
        GL_NV_compute_shader_derivatives,
        GL_NV_conditional_render,
        GL_NV_conservative_raster,
        GL_NV_conservative_raster_pre_snap,
        GL_NV_conservative_raster_pre_snap_triangles,
        GL_NV_copy_buffer,
        GL_NV_coverage_sample,
        GL_NV_depth_nonlinear,
        GL_NV_draw_buffers,
        GL_NV_draw_instanced,
        GL_NV_draw_vulkan_image,
        GL_NV_explicit_attrib_location,
        GL_NV_fbo_color_attachments,
        GL_NV_fence,
        GL_NV_fill_rectangle,
        GL_NV_fragment_coverage_to_color,
        GL_NV_fragment_shader_barycentric,
        GL_NV_fragment_shader_interlock,
        GL_NV_framebuffer_blit,
        GL_NV_framebuffer_mixed_samples,
        GL_NV_framebuffer_multisample,
        GL_NV_generate_mipmap_sRGB,
        GL_NV_geometry_shader_passthrough,
        GL_NV_gpu_shader5,
        GL_NV_image_formats,
        GL_NV_instanced_arrays,
        GL_NV_internalformat_sample_query,
        GL_NV_memory_attachment,
        GL_NV_memory_object_sparse,
        GL_NV_mesh_shader,
        GL_NV_non_square_matrices,
        GL_NV_pack_subimage,
        GL_NV_path_rendering,
        GL_NV_path_rendering_shared_edge,
        GL_NV_pixel_buffer_object,
        GL_NV_polygon_mode,
        GL_NV_primitive_shading_rate,
        GL_NV_read_buffer,
        GL_NV_read_buffer_front,
        GL_NV_read_depth,
        GL_NV_read_depth_stencil,
        GL_NV_read_stencil,
        GL_NV_representative_fragment_test,
        GL_NV_sRGB_formats,
        GL_NV_sample_locations,
        GL_NV_sample_mask_override_coverage,
        GL_NV_scissor_exclusive,
        GL_NV_shader_atomic_fp16_vector,
        GL_NV_shader_noperspective_interpolation,
        GL_NV_shader_subgroup_partitioned,
        GL_NV_shader_texture_footprint,
        GL_NV_shading_rate_image,
        GL_NV_shadow_samplers_array,
        GL_NV_shadow_samplers_cube,
        GL_NV_stereo_view_rendering,
        GL_NV_texture_border_clamp,
        GL_NV_texture_compression_s3tc_update,
        GL_NV_texture_npot_2D_mipmap,
        GL_NV_timeline_semaphore,
        GL_NV_viewport_array,
        GL_NV_viewport_array2,
        GL_NV_viewport_swizzle,
        GL_OES_EGL_image,
        GL_OES_EGL_image_external,
        GL_OES_EGL_image_external_essl3,
        GL_OES_compressed_ETC1_RGB8_sub_texture,
        GL_OES_compressed_ETC1_RGB8_texture,
        GL_OES_compressed_paletted_texture,
        GL_OES_copy_image,
        GL_OES_depth24,
        GL_OES_depth32,
        GL_OES_depth_texture,
        GL_OES_draw_buffers_indexed,
        GL_OES_draw_elements_base_vertex,
        GL_OES_element_index_uint,
        GL_OES_fbo_render_mipmap,
        GL_OES_fragment_precision_high,
        GL_OES_geometry_point_size,
        GL_OES_geometry_shader,
        GL_OES_get_program_binary,
        GL_OES_gpu_shader5,
        GL_OES_mapbuffer,
        GL_OES_packed_depth_stencil,
        GL_OES_primitive_bounding_box,
        GL_OES_required_internalformat,
        GL_OES_rgb8_rgba8,
        GL_OES_sample_shading,
        GL_OES_sample_variables,
        GL_OES_shader_image_atomic,
        GL_OES_shader_io_blocks,
        GL_OES_shader_multisample_interpolation,
        GL_OES_standard_derivatives,
        GL_OES_stencil1,
        GL_OES_stencil4,
        GL_OES_surfaceless_context,
        GL_OES_tessellation_point_size,
        GL_OES_tessellation_shader,
        GL_OES_texture_3D,
        GL_OES_texture_border_clamp,
        GL_OES_texture_buffer,
        GL_OES_texture_compression_astc,
        GL_OES_texture_cube_map_array,
        GL_OES_texture_float,
        GL_OES_texture_float_linear,
        GL_OES_texture_half_float,
        GL_OES_texture_half_float_linear,
        GL_OES_texture_npot,
        GL_OES_texture_stencil8,
        GL_OES_texture_storage_multisample_2d_array,
        GL_OES_texture_view,
        GL_OES_vertex_array_object,
        GL_OES_vertex_half_float,
        GL_OES_vertex_type_10_10_10_2,
        GL_OES_viewport_array,
        GL_OVR_multiview,
        GL_OVR_multiview2,
        GL_OVR_multiview_multisampled_render_to_texture,
        GL_QCOM_YUV_texture_gather,
        GL_QCOM_alpha_test,
        GL_QCOM_binning_control,
        GL_QCOM_driver_control,
        GL_QCOM_extended_get,
        GL_QCOM_extended_get2,
        GL_QCOM_frame_extrapolation,
        GL_QCOM_framebuffer_foveated,
        GL_QCOM_motion_estimation,
        GL_QCOM_perfmon_global_mode,
        GL_QCOM_render_sRGB_R8_RG8,
        GL_QCOM_render_shared_exponent,
        GL_QCOM_shader_framebuffer_fetch_noncoherent,
        GL_QCOM_shader_framebuffer_fetch_rate,
        GL_QCOM_shading_rate,
        GL_QCOM_texture_foveated,
        GL_QCOM_texture_foveated2,
        GL_QCOM_texture_foveated_subsampled_layout,
        GL_QCOM_texture_lod_bias,
        GL_QCOM_tiled_rendering,
        GL_QCOM_writeonly_rendering,
        GL_QCOM_ycbcr_degamma,
        GL_VIV_shader_binary
    Loader: True
    Local files: False
    Omit khrplatform: False
    Reproducible: False

    Commandline:
        --profile="core" --api="gles2=3.0" --generator="pascal" --spec="gl" --extensions="GL_AMD_compressed_3DC_texture,GL_AMD_compressed_ATC_texture,GL_AMD_framebuffer_multisample_advanced,GL_AMD_performance_monitor,GL_AMD_program_binary_Z400,GL_ANDROID_extension_pack_es31a,GL_ANGLE_depth_texture,GL_ANGLE_framebuffer_blit,GL_ANGLE_framebuffer_multisample,GL_ANGLE_instanced_arrays,GL_ANGLE_pack_reverse_row_order,GL_ANGLE_program_binary,GL_ANGLE_texture_compression_dxt3,GL_ANGLE_texture_compression_dxt5,GL_ANGLE_texture_usage,GL_ANGLE_translated_shader_source,GL_APPLE_clip_distance,GL_APPLE_color_buffer_packed_float,GL_APPLE_copy_texture_levels,GL_APPLE_framebuffer_multisample,GL_APPLE_rgb_422,GL_APPLE_sync,GL_APPLE_texture_format_BGRA8888,GL_APPLE_texture_max_level,GL_APPLE_texture_packed_float,GL_ARM_mali_program_binary,GL_ARM_mali_shader_binary,GL_ARM_rgba8,GL_ARM_shader_core_properties,GL_ARM_shader_framebuffer_fetch,GL_ARM_shader_framebuffer_fetch_depth_stencil,GL_ARM_texture_unnormalized_coordinates,GL_DMP_program_binary,GL_DMP_shader_binary,GL_EXT_EGL_image_array,GL_EXT_EGL_image_storage,GL_EXT_EGL_image_storage_compression,GL_EXT_YUV_target,GL_EXT_base_instance,GL_EXT_blend_func_extended,GL_EXT_blend_minmax,GL_EXT_buffer_storage,GL_EXT_clear_texture,GL_EXT_clip_control,GL_EXT_clip_cull_distance,GL_EXT_color_buffer_float,GL_EXT_color_buffer_half_float,GL_EXT_conservative_depth,GL_EXT_copy_image,GL_EXT_debug_label,GL_EXT_debug_marker,GL_EXT_depth_clamp,GL_EXT_discard_framebuffer,GL_EXT_disjoint_timer_query,GL_EXT_draw_buffers,GL_EXT_draw_buffers_indexed,GL_EXT_draw_elements_base_vertex,GL_EXT_draw_instanced,GL_EXT_draw_transform_feedback,GL_EXT_external_buffer,GL_EXT_float_blend,GL_EXT_fragment_shading_rate,GL_EXT_framebuffer_blit_layers,GL_EXT_geometry_point_size,GL_EXT_geometry_shader,GL_EXT_gpu_shader5,GL_EXT_instanced_arrays,GL_EXT_map_buffer_range,GL_EXT_memory_object,GL_EXT_memory_object_fd,GL_EXT_memory_object_win32,GL_EXT_multi_draw_arrays,GL_EXT_multi_draw_indirect,GL_EXT_multisampled_compatibility,GL_EXT_multisampled_render_to_texture,GL_EXT_multisampled_render_to_texture2,GL_EXT_multiview_draw_buffers,GL_EXT_multiview_tessellation_geometry_shader,GL_EXT_multiview_texture_multisample,GL_EXT_multiview_timer_query,GL_EXT_occlusion_query_boolean,GL_EXT_polygon_offset_clamp,GL_EXT_post_depth_coverage,GL_EXT_primitive_bounding_box,GL_EXT_protected_textures,GL_EXT_pvrtc_sRGB,GL_EXT_raster_multisample,GL_EXT_read_format_bgra,GL_EXT_render_snorm,GL_EXT_robustness,GL_EXT_sRGB,GL_EXT_sRGB_write_control,GL_EXT_semaphore,GL_EXT_semaphore_fd,GL_EXT_semaphore_win32,GL_EXT_separate_depth_stencil,GL_EXT_separate_shader_objects,GL_EXT_shader_framebuffer_fetch,GL_EXT_shader_framebuffer_fetch_non_coherent,GL_EXT_shader_group_vote,GL_EXT_shader_implicit_conversions,GL_EXT_shader_integer_mix,GL_EXT_shader_io_blocks,GL_EXT_shader_non_constant_global_initializers,GL_EXT_shader_pixel_local_storage,GL_EXT_shader_pixel_local_storage2,GL_EXT_shader_samples_identical,GL_EXT_shader_texture_lod,GL_EXT_shadow_samplers,GL_EXT_sparse_texture,GL_EXT_sparse_texture2,GL_EXT_tessellation_point_size,GL_EXT_tessellation_shader,GL_EXT_texture_border_clamp,GL_EXT_texture_buffer,GL_EXT_texture_compression_astc_decode_mode,GL_EXT_texture_compression_bptc,GL_EXT_texture_compression_dxt1,GL_EXT_texture_compression_rgtc,GL_EXT_texture_compression_s3tc,GL_EXT_texture_compression_s3tc_srgb,GL_EXT_texture_cube_map_array,GL_EXT_texture_filter_anisotropic,GL_EXT_texture_filter_minmax,GL_EXT_texture_format_BGRA8888,GL_EXT_texture_format_sRGB_override,GL_EXT_texture_mirror_clamp_to_edge,GL_EXT_texture_norm16,GL_EXT_texture_query_lod,GL_EXT_texture_rg,GL_EXT_texture_sRGB_R8,GL_EXT_texture_sRGB_RG8,GL_EXT_texture_sRGB_decode,GL_EXT_texture_shadow_lod,GL_EXT_texture_storage,GL_EXT_texture_storage_compression,GL_EXT_texture_type_2_10_10_10_REV,GL_EXT_texture_view,GL_EXT_unpack_subimage,GL_EXT_win32_keyed_mutex,GL_EXT_window_rectangles,GL_FJ_shader_binary_GCCSO,GL_IMG_bindless_texture,GL_IMG_framebuffer_downsample,GL_IMG_multisampled_render_to_texture,GL_IMG_program_binary,GL_IMG_read_format,GL_IMG_shader_binary,GL_IMG_texture_compression_pvrtc,GL_IMG_texture_compression_pvrtc2,GL_IMG_texture_filter_cubic,GL_INTEL_blackhole_render,GL_INTEL_conservative_rasterization,GL_INTEL_framebuffer_CMAA,GL_INTEL_performance_query,GL_KHR_blend_equation_advanced,GL_KHR_blend_equation_advanced_coherent,GL_KHR_context_flush_control,GL_KHR_debug,GL_KHR_no_error,GL_KHR_parallel_shader_compile,GL_KHR_robust_buffer_access_behavior,GL_KHR_robustness,GL_KHR_shader_subgroup,GL_KHR_texture_compression_astc_hdr,GL_KHR_texture_compression_astc_ldr,GL_KHR_texture_compression_astc_sliced_3d,GL_MESA_bgra,GL_MESA_framebuffer_flip_x,GL_MESA_framebuffer_flip_y,GL_MESA_framebuffer_swap_xy,GL_MESA_program_binary_formats,GL_MESA_sampler_objects,GL_MESA_shader_integer_functions,GL_NVX_blend_equation_advanced_multi_draw_buffers,GL_NV_bindless_texture,GL_NV_blend_equation_advanced,GL_NV_blend_equation_advanced_coherent,GL_NV_blend_minmax_factor,GL_NV_clip_space_w_scaling,GL_NV_compute_shader_derivatives,GL_NV_conditional_render,GL_NV_conservative_raster,GL_NV_conservative_raster_pre_snap,GL_NV_conservative_raster_pre_snap_triangles,GL_NV_copy_buffer,GL_NV_coverage_sample,GL_NV_depth_nonlinear,GL_NV_draw_buffers,GL_NV_draw_instanced,GL_NV_draw_vulkan_image,GL_NV_explicit_attrib_location,GL_NV_fbo_color_attachments,GL_NV_fence,GL_NV_fill_rectangle,GL_NV_fragment_coverage_to_color,GL_NV_fragment_shader_barycentric,GL_NV_fragment_shader_interlock,GL_NV_framebuffer_blit,GL_NV_framebuffer_mixed_samples,GL_NV_framebuffer_multisample,GL_NV_generate_mipmap_sRGB,GL_NV_geometry_shader_passthrough,GL_NV_gpu_shader5,GL_NV_image_formats,GL_NV_instanced_arrays,GL_NV_internalformat_sample_query,GL_NV_memory_attachment,GL_NV_memory_object_sparse,GL_NV_mesh_shader,GL_NV_non_square_matrices,GL_NV_pack_subimage,GL_NV_path_rendering,GL_NV_path_rendering_shared_edge,GL_NV_pixel_buffer_object,GL_NV_polygon_mode,GL_NV_primitive_shading_rate,GL_NV_read_buffer,GL_NV_read_buffer_front,GL_NV_read_depth,GL_NV_read_depth_stencil,GL_NV_read_stencil,GL_NV_representative_fragment_test,GL_NV_sRGB_formats,GL_NV_sample_locations,GL_NV_sample_mask_override_coverage,GL_NV_scissor_exclusive,GL_NV_shader_atomic_fp16_vector,GL_NV_shader_noperspective_interpolation,GL_NV_shader_subgroup_partitioned,GL_NV_shader_texture_footprint,GL_NV_shading_rate_image,GL_NV_shadow_samplers_array,GL_NV_shadow_samplers_cube,GL_NV_stereo_view_rendering,GL_NV_texture_border_clamp,GL_NV_texture_compression_s3tc_update,GL_NV_texture_npot_2D_mipmap,GL_NV_timeline_semaphore,GL_NV_viewport_array,GL_NV_viewport_array2,GL_NV_viewport_swizzle,GL_OES_EGL_image,GL_OES_EGL_image_external,GL_OES_EGL_image_external_essl3,GL_OES_compressed_ETC1_RGB8_sub_texture,GL_OES_compressed_ETC1_RGB8_texture,GL_OES_compressed_paletted_texture,GL_OES_copy_image,GL_OES_depth24,GL_OES_depth32,GL_OES_depth_texture,GL_OES_draw_buffers_indexed,GL_OES_draw_elements_base_vertex,GL_OES_element_index_uint,GL_OES_fbo_render_mipmap,GL_OES_fragment_precision_high,GL_OES_geometry_point_size,GL_OES_geometry_shader,GL_OES_get_program_binary,GL_OES_gpu_shader5,GL_OES_mapbuffer,GL_OES_packed_depth_stencil,GL_OES_primitive_bounding_box,GL_OES_required_internalformat,GL_OES_rgb8_rgba8,GL_OES_sample_shading,GL_OES_sample_variables,GL_OES_shader_image_atomic,GL_OES_shader_io_blocks,GL_OES_shader_multisample_interpolation,GL_OES_standard_derivatives,GL_OES_stencil1,GL_OES_stencil4,GL_OES_surfaceless_context,GL_OES_tessellation_point_size,GL_OES_tessellation_shader,GL_OES_texture_3D,GL_OES_texture_border_clamp,GL_OES_texture_buffer,GL_OES_texture_compression_astc,GL_OES_texture_cube_map_array,GL_OES_texture_float,GL_OES_texture_float_linear,GL_OES_texture_half_float,GL_OES_texture_half_float_linear,GL_OES_texture_npot,GL_OES_texture_stencil8,GL_OES_texture_storage_multisample_2d_array,GL_OES_texture_view,GL_OES_vertex_array_object,GL_OES_vertex_half_float,GL_OES_vertex_type_10_10_10_2,GL_OES_viewport_array,GL_OVR_multiview,GL_OVR_multiview2,GL_OVR_multiview_multisampled_render_to_texture,GL_QCOM_YUV_texture_gather,GL_QCOM_alpha_test,GL_QCOM_binning_control,GL_QCOM_driver_control,GL_QCOM_extended_get,GL_QCOM_extended_get2,GL_QCOM_frame_extrapolation,GL_QCOM_framebuffer_foveated,GL_QCOM_motion_estimation,GL_QCOM_perfmon_global_mode,GL_QCOM_render_sRGB_R8_RG8,GL_QCOM_render_shared_exponent,GL_QCOM_shader_framebuffer_fetch_noncoherent,GL_QCOM_shader_framebuffer_fetch_rate,GL_QCOM_shading_rate,GL_QCOM_texture_foveated,GL_QCOM_texture_foveated2,GL_QCOM_texture_foveated_subsampled_layout,GL_QCOM_texture_lod_bias,GL_QCOM_tiled_rendering,GL_QCOM_writeonly_rendering,GL_QCOM_ycbcr_degamma,GL_VIV_shader_binary"
    Online:
        Too many extensions
}
unit glad_gl;

{$IF Defined(FPC)}{$MODE Delphi}{$ENDIF}{$H+}

interface

uses
  SysUtils, StrUtils;

var
  glVersionMajor, glVersionMinor: integer;

(* Types *)
type
  GLVULKANPROCNV = pointer;
  GLbitfield = uint32;
  GLboolean = byte;
  GLbyte = int8;
  GLchar = char;
  GLcharARB = byte;
  GLclampd = double;
  GLclampf = single;
  GLclampx = int32;
  GLdouble = double;
  GLeglClientBufferEXT = pointer;
  GLeglImageOES = pointer;
  GLenum = uint32;
  GLfixed = int32;
  GLfloat = single;
  GLhalf = uint16;
  GLhalfARB = uint16;
  GLhalfNV = uint16;
  GLhandleARB = uint32;
  GLint = int32;
  GLint64 = int64;
  GLint64EXT = int64;
  GLintptr = int32;
  GLintptrARB = int32;
  GLshort = int16;
  GLsizei = int32;
  GLsizeiptr = int32;
  GLsizeiptrARB = int32;
  GLsync = pointer;
  GLubyte = uint8;
  GLuint = uint32;
  GLuint64 = uint64;
  GLuint64EXT = uint64;
  GLushort = uint16;
  GLvdpauSurfaceNV = int32;
  GLvoid = pointer;
  _cl_context = pointer;
  _cl_event = pointer;

  PGLVULKANPROCNV = ^pointer;
  PGLbitfield = ^uint32;
  PGLboolean = ^byte;
  PGLbyte = ^int8;
  PGLchar = ^char;
  PGLcharARB = ^byte;
  PGLclampd = ^double;
  PGLclampf = ^single;
  PGLclampx = ^int32;
  PGLdouble = ^double;
  PGLeglClientBufferEXT = ^pointer;
  PGLeglImageOES = ^pointer;
  PGLenum = ^uint32;
  PGLfixed = ^int32;
  PGLfloat = ^single;
  PGLhalf = ^uint16;
  PGLhalfARB = ^uint16;
  PGLhalfNV = ^uint16;
  PGLhandleARB = ^uint32;
  PGLint = ^int32;
  PGLint64 = ^int64;
  PGLint64EXT = ^int64;
  PGLintptr = ^int32;
  PGLintptrARB = ^int32;
  PGLshort = ^int16;
  PGLsizei = ^int32;
  PGLsizeiptr = ^int32;
  PGLsizeiptrARB = ^int32;
  PGLsync = ^pointer;
  PGLubyte = ^uint8;
  PGLuint = ^uint32;
  PGLuint64 = ^uint64;
  PGLuint64EXT = ^uint64;
  PGLushort = ^uint16;
  PGLvdpauSurfaceNV = ^int32;
  PGLvoid = ^pointer;
  P_cl_context = ^pointer;
  P_cl_event = ^pointer;
  PPGLchar = ^PGLchar;
  PPGLcharARB = ^PGLcharARB;
  PPGLboolean = ^PGLboolean;

  GLdebugProc = procedure (
    source: GLenum;
    typ: GLenum;
    id: GLuint;
    severity: GLenum;
    length: GLsizei;
    message: PGLchar;
    userParam: pointer); stdcall;
  GLdebugProcArb = GLdebugProc;
  GLdebugProcKhr = GLdebugProc;

  GLdebugProcAmd = procedure (
    id: GLuint;
    category: GLenum;
    severity: GLenum;
    len: GLsizei;
    message: PGLchar;
    userParam: pointer); stdcall;


(* Enums *)
const
  GL_FALSE = 0;
  GL_INVALID_INDEX = uint32($FFFFFFFF);
  GL_NONE = 0;
  GL_NONE_OES = 0;
  GL_NO_ERROR = 0;
  GL_ONE = 1;
  GL_TIMEOUT_IGNORED = uint64($FFFFFFFFFFFFFFFF);
  GL_TIMEOUT_IGNORED_APPLE = uint64($FFFFFFFFFFFFFFFF);
  GL_TRUE = 1;
  GL_VERSION_ES_CL_1_0 = 1;
  GL_VERSION_ES_CL_1_1 = 1;
  GL_VERSION_ES_CM_1_1 = 1;
  GL_ZERO = 0;

  GL_DEPTH_BUFFER_BIT = $00000100;
  GL_STENCIL_BUFFER_BIT = $00000400;
  GL_COLOR_BUFFER_BIT = $00004000;
  GL_POINTS = $0000;
  GL_LINES = $0001;
  GL_LINE_LOOP = $0002;
  GL_LINE_STRIP = $0003;
  GL_TRIANGLES = $0004;
  GL_TRIANGLE_STRIP = $0005;
  GL_TRIANGLE_FAN = $0006;
  GL_SRC_COLOR = $0300;
  GL_ONE_MINUS_SRC_COLOR = $0301;
  GL_SRC_ALPHA = $0302;
  GL_ONE_MINUS_SRC_ALPHA = $0303;
  GL_DST_ALPHA = $0304;
  GL_ONE_MINUS_DST_ALPHA = $0305;
  GL_DST_COLOR = $0306;
  GL_ONE_MINUS_DST_COLOR = $0307;
  GL_SRC_ALPHA_SATURATE = $0308;
  GL_FUNC_ADD = $8006;
  GL_BLEND_EQUATION = $8009;
  GL_BLEND_EQUATION_RGB = $8009;
  GL_BLEND_EQUATION_ALPHA = $883D;
  GL_FUNC_SUBTRACT = $800A;
  GL_FUNC_REVERSE_SUBTRACT = $800B;
  GL_BLEND_DST_RGB = $80C8;
  GL_BLEND_SRC_RGB = $80C9;
  GL_BLEND_DST_ALPHA = $80CA;
  GL_BLEND_SRC_ALPHA = $80CB;
  GL_CONSTANT_COLOR = $8001;
  GL_ONE_MINUS_CONSTANT_COLOR = $8002;
  GL_CONSTANT_ALPHA = $8003;
  GL_ONE_MINUS_CONSTANT_ALPHA = $8004;
  GL_BLEND_COLOR = $8005;
  GL_ARRAY_BUFFER = $8892;
  GL_ELEMENT_ARRAY_BUFFER = $8893;
  GL_ARRAY_BUFFER_BINDING = $8894;
  GL_ELEMENT_ARRAY_BUFFER_BINDING = $8895;
  GL_STREAM_DRAW = $88E0;
  GL_STATIC_DRAW = $88E4;
  GL_DYNAMIC_DRAW = $88E8;
  GL_BUFFER_SIZE = $8764;
  GL_BUFFER_USAGE = $8765;
  GL_CURRENT_VERTEX_ATTRIB = $8626;
  GL_FRONT = $0404;
  GL_BACK = $0405;
  GL_FRONT_AND_BACK = $0408;
  GL_TEXTURE_2D = $0DE1;
  GL_CULL_FACE = $0B44;
  GL_BLEND = $0BE2;
  GL_DITHER = $0BD0;
  GL_STENCIL_TEST = $0B90;
  GL_DEPTH_TEST = $0B71;
  GL_SCISSOR_TEST = $0C11;
  GL_POLYGON_OFFSET_FILL = $8037;
  GL_SAMPLE_ALPHA_TO_COVERAGE = $809E;
  GL_SAMPLE_COVERAGE = $80A0;
  GL_INVALID_ENUM = $0500;
  GL_INVALID_VALUE = $0501;
  GL_INVALID_OPERATION = $0502;
  GL_OUT_OF_MEMORY = $0505;
  GL_CW = $0900;
  GL_CCW = $0901;
  GL_LINE_WIDTH = $0B21;
  GL_ALIASED_POINT_SIZE_RANGE = $846D;
  GL_ALIASED_LINE_WIDTH_RANGE = $846E;
  GL_CULL_FACE_MODE = $0B45;
  GL_FRONT_FACE = $0B46;
  GL_DEPTH_RANGE = $0B70;
  GL_DEPTH_WRITEMASK = $0B72;
  GL_DEPTH_CLEAR_VALUE = $0B73;
  GL_DEPTH_FUNC = $0B74;
  GL_STENCIL_CLEAR_VALUE = $0B91;
  GL_STENCIL_FUNC = $0B92;
  GL_STENCIL_FAIL = $0B94;
  GL_STENCIL_PASS_DEPTH_FAIL = $0B95;
  GL_STENCIL_PASS_DEPTH_PASS = $0B96;
  GL_STENCIL_REF = $0B97;
  GL_STENCIL_VALUE_MASK = $0B93;
  GL_STENCIL_WRITEMASK = $0B98;
  GL_STENCIL_BACK_FUNC = $8800;
  GL_STENCIL_BACK_FAIL = $8801;
  GL_STENCIL_BACK_PASS_DEPTH_FAIL = $8802;
  GL_STENCIL_BACK_PASS_DEPTH_PASS = $8803;
  GL_STENCIL_BACK_REF = $8CA3;
  GL_STENCIL_BACK_VALUE_MASK = $8CA4;
  GL_STENCIL_BACK_WRITEMASK = $8CA5;
  GL_VIEWPORT = $0BA2;
  GL_SCISSOR_BOX = $0C10;
  GL_COLOR_CLEAR_VALUE = $0C22;
  GL_COLOR_WRITEMASK = $0C23;
  GL_UNPACK_ALIGNMENT = $0CF5;
  GL_PACK_ALIGNMENT = $0D05;
  GL_MAX_TEXTURE_SIZE = $0D33;
  GL_MAX_VIEWPORT_DIMS = $0D3A;
  GL_SUBPIXEL_BITS = $0D50;
  GL_RED_BITS = $0D52;
  GL_GREEN_BITS = $0D53;
  GL_BLUE_BITS = $0D54;
  GL_ALPHA_BITS = $0D55;
  GL_DEPTH_BITS = $0D56;
  GL_STENCIL_BITS = $0D57;
  GL_POLYGON_OFFSET_UNITS = $2A00;
  GL_POLYGON_OFFSET_FACTOR = $8038;
  GL_TEXTURE_BINDING_2D = $8069;
  GL_SAMPLE_BUFFERS = $80A8;
  GL_SAMPLES = $80A9;
  GL_SAMPLE_COVERAGE_VALUE = $80AA;
  GL_SAMPLE_COVERAGE_INVERT = $80AB;
  GL_NUM_COMPRESSED_TEXTURE_FORMATS = $86A2;
  GL_COMPRESSED_TEXTURE_FORMATS = $86A3;
  GL_DONT_CARE = $1100;
  GL_FASTEST = $1101;
  GL_NICEST = $1102;
  GL_GENERATE_MIPMAP_HINT = $8192;
  GL_BYTE = $1400;
  GL_UNSIGNED_BYTE = $1401;
  GL_SHORT = $1402;
  GL_UNSIGNED_SHORT = $1403;
  GL_INT = $1404;
  GL_UNSIGNED_INT = $1405;
  GL_FLOAT = $1406;
  GL_FIXED = $140C;
  GL_DEPTH_COMPONENT = $1902;
  GL_ALPHA = $1906;
  GL_RGB = $1907;
  GL_RGBA = $1908;
  GL_LUMINANCE = $1909;
  GL_LUMINANCE_ALPHA = $190A;
  GL_UNSIGNED_SHORT_4_4_4_4 = $8033;
  GL_UNSIGNED_SHORT_5_5_5_1 = $8034;
  GL_UNSIGNED_SHORT_5_6_5 = $8363;
  GL_FRAGMENT_SHADER = $8B30;
  GL_VERTEX_SHADER = $8B31;
  GL_MAX_VERTEX_ATTRIBS = $8869;
  GL_MAX_VERTEX_UNIFORM_VECTORS = $8DFB;
  GL_MAX_VARYING_VECTORS = $8DFC;
  GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS = $8B4D;
  GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS = $8B4C;
  GL_MAX_TEXTURE_IMAGE_UNITS = $8872;
  GL_MAX_FRAGMENT_UNIFORM_VECTORS = $8DFD;
  GL_SHADER_TYPE = $8B4F;
  GL_DELETE_STATUS = $8B80;
  GL_LINK_STATUS = $8B82;
  GL_VALIDATE_STATUS = $8B83;
  GL_ATTACHED_SHADERS = $8B85;
  GL_ACTIVE_UNIFORMS = $8B86;
  GL_ACTIVE_UNIFORM_MAX_LENGTH = $8B87;
  GL_ACTIVE_ATTRIBUTES = $8B89;
  GL_ACTIVE_ATTRIBUTE_MAX_LENGTH = $8B8A;
  GL_SHADING_LANGUAGE_VERSION = $8B8C;
  GL_CURRENT_PROGRAM = $8B8D;
  GL_NEVER = $0200;
  GL_LESS = $0201;
  GL_EQUAL = $0202;
  GL_LEQUAL = $0203;
  GL_GREATER = $0204;
  GL_NOTEQUAL = $0205;
  GL_GEQUAL = $0206;
  GL_ALWAYS = $0207;
  GL_KEEP = $1E00;
  GL_REPLACE = $1E01;
  GL_INCR = $1E02;
  GL_DECR = $1E03;
  GL_INVERT = $150A;
  GL_INCR_WRAP = $8507;
  GL_DECR_WRAP = $8508;
  GL_VENDOR = $1F00;
  GL_RENDERER = $1F01;
  GL_VERSION = $1F02;
  GL_EXTENSIONS = $1F03;
  GL_NEAREST = $2600;
  GL_LINEAR = $2601;
  GL_NEAREST_MIPMAP_NEAREST = $2700;
  GL_LINEAR_MIPMAP_NEAREST = $2701;
  GL_NEAREST_MIPMAP_LINEAR = $2702;
  GL_LINEAR_MIPMAP_LINEAR = $2703;
  GL_TEXTURE_MAG_FILTER = $2800;
  GL_TEXTURE_MIN_FILTER = $2801;
  GL_TEXTURE_WRAP_S = $2802;
  GL_TEXTURE_WRAP_T = $2803;
  GL_TEXTURE = $1702;
  GL_TEXTURE_CUBE_MAP = $8513;
  GL_TEXTURE_BINDING_CUBE_MAP = $8514;
  GL_TEXTURE_CUBE_MAP_POSITIVE_X = $8515;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_X = $8516;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Y = $8517;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = $8518;
  GL_TEXTURE_CUBE_MAP_POSITIVE_Z = $8519;
  GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = $851A;
  GL_MAX_CUBE_MAP_TEXTURE_SIZE = $851C;
  GL_TEXTURE0 = $84C0;
  GL_TEXTURE1 = $84C1;
  GL_TEXTURE2 = $84C2;
  GL_TEXTURE3 = $84C3;
  GL_TEXTURE4 = $84C4;
  GL_TEXTURE5 = $84C5;
  GL_TEXTURE6 = $84C6;
  GL_TEXTURE7 = $84C7;
  GL_TEXTURE8 = $84C8;
  GL_TEXTURE9 = $84C9;
  GL_TEXTURE10 = $84CA;
  GL_TEXTURE11 = $84CB;
  GL_TEXTURE12 = $84CC;
  GL_TEXTURE13 = $84CD;
  GL_TEXTURE14 = $84CE;
  GL_TEXTURE15 = $84CF;
  GL_TEXTURE16 = $84D0;
  GL_TEXTURE17 = $84D1;
  GL_TEXTURE18 = $84D2;
  GL_TEXTURE19 = $84D3;
  GL_TEXTURE20 = $84D4;
  GL_TEXTURE21 = $84D5;
  GL_TEXTURE22 = $84D6;
  GL_TEXTURE23 = $84D7;
  GL_TEXTURE24 = $84D8;
  GL_TEXTURE25 = $84D9;
  GL_TEXTURE26 = $84DA;
  GL_TEXTURE27 = $84DB;
  GL_TEXTURE28 = $84DC;
  GL_TEXTURE29 = $84DD;
  GL_TEXTURE30 = $84DE;
  GL_TEXTURE31 = $84DF;
  GL_ACTIVE_TEXTURE = $84E0;
  GL_REPEAT = $2901;
  GL_CLAMP_TO_EDGE = $812F;
  GL_MIRRORED_REPEAT = $8370;
  GL_FLOAT_VEC2 = $8B50;
  GL_FLOAT_VEC3 = $8B51;
  GL_FLOAT_VEC4 = $8B52;
  GL_INT_VEC2 = $8B53;
  GL_INT_VEC3 = $8B54;
  GL_INT_VEC4 = $8B55;
  GL_BOOL = $8B56;
  GL_BOOL_VEC2 = $8B57;
  GL_BOOL_VEC3 = $8B58;
  GL_BOOL_VEC4 = $8B59;
  GL_FLOAT_MAT2 = $8B5A;
  GL_FLOAT_MAT3 = $8B5B;
  GL_FLOAT_MAT4 = $8B5C;
  GL_SAMPLER_2D = $8B5E;
  GL_SAMPLER_CUBE = $8B60;
  GL_VERTEX_ATTRIB_ARRAY_ENABLED = $8622;
  GL_VERTEX_ATTRIB_ARRAY_SIZE = $8623;
  GL_VERTEX_ATTRIB_ARRAY_STRIDE = $8624;
  GL_VERTEX_ATTRIB_ARRAY_TYPE = $8625;
  GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = $886A;
  GL_VERTEX_ATTRIB_ARRAY_POINTER = $8645;
  GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = $889F;
  GL_IMPLEMENTATION_COLOR_READ_TYPE = $8B9A;
  GL_IMPLEMENTATION_COLOR_READ_FORMAT = $8B9B;
  GL_COMPILE_STATUS = $8B81;
  GL_INFO_LOG_LENGTH = $8B84;
  GL_SHADER_SOURCE_LENGTH = $8B88;
  GL_SHADER_COMPILER = $8DFA;
  GL_SHADER_BINARY_FORMATS = $8DF8;
  GL_NUM_SHADER_BINARY_FORMATS = $8DF9;
  GL_LOW_FLOAT = $8DF0;
  GL_MEDIUM_FLOAT = $8DF1;
  GL_HIGH_FLOAT = $8DF2;
  GL_LOW_INT = $8DF3;
  GL_MEDIUM_INT = $8DF4;
  GL_HIGH_INT = $8DF5;
  GL_FRAMEBUFFER = $8D40;
  GL_RENDERBUFFER = $8D41;
  GL_RGBA4 = $8056;
  GL_RGB5_A1 = $8057;
  GL_RGB565 = $8D62;
  GL_DEPTH_COMPONENT16 = $81A5;
  GL_STENCIL_INDEX8 = $8D48;
  GL_RENDERBUFFER_WIDTH = $8D42;
  GL_RENDERBUFFER_HEIGHT = $8D43;
  GL_RENDERBUFFER_INTERNAL_FORMAT = $8D44;
  GL_RENDERBUFFER_RED_SIZE = $8D50;
  GL_RENDERBUFFER_GREEN_SIZE = $8D51;
  GL_RENDERBUFFER_BLUE_SIZE = $8D52;
  GL_RENDERBUFFER_ALPHA_SIZE = $8D53;
  GL_RENDERBUFFER_DEPTH_SIZE = $8D54;
  GL_RENDERBUFFER_STENCIL_SIZE = $8D55;
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = $8CD0;
  GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = $8CD1;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = $8CD2;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = $8CD3;
  GL_COLOR_ATTACHMENT0 = $8CE0;
  GL_DEPTH_ATTACHMENT = $8D00;
  GL_STENCIL_ATTACHMENT = $8D20;
  GL_FRAMEBUFFER_COMPLETE = $8CD5;
  GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT = $8CD6;
  GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = $8CD7;
  GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS = $8CD9;
  GL_FRAMEBUFFER_UNSUPPORTED = $8CDD;
  GL_FRAMEBUFFER_BINDING = $8CA6;
  GL_RENDERBUFFER_BINDING = $8CA7;
  GL_MAX_RENDERBUFFER_SIZE = $84E8;
  GL_INVALID_FRAMEBUFFER_OPERATION = $0506;
  GL_READ_BUFFER = $0C02;
  GL_UNPACK_ROW_LENGTH = $0CF2;
  GL_UNPACK_SKIP_ROWS = $0CF3;
  GL_UNPACK_SKIP_PIXELS = $0CF4;
  GL_PACK_ROW_LENGTH = $0D02;
  GL_PACK_SKIP_ROWS = $0D03;
  GL_PACK_SKIP_PIXELS = $0D04;
  GL_COLOR = $1800;
  GL_DEPTH = $1801;
  GL_STENCIL = $1802;
  GL_RED = $1903;
  GL_RGB8 = $8051;
  GL_RGBA8 = $8058;
  GL_RGB10_A2 = $8059;
  GL_TEXTURE_BINDING_3D = $806A;
  GL_UNPACK_SKIP_IMAGES = $806D;
  GL_UNPACK_IMAGE_HEIGHT = $806E;
  GL_TEXTURE_3D = $806F;
  GL_TEXTURE_WRAP_R = $8072;
  GL_MAX_3D_TEXTURE_SIZE = $8073;
  GL_UNSIGNED_INT_2_10_10_10_REV = $8368;
  GL_MAX_ELEMENTS_VERTICES = $80E8;
  GL_MAX_ELEMENTS_INDICES = $80E9;
  GL_TEXTURE_MIN_LOD = $813A;
  GL_TEXTURE_MAX_LOD = $813B;
  GL_TEXTURE_BASE_LEVEL = $813C;
  GL_TEXTURE_MAX_LEVEL = $813D;
  GL_MIN = $8007;
  GL_MAX = $8008;
  GL_DEPTH_COMPONENT24 = $81A6;
  GL_MAX_TEXTURE_LOD_BIAS = $84FD;
  GL_TEXTURE_COMPARE_MODE = $884C;
  GL_TEXTURE_COMPARE_FUNC = $884D;
  GL_CURRENT_QUERY = $8865;
  GL_QUERY_RESULT = $8866;
  GL_QUERY_RESULT_AVAILABLE = $8867;
  GL_BUFFER_MAPPED = $88BC;
  GL_BUFFER_MAP_POINTER = $88BD;
  GL_STREAM_READ = $88E1;
  GL_STREAM_COPY = $88E2;
  GL_STATIC_READ = $88E5;
  GL_STATIC_COPY = $88E6;
  GL_DYNAMIC_READ = $88E9;
  GL_DYNAMIC_COPY = $88EA;
  GL_MAX_DRAW_BUFFERS = $8824;
  GL_DRAW_BUFFER0 = $8825;
  GL_DRAW_BUFFER1 = $8826;
  GL_DRAW_BUFFER2 = $8827;
  GL_DRAW_BUFFER3 = $8828;
  GL_DRAW_BUFFER4 = $8829;
  GL_DRAW_BUFFER5 = $882A;
  GL_DRAW_BUFFER6 = $882B;
  GL_DRAW_BUFFER7 = $882C;
  GL_DRAW_BUFFER8 = $882D;
  GL_DRAW_BUFFER9 = $882E;
  GL_DRAW_BUFFER10 = $882F;
  GL_DRAW_BUFFER11 = $8830;
  GL_DRAW_BUFFER12 = $8831;
  GL_DRAW_BUFFER13 = $8832;
  GL_DRAW_BUFFER14 = $8833;
  GL_DRAW_BUFFER15 = $8834;
  GL_MAX_FRAGMENT_UNIFORM_COMPONENTS = $8B49;
  GL_MAX_VERTEX_UNIFORM_COMPONENTS = $8B4A;
  GL_SAMPLER_3D = $8B5F;
  GL_SAMPLER_2D_SHADOW = $8B62;
  GL_FRAGMENT_SHADER_DERIVATIVE_HINT = $8B8B;
  GL_PIXEL_PACK_BUFFER = $88EB;
  GL_PIXEL_UNPACK_BUFFER = $88EC;
  GL_PIXEL_PACK_BUFFER_BINDING = $88ED;
  GL_PIXEL_UNPACK_BUFFER_BINDING = $88EF;
  GL_FLOAT_MAT2x3 = $8B65;
  GL_FLOAT_MAT2x4 = $8B66;
  GL_FLOAT_MAT3x2 = $8B67;
  GL_FLOAT_MAT3x4 = $8B68;
  GL_FLOAT_MAT4x2 = $8B69;
  GL_FLOAT_MAT4x3 = $8B6A;
  GL_SRGB = $8C40;
  GL_SRGB8 = $8C41;
  GL_SRGB8_ALPHA8 = $8C43;
  GL_COMPARE_REF_TO_TEXTURE = $884E;
  GL_MAJOR_VERSION = $821B;
  GL_MINOR_VERSION = $821C;
  GL_NUM_EXTENSIONS = $821D;
  GL_RGBA32F = $8814;
  GL_RGB32F = $8815;
  GL_RGBA16F = $881A;
  GL_RGB16F = $881B;
  GL_VERTEX_ATTRIB_ARRAY_INTEGER = $88FD;
  GL_MAX_ARRAY_TEXTURE_LAYERS = $88FF;
  GL_MIN_PROGRAM_TEXEL_OFFSET = $8904;
  GL_MAX_PROGRAM_TEXEL_OFFSET = $8905;
  GL_MAX_VARYING_COMPONENTS = $8B4B;
  GL_TEXTURE_2D_ARRAY = $8C1A;
  GL_TEXTURE_BINDING_2D_ARRAY = $8C1D;
  GL_R11F_G11F_B10F = $8C3A;
  GL_UNSIGNED_INT_10F_11F_11F_REV = $8C3B;
  GL_RGB9_E5 = $8C3D;
  GL_UNSIGNED_INT_5_9_9_9_REV = $8C3E;
  GL_TRANSFORM_FEEDBACK_VARYING_MAX_LENGTH = $8C76;
  GL_TRANSFORM_FEEDBACK_BUFFER_MODE = $8C7F;
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = $8C80;
  GL_TRANSFORM_FEEDBACK_VARYINGS = $8C83;
  GL_TRANSFORM_FEEDBACK_BUFFER_START = $8C84;
  GL_TRANSFORM_FEEDBACK_BUFFER_SIZE = $8C85;
  GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = $8C88;
  GL_RASTERIZER_DISCARD = $8C89;
  GL_MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = $8C8A;
  GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = $8C8B;
  GL_INTERLEAVED_ATTRIBS = $8C8C;
  GL_SEPARATE_ATTRIBS = $8C8D;
  GL_TRANSFORM_FEEDBACK_BUFFER = $8C8E;
  GL_TRANSFORM_FEEDBACK_BUFFER_BINDING = $8C8F;
  GL_RGBA32UI = $8D70;
  GL_RGB32UI = $8D71;
  GL_RGBA16UI = $8D76;
  GL_RGB16UI = $8D77;
  GL_RGBA8UI = $8D7C;
  GL_RGB8UI = $8D7D;
  GL_RGBA32I = $8D82;
  GL_RGB32I = $8D83;
  GL_RGBA16I = $8D88;
  GL_RGB16I = $8D89;
  GL_RGBA8I = $8D8E;
  GL_RGB8I = $8D8F;
  GL_RED_INTEGER = $8D94;
  GL_RGB_INTEGER = $8D98;
  GL_RGBA_INTEGER = $8D99;
  GL_SAMPLER_2D_ARRAY = $8DC1;
  GL_SAMPLER_2D_ARRAY_SHADOW = $8DC4;
  GL_SAMPLER_CUBE_SHADOW = $8DC5;
  GL_UNSIGNED_INT_VEC2 = $8DC6;
  GL_UNSIGNED_INT_VEC3 = $8DC7;
  GL_UNSIGNED_INT_VEC4 = $8DC8;
  GL_INT_SAMPLER_2D = $8DCA;
  GL_INT_SAMPLER_3D = $8DCB;
  GL_INT_SAMPLER_CUBE = $8DCC;
  GL_INT_SAMPLER_2D_ARRAY = $8DCF;
  GL_UNSIGNED_INT_SAMPLER_2D = $8DD2;
  GL_UNSIGNED_INT_SAMPLER_3D = $8DD3;
  GL_UNSIGNED_INT_SAMPLER_CUBE = $8DD4;
  GL_UNSIGNED_INT_SAMPLER_2D_ARRAY = $8DD7;
  GL_BUFFER_ACCESS_FLAGS = $911F;
  GL_BUFFER_MAP_LENGTH = $9120;
  GL_BUFFER_MAP_OFFSET = $9121;
  GL_DEPTH_COMPONENT32F = $8CAC;
  GL_DEPTH32F_STENCIL8 = $8CAD;
  GL_FLOAT_32_UNSIGNED_INT_24_8_REV = $8DAD;
  GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = $8210;
  GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = $8211;
  GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE = $8212;
  GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = $8213;
  GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = $8214;
  GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = $8215;
  GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = $8216;
  GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = $8217;
  GL_FRAMEBUFFER_DEFAULT = $8218;
  GL_FRAMEBUFFER_UNDEFINED = $8219;
  GL_DEPTH_STENCIL_ATTACHMENT = $821A;
  GL_DEPTH_STENCIL = $84F9;
  GL_UNSIGNED_INT_24_8 = $84FA;
  GL_DEPTH24_STENCIL8 = $88F0;
  GL_UNSIGNED_NORMALIZED = $8C17;
  GL_DRAW_FRAMEBUFFER_BINDING = $8CA6;
  GL_READ_FRAMEBUFFER = $8CA8;
  GL_DRAW_FRAMEBUFFER = $8CA9;
  GL_READ_FRAMEBUFFER_BINDING = $8CAA;
  GL_RENDERBUFFER_SAMPLES = $8CAB;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = $8CD4;
  GL_MAX_COLOR_ATTACHMENTS = $8CDF;
  GL_COLOR_ATTACHMENT1 = $8CE1;
  GL_COLOR_ATTACHMENT2 = $8CE2;
  GL_COLOR_ATTACHMENT3 = $8CE3;
  GL_COLOR_ATTACHMENT4 = $8CE4;
  GL_COLOR_ATTACHMENT5 = $8CE5;
  GL_COLOR_ATTACHMENT6 = $8CE6;
  GL_COLOR_ATTACHMENT7 = $8CE7;
  GL_COLOR_ATTACHMENT8 = $8CE8;
  GL_COLOR_ATTACHMENT9 = $8CE9;
  GL_COLOR_ATTACHMENT10 = $8CEA;
  GL_COLOR_ATTACHMENT11 = $8CEB;
  GL_COLOR_ATTACHMENT12 = $8CEC;
  GL_COLOR_ATTACHMENT13 = $8CED;
  GL_COLOR_ATTACHMENT14 = $8CEE;
  GL_COLOR_ATTACHMENT15 = $8CEF;
  GL_COLOR_ATTACHMENT16 = $8CF0;
  GL_COLOR_ATTACHMENT17 = $8CF1;
  GL_COLOR_ATTACHMENT18 = $8CF2;
  GL_COLOR_ATTACHMENT19 = $8CF3;
  GL_COLOR_ATTACHMENT20 = $8CF4;
  GL_COLOR_ATTACHMENT21 = $8CF5;
  GL_COLOR_ATTACHMENT22 = $8CF6;
  GL_COLOR_ATTACHMENT23 = $8CF7;
  GL_COLOR_ATTACHMENT24 = $8CF8;
  GL_COLOR_ATTACHMENT25 = $8CF9;
  GL_COLOR_ATTACHMENT26 = $8CFA;
  GL_COLOR_ATTACHMENT27 = $8CFB;
  GL_COLOR_ATTACHMENT28 = $8CFC;
  GL_COLOR_ATTACHMENT29 = $8CFD;
  GL_COLOR_ATTACHMENT30 = $8CFE;
  GL_COLOR_ATTACHMENT31 = $8CFF;
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = $8D56;
  GL_MAX_SAMPLES = $8D57;
  GL_HALF_FLOAT = $140B;
  GL_MAP_READ_BIT = $0001;
  GL_MAP_WRITE_BIT = $0002;
  GL_MAP_INVALIDATE_RANGE_BIT = $0004;
  GL_MAP_INVALIDATE_BUFFER_BIT = $0008;
  GL_MAP_FLUSH_EXPLICIT_BIT = $0010;
  GL_MAP_UNSYNCHRONIZED_BIT = $0020;
  GL_RG = $8227;
  GL_RG_INTEGER = $8228;
  GL_R8 = $8229;
  GL_RG8 = $822B;
  GL_R16F = $822D;
  GL_R32F = $822E;
  GL_RG16F = $822F;
  GL_RG32F = $8230;
  GL_R8I = $8231;
  GL_R8UI = $8232;
  GL_R16I = $8233;
  GL_R16UI = $8234;
  GL_R32I = $8235;
  GL_R32UI = $8236;
  GL_RG8I = $8237;
  GL_RG8UI = $8238;
  GL_RG16I = $8239;
  GL_RG16UI = $823A;
  GL_RG32I = $823B;
  GL_RG32UI = $823C;
  GL_VERTEX_ARRAY_BINDING = $85B5;
  GL_R8_SNORM = $8F94;
  GL_RG8_SNORM = $8F95;
  GL_RGB8_SNORM = $8F96;
  GL_RGBA8_SNORM = $8F97;
  GL_SIGNED_NORMALIZED = $8F9C;
  GL_PRIMITIVE_RESTART_FIXED_INDEX = $8D69;
  GL_COPY_READ_BUFFER = $8F36;
  GL_COPY_WRITE_BUFFER = $8F37;
  GL_COPY_READ_BUFFER_BINDING = $8F36;
  GL_COPY_WRITE_BUFFER_BINDING = $8F37;
  GL_UNIFORM_BUFFER = $8A11;
  GL_UNIFORM_BUFFER_BINDING = $8A28;
  GL_UNIFORM_BUFFER_START = $8A29;
  GL_UNIFORM_BUFFER_SIZE = $8A2A;
  GL_MAX_VERTEX_UNIFORM_BLOCKS = $8A2B;
  GL_MAX_FRAGMENT_UNIFORM_BLOCKS = $8A2D;
  GL_MAX_COMBINED_UNIFORM_BLOCKS = $8A2E;
  GL_MAX_UNIFORM_BUFFER_BINDINGS = $8A2F;
  GL_MAX_UNIFORM_BLOCK_SIZE = $8A30;
  GL_MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = $8A31;
  GL_MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = $8A33;
  GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT = $8A34;
  GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH = $8A35;
  GL_ACTIVE_UNIFORM_BLOCKS = $8A36;
  GL_UNIFORM_TYPE = $8A37;
  GL_UNIFORM_SIZE = $8A38;
  GL_UNIFORM_NAME_LENGTH = $8A39;
  GL_UNIFORM_BLOCK_INDEX = $8A3A;
  GL_UNIFORM_OFFSET = $8A3B;
  GL_UNIFORM_ARRAY_STRIDE = $8A3C;
  GL_UNIFORM_MATRIX_STRIDE = $8A3D;
  GL_UNIFORM_IS_ROW_MAJOR = $8A3E;
  GL_UNIFORM_BLOCK_BINDING = $8A3F;
  GL_UNIFORM_BLOCK_DATA_SIZE = $8A40;
  GL_UNIFORM_BLOCK_NAME_LENGTH = $8A41;
  GL_UNIFORM_BLOCK_ACTIVE_UNIFORMS = $8A42;
  GL_UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = $8A43;
  GL_UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = $8A44;
  GL_UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = $8A46;
  GL_MAX_VERTEX_OUTPUT_COMPONENTS = $9122;
  GL_MAX_FRAGMENT_INPUT_COMPONENTS = $9125;
  GL_MAX_SERVER_WAIT_TIMEOUT = $9111;
  GL_OBJECT_TYPE = $9112;
  GL_SYNC_CONDITION = $9113;
  GL_SYNC_STATUS = $9114;
  GL_SYNC_FLAGS = $9115;
  GL_SYNC_FENCE = $9116;
  GL_SYNC_GPU_COMMANDS_COMPLETE = $9117;
  GL_UNSIGNALED = $9118;
  GL_SIGNALED = $9119;
  GL_ALREADY_SIGNALED = $911A;
  GL_TIMEOUT_EXPIRED = $911B;
  GL_CONDITION_SATISFIED = $911C;
  GL_WAIT_FAILED = $911D;
  GL_SYNC_FLUSH_COMMANDS_BIT = $00000001;
  GL_VERTEX_ATTRIB_ARRAY_DIVISOR = $88FE;
  GL_ANY_SAMPLES_PASSED = $8C2F;
  GL_ANY_SAMPLES_PASSED_CONSERVATIVE = $8D6A;
  GL_SAMPLER_BINDING = $8919;
  GL_RGB10_A2UI = $906F;
  GL_TEXTURE_SWIZZLE_R = $8E42;
  GL_TEXTURE_SWIZZLE_G = $8E43;
  GL_TEXTURE_SWIZZLE_B = $8E44;
  GL_TEXTURE_SWIZZLE_A = $8E45;
  GL_GREEN = $1904;
  GL_BLUE = $1905;
  GL_INT_2_10_10_10_REV = $8D9F;
  GL_TRANSFORM_FEEDBACK = $8E22;
  GL_TRANSFORM_FEEDBACK_PAUSED = $8E23;
  GL_TRANSFORM_FEEDBACK_ACTIVE = $8E24;
  GL_TRANSFORM_FEEDBACK_BINDING = $8E25;
  GL_PROGRAM_BINARY_RETRIEVABLE_HINT = $8257;
  GL_PROGRAM_BINARY_LENGTH = $8741;
  GL_NUM_PROGRAM_BINARY_FORMATS = $87FE;
  GL_PROGRAM_BINARY_FORMATS = $87FF;
  GL_COMPRESSED_R11_EAC = $9270;
  GL_COMPRESSED_SIGNED_R11_EAC = $9271;
  GL_COMPRESSED_RG11_EAC = $9272;
  GL_COMPRESSED_SIGNED_RG11_EAC = $9273;
  GL_COMPRESSED_RGB8_ETC2 = $9274;
  GL_COMPRESSED_SRGB8_ETC2 = $9275;
  GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = $9276;
  GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = $9277;
  GL_COMPRESSED_RGBA8_ETC2_EAC = $9278;
  GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = $9279;
  GL_TEXTURE_IMMUTABLE_FORMAT = $912F;
  GL_MAX_ELEMENT_INDEX = $8D6B;
  GL_NUM_SAMPLE_COUNTS = $9380;
  GL_TEXTURE_IMMUTABLE_LEVELS = $82DF;

(* Functions *)
var
  GLAD_GL_ES_VERSION_2_0: boolean;
  GLAD_GL_ES_VERSION_3_0: boolean;

var
  glActiveTexture: procedure (texture: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glAttachShader: procedure (program_: GLuint; shader: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindAttribLocation: procedure (program_: GLuint; index: GLuint; name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindBuffer: procedure (target: GLenum; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindFramebuffer: procedure (target: GLenum; framebuffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindRenderbuffer: procedure (target: GLenum; renderbuffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindTexture: procedure (target: GLenum; texture: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendColor: procedure (red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendEquation: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendEquationSeparate: procedure (modeRGB: GLenum; modeAlpha: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendFunc: procedure (sfactor: GLenum; dfactor: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendFuncSeparate: procedure (sfactorRGB: GLenum; dfactorRGB: GLenum; sfactorAlpha: GLenum; dfactorAlpha: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBufferData: procedure (target: GLenum; size: GLsizeiptr; data: Pointer; usage: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBufferSubData: procedure (target: GLenum; offset: GLintptr; size: GLsizeiptr; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCheckFramebufferStatus: function (target: GLenum): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClear: procedure (mask: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearColor: procedure (red: GLfloat; green: GLfloat; blue: GLfloat; alpha: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearDepthf: procedure (d: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearStencil: procedure (s: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorMask: procedure (red: GLboolean; green: GLboolean; blue: GLboolean; alpha: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompileShader: procedure (shader: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTexImage2D: procedure (target: GLenum; level: GLint; internalformat: GLenum; width: GLsizei; height: GLsizei; border: GLint; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTexSubImage2D: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; width: GLsizei; height: GLsizei; format: GLenum; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTexImage2D: procedure (target: GLenum; level: GLint; internalformat: GLenum; x: GLint; y: GLint; width: GLsizei; height: GLsizei; border: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTexSubImage2D: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateProgram: function (): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateShader: function (type_: GLenum): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCullFace: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteBuffers: procedure (n: GLsizei; buffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteFramebuffers: procedure (n: GLsizei; framebuffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteProgram: procedure (program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteRenderbuffers: procedure (n: GLsizei; renderbuffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteShader: procedure (shader: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteTextures: procedure (n: GLsizei; textures: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDepthFunc: procedure (func: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDepthMask: procedure (flag: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDepthRangef: procedure (n: GLfloat; f: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDetachShader: procedure (program_: GLuint; shader: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDisable: procedure (cap: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDisableVertexAttribArray: procedure (index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawArrays: procedure (mode: GLenum; first: GLint; count: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElements: procedure (mode: GLenum; count: GLsizei; type_: GLenum; indices: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEnable: procedure (cap: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEnableVertexAttribArray: procedure (index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFinish: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFlush: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferRenderbuffer: procedure (target: GLenum; attachment: GLenum; renderbuffertarget: GLenum; renderbuffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTexture2D: procedure (target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFrontFace: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenBuffers: procedure (n: GLsizei; buffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenerateMipmap: procedure (target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenFramebuffers: procedure (n: GLsizei; framebuffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenRenderbuffers: procedure (n: GLsizei; renderbuffers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenTextures: procedure (n: GLsizei; textures: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetActiveAttrib: procedure (program_: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; type_: PGLenum; name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetActiveUniform: procedure (program_: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLint; type_: PGLenum; name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetAttachedShaders: procedure (program_: GLuint; maxCount: GLsizei; count: PGLsizei; shaders: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetAttribLocation: function (program_: GLuint; name: PGLchar): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetBooleanv: procedure (pname: GLenum; data: PGLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetBufferParameteriv: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetError: function (): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFloatv: procedure (pname: GLenum; data: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFramebufferAttachmentParameteriv: procedure (target: GLenum; attachment: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetIntegerv: procedure (pname: GLenum; data: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramiv: procedure (program_: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramInfoLog: procedure (program_: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetRenderbufferParameteriv: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetShaderiv: procedure (shader: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetShaderInfoLog: procedure (shader: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetShaderPrecisionFormat: procedure (shadertype: GLenum; precisiontype: GLenum; range: PGLint; precision: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetShaderSource: procedure (shader: GLuint; bufSize: GLsizei; length: PGLsizei; source: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetString: function (name: GLenum): PGLubyte; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexParameterfv: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexParameteriv: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformfv: procedure (program_: GLuint; location: GLint; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformiv: procedure (program_: GLuint; location: GLint; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformLocation: function (program_: GLuint; name: PGLchar): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribfv: procedure (index: GLuint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribiv: procedure (index: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribPointerv: procedure (index: GLuint; pname: GLenum; pointer: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glHint: procedure (target: GLenum; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsBuffer: function (buffer: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsEnabled: function (cap: GLenum): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsFramebuffer: function (framebuffer: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsProgram: function (program_: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsRenderbuffer: function (renderbuffer: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsShader: function (shader: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsTexture: function (texture: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLineWidth: procedure (width: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLinkProgram: procedure (program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPixelStorei: procedure (pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPolygonOffset: procedure (factor: GLfloat; units: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReadPixels: procedure (x: GLint; y: GLint; width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReleaseShaderCompiler: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRenderbufferStorage: procedure (target: GLenum; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSampleCoverage: procedure (value: GLfloat; invert: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glScissor: procedure (x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShaderBinary: procedure (count: GLsizei; shaders: PGLuint; binaryFormat: GLenum; binary: Pointer; length: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShaderSource: procedure (shader: GLuint; count: GLsizei; string_: PPGLchar; length: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilFunc: procedure (func: GLenum; ref: GLint; mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilFuncSeparate: procedure (face: GLenum; func: GLenum; ref: GLint; mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilMask: procedure (mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilMaskSeparate: procedure (face: GLenum; mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilOp: procedure (fail: GLenum; zfail: GLenum; zpass: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilOpSeparate: procedure (face: GLenum; sfail: GLenum; dpfail: GLenum; dppass: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexImage2D: procedure (target: GLenum; level: GLint; internalformat: GLint; width: GLsizei; height: GLsizei; border: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexParameterf: procedure (target: GLenum; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexParameterfv: procedure (target: GLenum; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexParameteri: procedure (target: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexParameteriv: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexSubImage2D: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1f: procedure (location: GLint; v0: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1fv: procedure (location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1i: procedure (location: GLint; v0: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1iv: procedure (location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2f: procedure (location: GLint; v0: GLfloat; v1: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2fv: procedure (location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2i: procedure (location: GLint; v0: GLint; v1: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2iv: procedure (location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3f: procedure (location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3fv: procedure (location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3i: procedure (location: GLint; v0: GLint; v1: GLint; v2: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3iv: procedure (location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4f: procedure (location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat; v3: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4fv: procedure (location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4i: procedure (location: GLint; v0: GLint; v1: GLint; v2: GLint; v3: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4iv: procedure (location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix2fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix3fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix4fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUseProgram: procedure (program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glValidateProgram: procedure (program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1f: procedure (index: GLuint; x: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib1fv: procedure (index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2f: procedure (index: GLuint; x: GLfloat; y: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib2fv: procedure (index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3f: procedure (index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib3fv: procedure (index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4f: procedure (index: GLuint; x: GLfloat; y: GLfloat; z: GLfloat; w: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttrib4fv: procedure (index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribPointer: procedure (index: GLuint; size: GLint; type_: GLenum; normalized: GLboolean; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glViewport: procedure (x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReadBuffer: procedure (src: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawRangeElements: procedure (mode: GLenum; start: GLuint; end_: GLuint; count: GLsizei; type_: GLenum; indices: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexImage3D: procedure (target: GLenum; level: GLint; internalformat: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; border: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexSubImage3D: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTexSubImage3D: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTexImage3D: procedure (target: GLenum; level: GLint; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; border: GLint; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTexSubImage3D: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; format: GLenum; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenQueries: procedure (n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteQueries: procedure (n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsQuery: function (id: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBeginQuery: procedure (target: GLenum; id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndQuery: procedure (target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryiv: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryObjectuiv: procedure (id: GLuint; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUnmapBuffer: function (target: GLenum): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetBufferPointerv: procedure (target: GLenum; pname: GLenum; params: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawBuffers: procedure (n: GLsizei; bufs: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix2x3fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix3x2fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix2x4fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix4x2fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix3x4fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix4x3fv: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlitFramebuffer: procedure (srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; mask: GLbitfield; filter: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRenderbufferStorageMultisample: procedure (target: GLenum; samples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTextureLayer: procedure (target: GLenum; attachment: GLenum; texture: GLuint; level: GLint; layer: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapBufferRange: function (target: GLenum; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): Pointer; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFlushMappedBufferRange: procedure (target: GLenum; offset: GLintptr; length: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindVertexArray: procedure (array_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteVertexArrays: procedure (n: GLsizei; arrays: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenVertexArrays: procedure (n: GLsizei; arrays: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsVertexArray: function (array_: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetIntegeri_v: procedure (target: GLenum; index: GLuint; data: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBeginTransformFeedback: procedure (primitiveMode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndTransformFeedback: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindBufferRange: procedure (target: GLenum; index: GLuint; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindBufferBase: procedure (target: GLenum; index: GLuint; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTransformFeedbackVaryings: procedure (program_: GLuint; count: GLsizei; varyings: PPGLchar; bufferMode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTransformFeedbackVarying: procedure (program_: GLuint; index: GLuint; bufSize: GLsizei; length: PGLsizei; size: PGLsizei; type_: PGLenum; name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribIPointer: procedure (index: GLuint; size: GLint; type_: GLenum; stride: GLsizei; pointer: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribIiv: procedure (index: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVertexAttribIuiv: procedure (index: GLuint; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI4i: procedure (index: GLuint; x: GLint; y: GLint; z: GLint; w: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI4ui: procedure (index: GLuint; x: GLuint; y: GLuint; z: GLuint; w: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI4iv: procedure (index: GLuint; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribI4uiv: procedure (index: GLuint; v: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformuiv: procedure (program_: GLuint; location: GLint; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFragDataLocation: function (program_: GLuint; name: PGLchar): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1ui: procedure (location: GLint; v0: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2ui: procedure (location: GLint; v0: GLuint; v1: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3ui: procedure (location: GLint; v0: GLuint; v1: GLuint; v2: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4ui: procedure (location: GLint; v0: GLuint; v1: GLuint; v2: GLuint; v3: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1uiv: procedure (location: GLint; count: GLsizei; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2uiv: procedure (location: GLint; count: GLsizei; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3uiv: procedure (location: GLint; count: GLsizei; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4uiv: procedure (location: GLint; count: GLsizei; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearBufferiv: procedure (buffer: GLenum; drawbuffer: GLint; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearBufferuiv: procedure (buffer: GLenum; drawbuffer: GLint; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearBufferfv: procedure (buffer: GLenum; drawbuffer: GLint; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearBufferfi: procedure (buffer: GLenum; drawbuffer: GLint; depth: GLfloat; stencil: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetStringi: function (name: GLenum; index: GLuint): PGLubyte; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyBufferSubData: procedure (readTarget: GLenum; writeTarget: GLenum; readOffset: GLintptr; writeOffset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformIndices: procedure (program_: GLuint; uniformCount: GLsizei; uniformNames: PPGLchar; uniformIndices: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetActiveUniformsiv: procedure (program_: GLuint; uniformCount: GLsizei; uniformIndices: PGLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformBlockIndex: function (program_: GLuint; uniformBlockName: PGLchar): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetActiveUniformBlockiv: procedure (program_: GLuint; uniformBlockIndex: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetActiveUniformBlockName: procedure (program_: GLuint; uniformBlockIndex: GLuint; bufSize: GLsizei; length: PGLsizei; uniformBlockName: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformBlockBinding: procedure (program_: GLuint; uniformBlockIndex: GLuint; uniformBlockBinding: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawArraysInstanced: procedure (mode: GLenum; first: GLint; count: GLsizei; instancecount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElementsInstanced: procedure (mode: GLenum; count: GLsizei; type_: GLenum; indices: Pointer; instancecount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFenceSync: function (condition: GLenum; flags: GLbitfield): GLsync; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsSync: function (sync: GLsync): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteSync: procedure (sync: GLsync); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClientWaitSync: function (sync: GLsync; flags: GLbitfield; timeout: GLuint64): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWaitSync: procedure (sync: GLsync; flags: GLbitfield; timeout: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetInteger64v: procedure (pname: GLenum; data: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSynciv: procedure (sync: GLsync; pname: GLenum; count: GLsizei; length: PGLsizei; values: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetInteger64i_v: procedure (target: GLenum; index: GLuint; data: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetBufferParameteri64v: procedure (target: GLenum; pname: GLenum; params: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenSamplers: procedure (count: GLsizei; samplers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteSamplers: procedure (count: GLsizei; samplers: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsSampler: function (sampler: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindSampler: procedure (unit_: GLuint; sampler: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSamplerParameteri: procedure (sampler: GLuint; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSamplerParameteriv: procedure (sampler: GLuint; pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSamplerParameterf: procedure (sampler: GLuint; pname: GLenum; param: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSamplerParameterfv: procedure (sampler: GLuint; pname: GLenum; param: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSamplerParameteriv: procedure (sampler: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSamplerParameterfv: procedure (sampler: GLuint; pname: GLenum; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribDivisor: procedure (index: GLuint; divisor: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindTransformFeedback: procedure (target: GLenum; id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteTransformFeedbacks: procedure (n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenTransformFeedbacks: procedure (n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsTransformFeedback: function (id: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPauseTransformFeedback: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glResumeTransformFeedback: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramBinary: procedure (program_: GLuint; bufSize: GLsizei; length: PGLsizei; binaryFormat: PGLenum; binary: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramBinary: procedure (program_: GLuint; binaryFormat: GLenum; binary: Pointer; length: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramParameteri: procedure (program_: GLuint; pname: GLenum; value: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glInvalidateFramebuffer: procedure (target: GLenum; numAttachments: GLsizei; attachments: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glInvalidateSubFramebuffer: procedure (target: GLenum; numAttachments: GLsizei; attachments: PGLenum; x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorage2D: procedure (target: GLenum; levels: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorage3D: procedure (target: GLenum; levels: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetInternalformativ: procedure (target: GLenum; internalformat: GLenum; pname: GLenum; count: GLsizei; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}


(* Extensions *)
var
  GLAD_GL_AMD_compressed_3DC_texture: boolean;
const
  GL_3DC_X_AMD = $87F9;
  GL_3DC_XY_AMD = $87FA;
var
  GLAD_GL_AMD_compressed_ATC_texture: boolean;
const
  GL_ATC_RGB_AMD = $8C92;
  GL_ATC_RGBA_EXPLICIT_ALPHA_AMD = $8C93;
  GL_ATC_RGBA_INTERPOLATED_ALPHA_AMD = $87EE;
var
  GLAD_GL_AMD_framebuffer_multisample_advanced: boolean;
const
  GL_RENDERBUFFER_STORAGE_SAMPLES_AMD = $91B2;
  GL_MAX_COLOR_FRAMEBUFFER_SAMPLES_AMD = $91B3;
  GL_MAX_COLOR_FRAMEBUFFER_STORAGE_SAMPLES_AMD = $91B4;
  GL_MAX_DEPTH_STENCIL_FRAMEBUFFER_SAMPLES_AMD = $91B5;
  GL_NUM_SUPPORTED_MULTISAMPLE_MODES_AMD = $91B6;
  GL_SUPPORTED_MULTISAMPLE_MODES_AMD = $91B7;
var
  GLAD_GL_AMD_performance_monitor: boolean;
const
  GL_COUNTER_TYPE_AMD = $8BC0;
  GL_COUNTER_RANGE_AMD = $8BC1;
  GL_UNSIGNED_INT64_AMD = $8BC2;
  GL_PERCENTAGE_AMD = $8BC3;
  GL_PERFMON_RESULT_AVAILABLE_AMD = $8BC4;
  GL_PERFMON_RESULT_SIZE_AMD = $8BC5;
  GL_PERFMON_RESULT_AMD = $8BC6;
var
  GLAD_GL_AMD_program_binary_Z400: boolean;
const
  GL_Z400_BINARY_AMD = $8740;
var
  GLAD_GL_ANDROID_extension_pack_es31a: boolean;
var
  GLAD_GL_ANGLE_depth_texture: boolean;
const
  GL_DEPTH_STENCIL_OES = $84F9;
  GL_UNSIGNED_INT_24_8_OES = $84FA;
  GL_DEPTH_COMPONENT32_OES = $81A7;
  GL_DEPTH24_STENCIL8_OES = $88F0;
var
  GLAD_GL_ANGLE_framebuffer_blit: boolean;
const
  GL_READ_FRAMEBUFFER_ANGLE = $8CA8;
  GL_DRAW_FRAMEBUFFER_ANGLE = $8CA9;
  GL_DRAW_FRAMEBUFFER_BINDING_ANGLE = $8CA6;
  GL_READ_FRAMEBUFFER_BINDING_ANGLE = $8CAA;
var
  GLAD_GL_ANGLE_framebuffer_multisample: boolean;
const
  GL_RENDERBUFFER_SAMPLES_ANGLE = $8CAB;
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_ANGLE = $8D56;
  GL_MAX_SAMPLES_ANGLE = $8D57;
var
  GLAD_GL_ANGLE_instanced_arrays: boolean;
const
  GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE = $88FE;
var
  GLAD_GL_ANGLE_pack_reverse_row_order: boolean;
const
  GL_PACK_REVERSE_ROW_ORDER_ANGLE = $93A4;
var
  GLAD_GL_ANGLE_program_binary: boolean;
const
  GL_PROGRAM_BINARY_ANGLE = $93A6;
var
  GLAD_GL_ANGLE_texture_compression_dxt3: boolean;
const
  GL_COMPRESSED_RGBA_S3TC_DXT3_ANGLE = $83F2;
var
  GLAD_GL_ANGLE_texture_compression_dxt5: boolean;
const
  GL_COMPRESSED_RGBA_S3TC_DXT5_ANGLE = $83F3;
var
  GLAD_GL_ANGLE_texture_usage: boolean;
const
  GL_TEXTURE_USAGE_ANGLE = $93A2;
  GL_FRAMEBUFFER_ATTACHMENT_ANGLE = $93A3;
var
  GLAD_GL_ANGLE_translated_shader_source: boolean;
const
  GL_TRANSLATED_SHADER_SOURCE_LENGTH_ANGLE = $93A0;
var
  GLAD_GL_APPLE_clip_distance: boolean;
const
  GL_MAX_CLIP_DISTANCES_APPLE = $0D32;
  GL_CLIP_DISTANCE0_APPLE = $3000;
  GL_CLIP_DISTANCE1_APPLE = $3001;
  GL_CLIP_DISTANCE2_APPLE = $3002;
  GL_CLIP_DISTANCE3_APPLE = $3003;
  GL_CLIP_DISTANCE4_APPLE = $3004;
  GL_CLIP_DISTANCE5_APPLE = $3005;
  GL_CLIP_DISTANCE6_APPLE = $3006;
  GL_CLIP_DISTANCE7_APPLE = $3007;
var
  GLAD_GL_APPLE_color_buffer_packed_float: boolean;
var
  GLAD_GL_APPLE_copy_texture_levels: boolean;
var
  GLAD_GL_APPLE_framebuffer_multisample: boolean;
const
  GL_RENDERBUFFER_SAMPLES_APPLE = $8CAB;
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_APPLE = $8D56;
  GL_MAX_SAMPLES_APPLE = $8D57;
  GL_READ_FRAMEBUFFER_APPLE = $8CA8;
  GL_DRAW_FRAMEBUFFER_APPLE = $8CA9;
  GL_DRAW_FRAMEBUFFER_BINDING_APPLE = $8CA6;
  GL_READ_FRAMEBUFFER_BINDING_APPLE = $8CAA;
var
  GLAD_GL_APPLE_rgb_422: boolean;
const
  GL_RGB_422_APPLE = $8A1F;
  GL_UNSIGNED_SHORT_8_8_APPLE = $85BA;
  GL_UNSIGNED_SHORT_8_8_REV_APPLE = $85BB;
  GL_RGB_RAW_422_APPLE = $8A51;
var
  GLAD_GL_APPLE_sync: boolean;
const
  GL_SYNC_OBJECT_APPLE = $8A53;
  GL_MAX_SERVER_WAIT_TIMEOUT_APPLE = $9111;
  GL_OBJECT_TYPE_APPLE = $9112;
  GL_SYNC_CONDITION_APPLE = $9113;
  GL_SYNC_STATUS_APPLE = $9114;
  GL_SYNC_FLAGS_APPLE = $9115;
  GL_SYNC_FENCE_APPLE = $9116;
  GL_SYNC_GPU_COMMANDS_COMPLETE_APPLE = $9117;
  GL_UNSIGNALED_APPLE = $9118;
  GL_SIGNALED_APPLE = $9119;
  GL_ALREADY_SIGNALED_APPLE = $911A;
  GL_TIMEOUT_EXPIRED_APPLE = $911B;
  GL_CONDITION_SATISFIED_APPLE = $911C;
  GL_WAIT_FAILED_APPLE = $911D;
  GL_SYNC_FLUSH_COMMANDS_BIT_APPLE = $00000001;
var
  GLAD_GL_APPLE_texture_format_BGRA8888: boolean;
const
  GL_BGRA_EXT = $80E1;
  GL_BGRA8_EXT = $93A1;
var
  GLAD_GL_APPLE_texture_max_level: boolean;
const
  GL_TEXTURE_MAX_LEVEL_APPLE = $813D;
var
  GLAD_GL_APPLE_texture_packed_float: boolean;
const
  GL_UNSIGNED_INT_10F_11F_11F_REV_APPLE = $8C3B;
  GL_UNSIGNED_INT_5_9_9_9_REV_APPLE = $8C3E;
  GL_R11F_G11F_B10F_APPLE = $8C3A;
  GL_RGB9_E5_APPLE = $8C3D;
var
  GLAD_GL_ARM_mali_program_binary: boolean;
const
  GL_MALI_PROGRAM_BINARY_ARM = $8F61;
var
  GLAD_GL_ARM_mali_shader_binary: boolean;
const
  GL_MALI_SHADER_BINARY_ARM = $8F60;
var
  GLAD_GL_ARM_rgba8: boolean;
var
  GLAD_GL_ARM_shader_core_properties: boolean;
const
  GL_SHADER_CORE_COUNT_ARM = $96F0;
  GL_SHADER_CORE_ACTIVE_COUNT_ARM = $96F1;
  GL_SHADER_CORE_PRESENT_MASK_ARM = $96F2;
  GL_SHADER_CORE_MAX_WARP_COUNT_ARM = $96F3;
  GL_SHADER_CORE_PIXEL_RATE_ARM = $96F4;
  GL_SHADER_CORE_TEXEL_RATE_ARM = $96F5;
  GL_SHADER_CORE_FMA_RATE_ARM = $96F6;
var
  GLAD_GL_ARM_shader_framebuffer_fetch: boolean;
const
  GL_FETCH_PER_SAMPLE_ARM = $8F65;
  GL_FRAGMENT_SHADER_FRAMEBUFFER_FETCH_MRT_ARM = $8F66;
var
  GLAD_GL_ARM_shader_framebuffer_fetch_depth_stencil: boolean;
var
  GLAD_GL_ARM_texture_unnormalized_coordinates: boolean;
const
  GL_TEXTURE_UNNORMALIZED_COORDINATES_ARM = $8F6A;
var
  GLAD_GL_DMP_program_binary: boolean;
const
  GL_SMAPHS30_PROGRAM_BINARY_DMP = $9251;
  GL_SMAPHS_PROGRAM_BINARY_DMP = $9252;
  GL_DMP_PROGRAM_BINARY_DMP = $9253;
var
  GLAD_GL_DMP_shader_binary: boolean;
const
  GL_SHADER_BINARY_DMP = $9250;
var
  GLAD_GL_EXT_EGL_image_array: boolean;
var
  GLAD_GL_EXT_EGL_image_storage: boolean;
var
  GLAD_GL_EXT_EGL_image_storage_compression: boolean;
const
  GL_SURFACE_COMPRESSION_EXT = $96C0;
  GL_SURFACE_COMPRESSION_FIXED_RATE_NONE_EXT = $96C1;
  GL_SURFACE_COMPRESSION_FIXED_RATE_DEFAULT_EXT = $96C2;
var
  GLAD_GL_EXT_YUV_target: boolean;
const
  GL_SAMPLER_EXTERNAL_2D_Y2Y_EXT = $8BE7;
  GL_TEXTURE_EXTERNAL_OES = $8D65;
  GL_TEXTURE_BINDING_EXTERNAL_OES = $8D67;
  GL_REQUIRED_TEXTURE_IMAGE_UNITS_OES = $8D68;
var
  GLAD_GL_EXT_base_instance: boolean;
var
  GLAD_GL_EXT_blend_func_extended: boolean;
const
  GL_SRC1_COLOR_EXT = $88F9;
  GL_SRC1_ALPHA_EXT = $8589;
  GL_ONE_MINUS_SRC1_COLOR_EXT = $88FA;
  GL_ONE_MINUS_SRC1_ALPHA_EXT = $88FB;
  GL_SRC_ALPHA_SATURATE_EXT = $0308;
  GL_LOCATION_INDEX_EXT = $930F;
  GL_MAX_DUAL_SOURCE_DRAW_BUFFERS_EXT = $88FC;
var
  GLAD_GL_EXT_blend_minmax: boolean;
const
  GL_MIN_EXT = $8007;
  GL_MAX_EXT = $8008;
  GL_FUNC_ADD_EXT = $8006;
  GL_BLEND_EQUATION_EXT = $8009;
var
  GLAD_GL_EXT_buffer_storage: boolean;
const
  GL_MAP_PERSISTENT_BIT_EXT = $0040;
  GL_MAP_COHERENT_BIT_EXT = $0080;
  GL_DYNAMIC_STORAGE_BIT_EXT = $0100;
  GL_CLIENT_STORAGE_BIT_EXT = $0200;
  GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT_EXT = $00004000;
  GL_BUFFER_IMMUTABLE_STORAGE_EXT = $821F;
  GL_BUFFER_STORAGE_FLAGS_EXT = $8220;
var
  GLAD_GL_EXT_clear_texture: boolean;
var
  GLAD_GL_EXT_clip_control: boolean;
const
  GL_LOWER_LEFT_EXT = $8CA1;
  GL_UPPER_LEFT_EXT = $8CA2;
  GL_NEGATIVE_ONE_TO_ONE_EXT = $935E;
  GL_ZERO_TO_ONE_EXT = $935F;
  GL_CLIP_ORIGIN_EXT = $935C;
  GL_CLIP_DEPTH_MODE_EXT = $935D;
var
  GLAD_GL_EXT_clip_cull_distance: boolean;
const
  GL_MAX_CLIP_DISTANCES_EXT = $0D32;
  GL_MAX_CULL_DISTANCES_EXT = $82F9;
  GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES_EXT = $82FA;
  GL_CLIP_DISTANCE0_EXT = $3000;
  GL_CLIP_DISTANCE1_EXT = $3001;
  GL_CLIP_DISTANCE2_EXT = $3002;
  GL_CLIP_DISTANCE3_EXT = $3003;
  GL_CLIP_DISTANCE4_EXT = $3004;
  GL_CLIP_DISTANCE5_EXT = $3005;
  GL_CLIP_DISTANCE6_EXT = $3006;
  GL_CLIP_DISTANCE7_EXT = $3007;
var
  GLAD_GL_EXT_color_buffer_float: boolean;
var
  GLAD_GL_EXT_color_buffer_half_float: boolean;
const
  GL_RGBA16F_EXT = $881A;
  GL_RGB16F_EXT = $881B;
  GL_RG16F_EXT = $822F;
  GL_R16F_EXT = $822D;
  GL_FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT = $8211;
  GL_UNSIGNED_NORMALIZED_EXT = $8C17;
var
  GLAD_GL_EXT_conservative_depth: boolean;
var
  GLAD_GL_EXT_copy_image: boolean;
var
  GLAD_GL_EXT_debug_label: boolean;
const
  GL_PROGRAM_PIPELINE_OBJECT_EXT = $8A4F;
  GL_PROGRAM_OBJECT_EXT = $8B40;
  GL_SHADER_OBJECT_EXT = $8B48;
  GL_BUFFER_OBJECT_EXT = $9151;
  GL_QUERY_OBJECT_EXT = $9153;
  GL_VERTEX_ARRAY_OBJECT_EXT = $9154;
  GL_SAMPLER = $82E6;
var
  GLAD_GL_EXT_debug_marker: boolean;
var
  GLAD_GL_EXT_depth_clamp: boolean;
const
  GL_DEPTH_CLAMP_EXT = $864F;
var
  GLAD_GL_EXT_discard_framebuffer: boolean;
const
  GL_COLOR_EXT = $1800;
  GL_DEPTH_EXT = $1801;
  GL_STENCIL_EXT = $1802;
var
  GLAD_GL_EXT_disjoint_timer_query: boolean;
const
  GL_QUERY_COUNTER_BITS_EXT = $8864;
  GL_CURRENT_QUERY_EXT = $8865;
  GL_QUERY_RESULT_EXT = $8866;
  GL_QUERY_RESULT_AVAILABLE_EXT = $8867;
  GL_TIME_ELAPSED_EXT = $88BF;
  GL_TIMESTAMP_EXT = $8E28;
  GL_GPU_DISJOINT_EXT = $8FBB;
var
  GLAD_GL_EXT_draw_buffers: boolean;
const
  GL_MAX_COLOR_ATTACHMENTS_EXT = $8CDF;
  GL_MAX_DRAW_BUFFERS_EXT = $8824;
  GL_DRAW_BUFFER0_EXT = $8825;
  GL_DRAW_BUFFER1_EXT = $8826;
  GL_DRAW_BUFFER2_EXT = $8827;
  GL_DRAW_BUFFER3_EXT = $8828;
  GL_DRAW_BUFFER4_EXT = $8829;
  GL_DRAW_BUFFER5_EXT = $882A;
  GL_DRAW_BUFFER6_EXT = $882B;
  GL_DRAW_BUFFER7_EXT = $882C;
  GL_DRAW_BUFFER8_EXT = $882D;
  GL_DRAW_BUFFER9_EXT = $882E;
  GL_DRAW_BUFFER10_EXT = $882F;
  GL_DRAW_BUFFER11_EXT = $8830;
  GL_DRAW_BUFFER12_EXT = $8831;
  GL_DRAW_BUFFER13_EXT = $8832;
  GL_DRAW_BUFFER14_EXT = $8833;
  GL_DRAW_BUFFER15_EXT = $8834;
  GL_COLOR_ATTACHMENT0_EXT = $8CE0;
  GL_COLOR_ATTACHMENT1_EXT = $8CE1;
  GL_COLOR_ATTACHMENT2_EXT = $8CE2;
  GL_COLOR_ATTACHMENT3_EXT = $8CE3;
  GL_COLOR_ATTACHMENT4_EXT = $8CE4;
  GL_COLOR_ATTACHMENT5_EXT = $8CE5;
  GL_COLOR_ATTACHMENT6_EXT = $8CE6;
  GL_COLOR_ATTACHMENT7_EXT = $8CE7;
  GL_COLOR_ATTACHMENT8_EXT = $8CE8;
  GL_COLOR_ATTACHMENT9_EXT = $8CE9;
  GL_COLOR_ATTACHMENT10_EXT = $8CEA;
  GL_COLOR_ATTACHMENT11_EXT = $8CEB;
  GL_COLOR_ATTACHMENT12_EXT = $8CEC;
  GL_COLOR_ATTACHMENT13_EXT = $8CED;
  GL_COLOR_ATTACHMENT14_EXT = $8CEE;
  GL_COLOR_ATTACHMENT15_EXT = $8CEF;
var
  GLAD_GL_EXT_draw_buffers_indexed: boolean;
var
  GLAD_GL_EXT_draw_elements_base_vertex: boolean;
var
  GLAD_GL_EXT_draw_instanced: boolean;
var
  GLAD_GL_EXT_draw_transform_feedback: boolean;
var
  GLAD_GL_EXT_external_buffer: boolean;
var
  GLAD_GL_EXT_float_blend: boolean;
var
  GLAD_GL_EXT_fragment_shading_rate: boolean;
const
  GL_SHADING_RATE_1X1_PIXELS_EXT = $96A6;
  GL_SHADING_RATE_1X2_PIXELS_EXT = $96A7;
  GL_SHADING_RATE_2X1_PIXELS_EXT = $96A8;
  GL_SHADING_RATE_2X2_PIXELS_EXT = $96A9;
  GL_SHADING_RATE_1X4_PIXELS_EXT = $96AA;
  GL_SHADING_RATE_4X1_PIXELS_EXT = $96AB;
  GL_SHADING_RATE_4X2_PIXELS_EXT = $96AC;
  GL_SHADING_RATE_2X4_PIXELS_EXT = $96AD;
  GL_SHADING_RATE_4X4_PIXELS_EXT = $96AE;
  GL_SHADING_RATE_EXT = $96D0;
  GL_SHADING_RATE_ATTACHMENT_EXT = $96D1;
  GL_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_EXT = $96D2;
  GL_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_EXT = $96D3;
  GL_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_EXT = $96D4;
  GL_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_EXT = $96D5;
  GL_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_EXT = $96D6;
  GL_MIN_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_WIDTH_EXT = $96D7;
  GL_MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_WIDTH_EXT = $96D8;
  GL_MIN_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_HEIGHT_EXT = $96D9;
  GL_MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_HEIGHT_EXT = $96DA;
  GL_MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_TEXEL_ASPECT_RATIO_EXT = $96DB;
  GL_MAX_FRAGMENT_SHADING_RATE_ATTACHMENT_LAYERS_EXT = $96DC;
  GL_FRAGMENT_SHADING_RATE_WITH_SHADER_DEPTH_STENCIL_WRITES_SUPPORTED_EXT = $96DD;
  GL_FRAGMENT_SHADING_RATE_WITH_SAMPLE_MASK_SUPPORTED_EXT = $96DE;
  GL_FRAGMENT_SHADING_RATE_ATTACHMENT_WITH_DEFAULT_FRAMEBUFFER_SUPPORTED_EXT = $96DF;
  GL_FRAGMENT_SHADING_RATE_NON_TRIVIAL_COMBINERS_SUPPORTED_EXT = $8F6F;
var
  GLAD_GL_EXT_framebuffer_blit_layers: boolean;
var
  GLAD_GL_EXT_geometry_point_size: boolean;
var
  GLAD_GL_EXT_geometry_shader: boolean;
const
  GL_GEOMETRY_SHADER_EXT = $8DD9;
  GL_GEOMETRY_SHADER_BIT_EXT = $00000004;
  GL_GEOMETRY_LINKED_VERTICES_OUT_EXT = $8916;
  GL_GEOMETRY_LINKED_INPUT_TYPE_EXT = $8917;
  GL_GEOMETRY_LINKED_OUTPUT_TYPE_EXT = $8918;
  GL_GEOMETRY_SHADER_INVOCATIONS_EXT = $887F;
  GL_LAYER_PROVOKING_VERTEX_EXT = $825E;
  GL_LINES_ADJACENCY_EXT = $000A;
  GL_LINE_STRIP_ADJACENCY_EXT = $000B;
  GL_TRIANGLES_ADJACENCY_EXT = $000C;
  GL_TRIANGLE_STRIP_ADJACENCY_EXT = $000D;
  GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_EXT = $8DDF;
  GL_MAX_GEOMETRY_UNIFORM_BLOCKS_EXT = $8A2C;
  GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS_EXT = $8A32;
  GL_MAX_GEOMETRY_INPUT_COMPONENTS_EXT = $9123;
  GL_MAX_GEOMETRY_OUTPUT_COMPONENTS_EXT = $9124;
  GL_MAX_GEOMETRY_OUTPUT_VERTICES_EXT = $8DE0;
  GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_EXT = $8DE1;
  GL_MAX_GEOMETRY_SHADER_INVOCATIONS_EXT = $8E5A;
  GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_EXT = $8C29;
  GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_EXT = $92CF;
  GL_MAX_GEOMETRY_ATOMIC_COUNTERS_EXT = $92D5;
  GL_MAX_GEOMETRY_IMAGE_UNIFORMS_EXT = $90CD;
  GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS_EXT = $90D7;
  GL_FIRST_VERTEX_CONVENTION_EXT = $8E4D;
  GL_LAST_VERTEX_CONVENTION_EXT = $8E4E;
  GL_UNDEFINED_VERTEX_EXT = $8260;
  GL_PRIMITIVES_GENERATED_EXT = $8C87;
  GL_FRAMEBUFFER_DEFAULT_LAYERS_EXT = $9312;
  GL_MAX_FRAMEBUFFER_LAYERS_EXT = $9317;
  GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_EXT = $8DA8;
  GL_FRAMEBUFFER_ATTACHMENT_LAYERED_EXT = $8DA7;
  GL_REFERENCED_BY_GEOMETRY_SHADER_EXT = $9309;
var
  GLAD_GL_EXT_gpu_shader5: boolean;
var
  GLAD_GL_EXT_instanced_arrays: boolean;
const
  GL_VERTEX_ATTRIB_ARRAY_DIVISOR_EXT = $88FE;
var
  GLAD_GL_EXT_map_buffer_range: boolean;
const
  GL_MAP_READ_BIT_EXT = $0001;
  GL_MAP_WRITE_BIT_EXT = $0002;
  GL_MAP_INVALIDATE_RANGE_BIT_EXT = $0004;
  GL_MAP_INVALIDATE_BUFFER_BIT_EXT = $0008;
  GL_MAP_FLUSH_EXPLICIT_BIT_EXT = $0010;
  GL_MAP_UNSYNCHRONIZED_BIT_EXT = $0020;
var
  GLAD_GL_EXT_memory_object: boolean;
const
  GL_TEXTURE_TILING_EXT = $9580;
  GL_DEDICATED_MEMORY_OBJECT_EXT = $9581;
  GL_PROTECTED_MEMORY_OBJECT_EXT = $959B;
  GL_NUM_TILING_TYPES_EXT = $9582;
  GL_TILING_TYPES_EXT = $9583;
  GL_OPTIMAL_TILING_EXT = $9584;
  GL_LINEAR_TILING_EXT = $9585;
  GL_NUM_DEVICE_UUIDS_EXT = $9596;
  GL_DEVICE_UUID_EXT = $9597;
  GL_DRIVER_UUID_EXT = $9598;
var
  GLAD_GL_EXT_memory_object_fd: boolean;
const
  GL_HANDLE_TYPE_OPAQUE_FD_EXT = $9586;
var
  GLAD_GL_EXT_memory_object_win32: boolean;
const
  GL_HANDLE_TYPE_OPAQUE_WIN32_EXT = $9587;
  GL_HANDLE_TYPE_OPAQUE_WIN32_KMT_EXT = $9588;
  GL_DEVICE_LUID_EXT = $9599;
  GL_DEVICE_NODE_MASK_EXT = $959A;
  GL_HANDLE_TYPE_D3D12_TILEPOOL_EXT = $9589;
  GL_HANDLE_TYPE_D3D12_RESOURCE_EXT = $958A;
  GL_HANDLE_TYPE_D3D11_IMAGE_EXT = $958B;
  GL_HANDLE_TYPE_D3D11_IMAGE_KMT_EXT = $958C;
var
  GLAD_GL_EXT_multi_draw_arrays: boolean;
var
  GLAD_GL_EXT_multi_draw_indirect: boolean;
var
  GLAD_GL_EXT_multisampled_compatibility: boolean;
const
  GL_MULTISAMPLE_EXT = $809D;
  GL_SAMPLE_ALPHA_TO_ONE_EXT = $809F;
var
  GLAD_GL_EXT_multisampled_render_to_texture: boolean;
const
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_SAMPLES_EXT = $8D6C;
  GL_RENDERBUFFER_SAMPLES_EXT = $8CAB;
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_EXT = $8D56;
  GL_MAX_SAMPLES_EXT = $8D57;
var
  GLAD_GL_EXT_multisampled_render_to_texture2: boolean;
var
  GLAD_GL_EXT_multiview_draw_buffers: boolean;
const
  GL_COLOR_ATTACHMENT_EXT = $90F0;
  GL_MULTIVIEW_EXT = $90F1;
  GL_DRAW_BUFFER_EXT = $0C01;
  GL_READ_BUFFER_EXT = $0C02;
  GL_MAX_MULTIVIEW_BUFFERS_EXT = $90F2;
var
  GLAD_GL_EXT_multiview_tessellation_geometry_shader: boolean;
var
  GLAD_GL_EXT_multiview_texture_multisample: boolean;
var
  GLAD_GL_EXT_multiview_timer_query: boolean;
var
  GLAD_GL_EXT_occlusion_query_boolean: boolean;
const
  GL_ANY_SAMPLES_PASSED_EXT = $8C2F;
  GL_ANY_SAMPLES_PASSED_CONSERVATIVE_EXT = $8D6A;
var
  GLAD_GL_EXT_polygon_offset_clamp: boolean;
const
  GL_POLYGON_OFFSET_CLAMP_EXT = $8E1B;
var
  GLAD_GL_EXT_post_depth_coverage: boolean;
var
  GLAD_GL_EXT_primitive_bounding_box: boolean;
const
  GL_PRIMITIVE_BOUNDING_BOX_EXT = $92BE;
var
  GLAD_GL_EXT_protected_textures: boolean;
const
  GL_CONTEXT_FLAG_PROTECTED_CONTENT_BIT_EXT = $00000010;
  GL_TEXTURE_PROTECTED_EXT = $8BFA;
var
  GLAD_GL_EXT_pvrtc_sRGB: boolean;
const
  GL_COMPRESSED_SRGB_PVRTC_2BPPV1_EXT = $8A54;
  GL_COMPRESSED_SRGB_PVRTC_4BPPV1_EXT = $8A55;
  GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV1_EXT = $8A56;
  GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV1_EXT = $8A57;
  GL_COMPRESSED_SRGB_ALPHA_PVRTC_2BPPV2_IMG = $93F0;
  GL_COMPRESSED_SRGB_ALPHA_PVRTC_4BPPV2_IMG = $93F1;
var
  GLAD_GL_EXT_raster_multisample: boolean;
const
  GL_RASTER_MULTISAMPLE_EXT = $9327;
  GL_RASTER_SAMPLES_EXT = $9328;
  GL_MAX_RASTER_SAMPLES_EXT = $9329;
  GL_RASTER_FIXED_SAMPLE_LOCATIONS_EXT = $932A;
  GL_MULTISAMPLE_RASTERIZATION_ALLOWED_EXT = $932B;
  GL_EFFECTIVE_RASTER_SAMPLES_EXT = $932C;
var
  GLAD_GL_EXT_read_format_bgra: boolean;
const
  GL_UNSIGNED_SHORT_4_4_4_4_REV_EXT = $8365;
  GL_UNSIGNED_SHORT_1_5_5_5_REV_EXT = $8366;
var
  GLAD_GL_EXT_render_snorm: boolean;
const
  GL_R16_SNORM_EXT = $8F98;
  GL_RG16_SNORM_EXT = $8F99;
  GL_RGBA16_SNORM_EXT = $8F9B;
var
  GLAD_GL_EXT_robustness: boolean;
const
  GL_GUILTY_CONTEXT_RESET_EXT = $8253;
  GL_INNOCENT_CONTEXT_RESET_EXT = $8254;
  GL_UNKNOWN_CONTEXT_RESET_EXT = $8255;
  GL_CONTEXT_ROBUST_ACCESS_EXT = $90F3;
  GL_RESET_NOTIFICATION_STRATEGY_EXT = $8256;
  GL_LOSE_CONTEXT_ON_RESET_EXT = $8252;
  GL_NO_RESET_NOTIFICATION_EXT = $8261;
var
  GLAD_GL_EXT_sRGB: boolean;
const
  GL_SRGB_EXT = $8C40;
  GL_SRGB_ALPHA_EXT = $8C42;
  GL_SRGB8_ALPHA8_EXT = $8C43;
  GL_FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT = $8210;
var
  GLAD_GL_EXT_sRGB_write_control: boolean;
const
  GL_FRAMEBUFFER_SRGB_EXT = $8DB9;
var
  GLAD_GL_EXT_semaphore: boolean;
const
  GL_LAYOUT_GENERAL_EXT = $958D;
  GL_LAYOUT_COLOR_ATTACHMENT_EXT = $958E;
  GL_LAYOUT_DEPTH_STENCIL_ATTACHMENT_EXT = $958F;
  GL_LAYOUT_DEPTH_STENCIL_READ_ONLY_EXT = $9590;
  GL_LAYOUT_SHADER_READ_ONLY_EXT = $9591;
  GL_LAYOUT_TRANSFER_SRC_EXT = $9592;
  GL_LAYOUT_TRANSFER_DST_EXT = $9593;
  GL_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_EXT = $9530;
  GL_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_EXT = $9531;
var
  GLAD_GL_EXT_semaphore_fd: boolean;
var
  GLAD_GL_EXT_semaphore_win32: boolean;
const
  GL_HANDLE_TYPE_D3D12_FENCE_EXT = $9594;
  GL_D3D12_FENCE_VALUE_EXT = $9595;
var
  GLAD_GL_EXT_separate_depth_stencil: boolean;
var
  GLAD_GL_EXT_separate_shader_objects: boolean;
const
  GL_ACTIVE_PROGRAM_EXT = $8B8D;
  GL_VERTEX_SHADER_BIT_EXT = $00000001;
  GL_FRAGMENT_SHADER_BIT_EXT = $00000002;
  GL_ALL_SHADER_BITS_EXT = $FFFFFFFF;
  GL_PROGRAM_SEPARABLE_EXT = $8258;
  GL_PROGRAM_PIPELINE_BINDING_EXT = $825A;
var
  GLAD_GL_EXT_shader_framebuffer_fetch: boolean;
const
  GL_FRAGMENT_SHADER_DISCARDS_SAMPLES_EXT = $8A52;
var
  GLAD_GL_EXT_shader_framebuffer_fetch_non_coherent: boolean;
var
  GLAD_GL_EXT_shader_group_vote: boolean;
var
  GLAD_GL_EXT_shader_implicit_conversions: boolean;
var
  GLAD_GL_EXT_shader_integer_mix: boolean;
var
  GLAD_GL_EXT_shader_io_blocks: boolean;
var
  GLAD_GL_EXT_shader_non_constant_global_initializers: boolean;
var
  GLAD_GL_EXT_shader_pixel_local_storage: boolean;
const
  GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_FAST_SIZE_EXT = $8F63;
  GL_MAX_SHADER_PIXEL_LOCAL_STORAGE_SIZE_EXT = $8F67;
  GL_SHADER_PIXEL_LOCAL_STORAGE_EXT = $8F64;
var
  GLAD_GL_EXT_shader_pixel_local_storage2: boolean;
const
  GL_MAX_SHADER_COMBINED_LOCAL_STORAGE_FAST_SIZE_EXT = $9650;
  GL_MAX_SHADER_COMBINED_LOCAL_STORAGE_SIZE_EXT = $9651;
  GL_FRAMEBUFFER_INCOMPLETE_INSUFFICIENT_SHADER_COMBINED_LOCAL_STORAGE_EXT = $9652;
var
  GLAD_GL_EXT_shader_samples_identical: boolean;
var
  GLAD_GL_EXT_shader_texture_lod: boolean;
var
  GLAD_GL_EXT_shadow_samplers: boolean;
const
  GL_TEXTURE_COMPARE_MODE_EXT = $884C;
  GL_TEXTURE_COMPARE_FUNC_EXT = $884D;
  GL_COMPARE_REF_TO_TEXTURE_EXT = $884E;
  GL_SAMPLER_2D_SHADOW_EXT = $8B62;
var
  GLAD_GL_EXT_sparse_texture: boolean;
const
  GL_TEXTURE_SPARSE_EXT = $91A6;
  GL_VIRTUAL_PAGE_SIZE_INDEX_EXT = $91A7;
  GL_NUM_SPARSE_LEVELS_EXT = $91AA;
  GL_NUM_VIRTUAL_PAGE_SIZES_EXT = $91A8;
  GL_VIRTUAL_PAGE_SIZE_X_EXT = $9195;
  GL_VIRTUAL_PAGE_SIZE_Y_EXT = $9196;
  GL_VIRTUAL_PAGE_SIZE_Z_EXT = $9197;
  GL_TEXTURE_CUBE_MAP_ARRAY_OES = $9009;
  GL_MAX_SPARSE_TEXTURE_SIZE_EXT = $9198;
  GL_MAX_SPARSE_3D_TEXTURE_SIZE_EXT = $9199;
  GL_MAX_SPARSE_ARRAY_TEXTURE_LAYERS_EXT = $919A;
  GL_SPARSE_TEXTURE_FULL_ARRAY_CUBE_MIPMAPS_EXT = $91A9;
var
  GLAD_GL_EXT_sparse_texture2: boolean;
var
  GLAD_GL_EXT_tessellation_point_size: boolean;
var
  GLAD_GL_EXT_tessellation_shader: boolean;
const
  GL_PATCHES_EXT = $000E;
  GL_PATCH_VERTICES_EXT = $8E72;
  GL_TESS_CONTROL_OUTPUT_VERTICES_EXT = $8E75;
  GL_TESS_GEN_MODE_EXT = $8E76;
  GL_TESS_GEN_SPACING_EXT = $8E77;
  GL_TESS_GEN_VERTEX_ORDER_EXT = $8E78;
  GL_TESS_GEN_POINT_MODE_EXT = $8E79;
  GL_ISOLINES_EXT = $8E7A;
  GL_QUADS_EXT = $0007;
  GL_FRACTIONAL_ODD_EXT = $8E7B;
  GL_FRACTIONAL_EVEN_EXT = $8E7C;
  GL_MAX_PATCH_VERTICES_EXT = $8E7D;
  GL_MAX_TESS_GEN_LEVEL_EXT = $8E7E;
  GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS_EXT = $8E7F;
  GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS_EXT = $8E80;
  GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_EXT = $8E81;
  GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_EXT = $8E82;
  GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS_EXT = $8E83;
  GL_MAX_TESS_PATCH_COMPONENTS_EXT = $8E84;
  GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS_EXT = $8E85;
  GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS_EXT = $8E86;
  GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS_EXT = $8E89;
  GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS_EXT = $8E8A;
  GL_MAX_TESS_CONTROL_INPUT_COMPONENTS_EXT = $886C;
  GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS_EXT = $886D;
  GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS_EXT = $8E1E;
  GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS_EXT = $8E1F;
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS_EXT = $92CD;
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS_EXT = $92CE;
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS_EXT = $92D3;
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS_EXT = $92D4;
  GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS_EXT = $90CB;
  GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS_EXT = $90CC;
  GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS_EXT = $90D8;
  GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS_EXT = $90D9;
  GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED = $8221;
  GL_IS_PER_PATCH_EXT = $92E7;
  GL_REFERENCED_BY_TESS_CONTROL_SHADER_EXT = $9307;
  GL_REFERENCED_BY_TESS_EVALUATION_SHADER_EXT = $9308;
  GL_TESS_CONTROL_SHADER_EXT = $8E88;
  GL_TESS_EVALUATION_SHADER_EXT = $8E87;
  GL_TESS_CONTROL_SHADER_BIT_EXT = $00000008;
  GL_TESS_EVALUATION_SHADER_BIT_EXT = $00000010;
var
  GLAD_GL_EXT_texture_border_clamp: boolean;
const
  GL_TEXTURE_BORDER_COLOR_EXT = $1004;
  GL_CLAMP_TO_BORDER_EXT = $812D;
var
  GLAD_GL_EXT_texture_buffer: boolean;
const
  GL_TEXTURE_BUFFER_EXT = $8C2A;
  GL_TEXTURE_BUFFER_BINDING_EXT = $8C2A;
  GL_MAX_TEXTURE_BUFFER_SIZE_EXT = $8C2B;
  GL_TEXTURE_BINDING_BUFFER_EXT = $8C2C;
  GL_TEXTURE_BUFFER_DATA_STORE_BINDING_EXT = $8C2D;
  GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT_EXT = $919F;
  GL_SAMPLER_BUFFER_EXT = $8DC2;
  GL_INT_SAMPLER_BUFFER_EXT = $8DD0;
  GL_UNSIGNED_INT_SAMPLER_BUFFER_EXT = $8DD8;
  GL_IMAGE_BUFFER_EXT = $9051;
  GL_INT_IMAGE_BUFFER_EXT = $905C;
  GL_UNSIGNED_INT_IMAGE_BUFFER_EXT = $9067;
  GL_TEXTURE_BUFFER_OFFSET_EXT = $919D;
  GL_TEXTURE_BUFFER_SIZE_EXT = $919E;
var
  GLAD_GL_EXT_texture_compression_astc_decode_mode: boolean;
const
  GL_TEXTURE_ASTC_DECODE_PRECISION_EXT = $8F69;
var
  GLAD_GL_EXT_texture_compression_bptc: boolean;
const
  GL_COMPRESSED_RGBA_BPTC_UNORM_EXT = $8E8C;
  GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = $8E8D;
  GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = $8E8E;
  GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = $8E8F;
var
  GLAD_GL_EXT_texture_compression_dxt1: boolean;
const
  GL_COMPRESSED_RGB_S3TC_DXT1_EXT = $83F0;
  GL_COMPRESSED_RGBA_S3TC_DXT1_EXT = $83F1;
var
  GLAD_GL_EXT_texture_compression_rgtc: boolean;
const
  GL_COMPRESSED_RED_RGTC1_EXT = $8DBB;
  GL_COMPRESSED_SIGNED_RED_RGTC1_EXT = $8DBC;
  GL_COMPRESSED_RED_GREEN_RGTC2_EXT = $8DBD;
  GL_COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = $8DBE;
var
  GLAD_GL_EXT_texture_compression_s3tc: boolean;
const
  GL_COMPRESSED_RGBA_S3TC_DXT3_EXT = $83F2;
  GL_COMPRESSED_RGBA_S3TC_DXT5_EXT = $83F3;
var
  GLAD_GL_EXT_texture_compression_s3tc_srgb: boolean;
const
  GL_COMPRESSED_SRGB_S3TC_DXT1_EXT = $8C4C;
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = $8C4D;
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = $8C4E;
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = $8C4F;
var
  GLAD_GL_EXT_texture_cube_map_array: boolean;
const
  GL_TEXTURE_CUBE_MAP_ARRAY_EXT = $9009;
  GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_EXT = $900A;
  GL_SAMPLER_CUBE_MAP_ARRAY_EXT = $900C;
  GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_EXT = $900D;
  GL_INT_SAMPLER_CUBE_MAP_ARRAY_EXT = $900E;
  GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_EXT = $900F;
  GL_IMAGE_CUBE_MAP_ARRAY_EXT = $9054;
  GL_INT_IMAGE_CUBE_MAP_ARRAY_EXT = $905F;
  GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_EXT = $906A;
var
  GLAD_GL_EXT_texture_filter_anisotropic: boolean;
const
  GL_TEXTURE_MAX_ANISOTROPY_EXT = $84FE;
  GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = $84FF;
var
  GLAD_GL_EXT_texture_filter_minmax: boolean;
const
  GL_TEXTURE_REDUCTION_MODE_EXT = $9366;
  GL_WEIGHTED_AVERAGE_EXT = $9367;
var
  GLAD_GL_EXT_texture_format_BGRA8888: boolean;
var
  GLAD_GL_EXT_texture_format_sRGB_override: boolean;
const
  GL_TEXTURE_FORMAT_SRGB_OVERRIDE_EXT = $8FBF;
var
  GLAD_GL_EXT_texture_mirror_clamp_to_edge: boolean;
const
  GL_MIRROR_CLAMP_TO_EDGE_EXT = $8743;
var
  GLAD_GL_EXT_texture_norm16: boolean;
const
  GL_R16_EXT = $822A;
  GL_RG16_EXT = $822C;
  GL_RGBA16_EXT = $805B;
  GL_RGB16_EXT = $8054;
  GL_RGB16_SNORM_EXT = $8F9A;
var
  GLAD_GL_EXT_texture_query_lod: boolean;
var
  GLAD_GL_EXT_texture_rg: boolean;
const
  GL_RED_EXT = $1903;
  GL_RG_EXT = $8227;
  GL_R8_EXT = $8229;
  GL_RG8_EXT = $822B;
var
  GLAD_GL_EXT_texture_sRGB_R8: boolean;
const
  GL_SR8_EXT = $8FBD;
var
  GLAD_GL_EXT_texture_sRGB_RG8: boolean;
const
  GL_SRG8_EXT = $8FBE;
var
  GLAD_GL_EXT_texture_sRGB_decode: boolean;
const
  GL_TEXTURE_SRGB_DECODE_EXT = $8A48;
  GL_DECODE_EXT = $8A49;
  GL_SKIP_DECODE_EXT = $8A4A;
var
  GLAD_GL_EXT_texture_shadow_lod: boolean;
var
  GLAD_GL_EXT_texture_storage: boolean;
const
  GL_TEXTURE_IMMUTABLE_FORMAT_EXT = $912F;
  GL_ALPHA8_EXT = $803C;
  GL_LUMINANCE8_EXT = $8040;
  GL_LUMINANCE8_ALPHA8_EXT = $8045;
  GL_RGBA32F_EXT = $8814;
  GL_RGB32F_EXT = $8815;
  GL_ALPHA32F_EXT = $8816;
  GL_LUMINANCE32F_EXT = $8818;
  GL_LUMINANCE_ALPHA32F_EXT = $8819;
  GL_ALPHA16F_EXT = $881C;
  GL_LUMINANCE16F_EXT = $881E;
  GL_LUMINANCE_ALPHA16F_EXT = $881F;
  GL_RGB10_A2_EXT = $8059;
  GL_RGB10_EXT = $8052;
  GL_R32F_EXT = $822E;
  GL_RG32F_EXT = $8230;
var
  GLAD_GL_EXT_texture_storage_compression: boolean;
const
  GL_NUM_SURFACE_COMPRESSION_FIXED_RATES_EXT = $8F6E;
  GL_SURFACE_COMPRESSION_FIXED_RATE_1BPC_EXT = $96C4;
  GL_SURFACE_COMPRESSION_FIXED_RATE_2BPC_EXT = $96C5;
  GL_SURFACE_COMPRESSION_FIXED_RATE_3BPC_EXT = $96C6;
  GL_SURFACE_COMPRESSION_FIXED_RATE_4BPC_EXT = $96C7;
  GL_SURFACE_COMPRESSION_FIXED_RATE_5BPC_EXT = $96C8;
  GL_SURFACE_COMPRESSION_FIXED_RATE_6BPC_EXT = $96C9;
  GL_SURFACE_COMPRESSION_FIXED_RATE_7BPC_EXT = $96CA;
  GL_SURFACE_COMPRESSION_FIXED_RATE_8BPC_EXT = $96CB;
  GL_SURFACE_COMPRESSION_FIXED_RATE_9BPC_EXT = $96CC;
  GL_SURFACE_COMPRESSION_FIXED_RATE_10BPC_EXT = $96CD;
  GL_SURFACE_COMPRESSION_FIXED_RATE_11BPC_EXT = $96CE;
  GL_SURFACE_COMPRESSION_FIXED_RATE_12BPC_EXT = $96CF;
var
  GLAD_GL_EXT_texture_type_2_10_10_10_REV: boolean;
const
  GL_UNSIGNED_INT_2_10_10_10_REV_EXT = $8368;
var
  GLAD_GL_EXT_texture_view: boolean;
const
  GL_TEXTURE_VIEW_MIN_LEVEL_EXT = $82DB;
  GL_TEXTURE_VIEW_NUM_LEVELS_EXT = $82DC;
  GL_TEXTURE_VIEW_MIN_LAYER_EXT = $82DD;
  GL_TEXTURE_VIEW_NUM_LAYERS_EXT = $82DE;
var
  GLAD_GL_EXT_unpack_subimage: boolean;
const
  GL_UNPACK_ROW_LENGTH_EXT = $0CF2;
  GL_UNPACK_SKIP_ROWS_EXT = $0CF3;
  GL_UNPACK_SKIP_PIXELS_EXT = $0CF4;
var
  GLAD_GL_EXT_win32_keyed_mutex: boolean;
var
  GLAD_GL_EXT_window_rectangles: boolean;
const
  GL_INCLUSIVE_EXT = $8F10;
  GL_EXCLUSIVE_EXT = $8F11;
  GL_WINDOW_RECTANGLE_EXT = $8F12;
  GL_WINDOW_RECTANGLE_MODE_EXT = $8F13;
  GL_MAX_WINDOW_RECTANGLES_EXT = $8F14;
  GL_NUM_WINDOW_RECTANGLES_EXT = $8F15;
var
  GLAD_GL_FJ_shader_binary_GCCSO: boolean;
const
  GL_GCCSO_SHADER_BINARY_FJ = $9260;
var
  GLAD_GL_IMG_bindless_texture: boolean;
var
  GLAD_GL_IMG_framebuffer_downsample: boolean;
const
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_AND_DOWNSAMPLE_IMG = $913C;
  GL_NUM_DOWNSAMPLE_SCALES_IMG = $913D;
  GL_DOWNSAMPLE_SCALES_IMG = $913E;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_SCALE_IMG = $913F;
var
  GLAD_GL_IMG_multisampled_render_to_texture: boolean;
const
  GL_RENDERBUFFER_SAMPLES_IMG = $9133;
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_IMG = $9134;
  GL_MAX_SAMPLES_IMG = $9135;
  GL_TEXTURE_SAMPLES_IMG = $9136;
var
  GLAD_GL_IMG_program_binary: boolean;
const
  GL_SGX_PROGRAM_BINARY_IMG = $9130;
var
  GLAD_GL_IMG_read_format: boolean;
const
  GL_BGRA_IMG = $80E1;
  GL_UNSIGNED_SHORT_4_4_4_4_REV_IMG = $8365;
var
  GLAD_GL_IMG_shader_binary: boolean;
const
  GL_SGX_BINARY_IMG = $8C0A;
var
  GLAD_GL_IMG_texture_compression_pvrtc: boolean;
const
  GL_COMPRESSED_RGB_PVRTC_4BPPV1_IMG = $8C00;
  GL_COMPRESSED_RGB_PVRTC_2BPPV1_IMG = $8C01;
  GL_COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = $8C02;
  GL_COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = $8C03;
var
  GLAD_GL_IMG_texture_compression_pvrtc2: boolean;
const
  GL_COMPRESSED_RGBA_PVRTC_2BPPV2_IMG = $9137;
  GL_COMPRESSED_RGBA_PVRTC_4BPPV2_IMG = $9138;
var
  GLAD_GL_IMG_texture_filter_cubic: boolean;
const
  GL_CUBIC_IMG = $9139;
  GL_CUBIC_MIPMAP_NEAREST_IMG = $913A;
  GL_CUBIC_MIPMAP_LINEAR_IMG = $913B;
var
  GLAD_GL_INTEL_blackhole_render: boolean;
const
  GL_BLACKHOLE_RENDER_INTEL = $83FC;
var
  GLAD_GL_INTEL_conservative_rasterization: boolean;
const
  GL_CONSERVATIVE_RASTERIZATION_INTEL = $83FE;
var
  GLAD_GL_INTEL_framebuffer_CMAA: boolean;
var
  GLAD_GL_INTEL_performance_query: boolean;
const
  GL_PERFQUERY_SINGLE_CONTEXT_INTEL = $00000000;
  GL_PERFQUERY_GLOBAL_CONTEXT_INTEL = $00000001;
  GL_PERFQUERY_WAIT_INTEL = $83FB;
  GL_PERFQUERY_FLUSH_INTEL = $83FA;
  GL_PERFQUERY_DONOT_FLUSH_INTEL = $83F9;
  GL_PERFQUERY_COUNTER_EVENT_INTEL = $94F0;
  GL_PERFQUERY_COUNTER_DURATION_NORM_INTEL = $94F1;
  GL_PERFQUERY_COUNTER_DURATION_RAW_INTEL = $94F2;
  GL_PERFQUERY_COUNTER_THROUGHPUT_INTEL = $94F3;
  GL_PERFQUERY_COUNTER_RAW_INTEL = $94F4;
  GL_PERFQUERY_COUNTER_TIMESTAMP_INTEL = $94F5;
  GL_PERFQUERY_COUNTER_DATA_UINT32_INTEL = $94F8;
  GL_PERFQUERY_COUNTER_DATA_UINT64_INTEL = $94F9;
  GL_PERFQUERY_COUNTER_DATA_FLOAT_INTEL = $94FA;
  GL_PERFQUERY_COUNTER_DATA_DOUBLE_INTEL = $94FB;
  GL_PERFQUERY_COUNTER_DATA_BOOL32_INTEL = $94FC;
  GL_PERFQUERY_QUERY_NAME_LENGTH_MAX_INTEL = $94FD;
  GL_PERFQUERY_COUNTER_NAME_LENGTH_MAX_INTEL = $94FE;
  GL_PERFQUERY_COUNTER_DESC_LENGTH_MAX_INTEL = $94FF;
  GL_PERFQUERY_GPA_EXTENDED_COUNTERS_INTEL = $9500;
var
  GLAD_GL_KHR_blend_equation_advanced: boolean;
const
  GL_MULTIPLY_KHR = $9294;
  GL_SCREEN_KHR = $9295;
  GL_OVERLAY_KHR = $9296;
  GL_DARKEN_KHR = $9297;
  GL_LIGHTEN_KHR = $9298;
  GL_COLORDODGE_KHR = $9299;
  GL_COLORBURN_KHR = $929A;
  GL_HARDLIGHT_KHR = $929B;
  GL_SOFTLIGHT_KHR = $929C;
  GL_DIFFERENCE_KHR = $929E;
  GL_EXCLUSION_KHR = $92A0;
  GL_HSL_HUE_KHR = $92AD;
  GL_HSL_SATURATION_KHR = $92AE;
  GL_HSL_COLOR_KHR = $92AF;
  GL_HSL_LUMINOSITY_KHR = $92B0;
var
  GLAD_GL_KHR_blend_equation_advanced_coherent: boolean;
const
  GL_BLEND_ADVANCED_COHERENT_KHR = $9285;
var
  GLAD_GL_KHR_context_flush_control: boolean;
const
  GL_CONTEXT_RELEASE_BEHAVIOR = $82FB;
  GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = $82FC;
  GL_CONTEXT_RELEASE_BEHAVIOR_KHR = $82FB;
  GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH_KHR = $82FC;
var
  GLAD_GL_KHR_debug: boolean;
const
  GL_DEBUG_OUTPUT_SYNCHRONOUS = $8242;
  GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH = $8243;
  GL_DEBUG_CALLBACK_FUNCTION = $8244;
  GL_DEBUG_CALLBACK_USER_PARAM = $8245;
  GL_DEBUG_SOURCE_API = $8246;
  GL_DEBUG_SOURCE_WINDOW_SYSTEM = $8247;
  GL_DEBUG_SOURCE_SHADER_COMPILER = $8248;
  GL_DEBUG_SOURCE_THIRD_PARTY = $8249;
  GL_DEBUG_SOURCE_APPLICATION = $824A;
  GL_DEBUG_SOURCE_OTHER = $824B;
  GL_DEBUG_TYPE_ERROR = $824C;
  GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR = $824D;
  GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR = $824E;
  GL_DEBUG_TYPE_PORTABILITY = $824F;
  GL_DEBUG_TYPE_PERFORMANCE = $8250;
  GL_DEBUG_TYPE_OTHER = $8251;
  GL_DEBUG_TYPE_MARKER = $8268;
  GL_DEBUG_TYPE_PUSH_GROUP = $8269;
  GL_DEBUG_TYPE_POP_GROUP = $826A;
  GL_DEBUG_SEVERITY_NOTIFICATION = $826B;
  GL_MAX_DEBUG_GROUP_STACK_DEPTH = $826C;
  GL_DEBUG_GROUP_STACK_DEPTH = $826D;
  GL_BUFFER = $82E0;
  GL_SHADER = $82E1;
  GL_PROGRAM = $82E2;
  GL_VERTEX_ARRAY = $8074;
  GL_QUERY = $82E3;
  GL_PROGRAM_PIPELINE = $82E4;
  GL_MAX_LABEL_LENGTH = $82E8;
  GL_MAX_DEBUG_MESSAGE_LENGTH = $9143;
  GL_MAX_DEBUG_LOGGED_MESSAGES = $9144;
  GL_DEBUG_LOGGED_MESSAGES = $9145;
  GL_DEBUG_SEVERITY_HIGH = $9146;
  GL_DEBUG_SEVERITY_MEDIUM = $9147;
  GL_DEBUG_SEVERITY_LOW = $9148;
  GL_DEBUG_OUTPUT = $92E0;
  GL_CONTEXT_FLAG_DEBUG_BIT = $00000002;
  GL_STACK_OVERFLOW = $0503;
  GL_STACK_UNDERFLOW = $0504;
  GL_DEBUG_OUTPUT_SYNCHRONOUS_KHR = $8242;
  GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_KHR = $8243;
  GL_DEBUG_CALLBACK_FUNCTION_KHR = $8244;
  GL_DEBUG_CALLBACK_USER_PARAM_KHR = $8245;
  GL_DEBUG_SOURCE_API_KHR = $8246;
  GL_DEBUG_SOURCE_WINDOW_SYSTEM_KHR = $8247;
  GL_DEBUG_SOURCE_SHADER_COMPILER_KHR = $8248;
  GL_DEBUG_SOURCE_THIRD_PARTY_KHR = $8249;
  GL_DEBUG_SOURCE_APPLICATION_KHR = $824A;
  GL_DEBUG_SOURCE_OTHER_KHR = $824B;
  GL_DEBUG_TYPE_ERROR_KHR = $824C;
  GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_KHR = $824D;
  GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_KHR = $824E;
  GL_DEBUG_TYPE_PORTABILITY_KHR = $824F;
  GL_DEBUG_TYPE_PERFORMANCE_KHR = $8250;
  GL_DEBUG_TYPE_OTHER_KHR = $8251;
  GL_DEBUG_TYPE_MARKER_KHR = $8268;
  GL_DEBUG_TYPE_PUSH_GROUP_KHR = $8269;
  GL_DEBUG_TYPE_POP_GROUP_KHR = $826A;
  GL_DEBUG_SEVERITY_NOTIFICATION_KHR = $826B;
  GL_MAX_DEBUG_GROUP_STACK_DEPTH_KHR = $826C;
  GL_DEBUG_GROUP_STACK_DEPTH_KHR = $826D;
  GL_BUFFER_KHR = $82E0;
  GL_SHADER_KHR = $82E1;
  GL_PROGRAM_KHR = $82E2;
  GL_VERTEX_ARRAY_KHR = $8074;
  GL_QUERY_KHR = $82E3;
  GL_PROGRAM_PIPELINE_KHR = $82E4;
  GL_SAMPLER_KHR = $82E6;
  GL_MAX_LABEL_LENGTH_KHR = $82E8;
  GL_MAX_DEBUG_MESSAGE_LENGTH_KHR = $9143;
  GL_MAX_DEBUG_LOGGED_MESSAGES_KHR = $9144;
  GL_DEBUG_LOGGED_MESSAGES_KHR = $9145;
  GL_DEBUG_SEVERITY_HIGH_KHR = $9146;
  GL_DEBUG_SEVERITY_MEDIUM_KHR = $9147;
  GL_DEBUG_SEVERITY_LOW_KHR = $9148;
  GL_DEBUG_OUTPUT_KHR = $92E0;
  GL_CONTEXT_FLAG_DEBUG_BIT_KHR = $00000002;
  GL_STACK_OVERFLOW_KHR = $0503;
  GL_STACK_UNDERFLOW_KHR = $0504;
  GL_DISPLAY_LIST = $82E7;
var
  GLAD_GL_KHR_no_error: boolean;
const
  GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR = $00000008;
var
  GLAD_GL_KHR_parallel_shader_compile: boolean;
const
  GL_MAX_SHADER_COMPILER_THREADS_KHR = $91B0;
  GL_COMPLETION_STATUS_KHR = $91B1;
var
  GLAD_GL_KHR_robust_buffer_access_behavior: boolean;
var
  GLAD_GL_KHR_robustness: boolean;
const
  GL_CONTEXT_ROBUST_ACCESS = $90F3;
  GL_LOSE_CONTEXT_ON_RESET = $8252;
  GL_GUILTY_CONTEXT_RESET = $8253;
  GL_INNOCENT_CONTEXT_RESET = $8254;
  GL_UNKNOWN_CONTEXT_RESET = $8255;
  GL_RESET_NOTIFICATION_STRATEGY = $8256;
  GL_NO_RESET_NOTIFICATION = $8261;
  GL_CONTEXT_LOST = $0507;
  GL_CONTEXT_ROBUST_ACCESS_KHR = $90F3;
  GL_LOSE_CONTEXT_ON_RESET_KHR = $8252;
  GL_GUILTY_CONTEXT_RESET_KHR = $8253;
  GL_INNOCENT_CONTEXT_RESET_KHR = $8254;
  GL_UNKNOWN_CONTEXT_RESET_KHR = $8255;
  GL_RESET_NOTIFICATION_STRATEGY_KHR = $8256;
  GL_NO_RESET_NOTIFICATION_KHR = $8261;
  GL_CONTEXT_LOST_KHR = $0507;
var
  GLAD_GL_KHR_shader_subgroup: boolean;
const
  GL_SUBGROUP_SIZE_KHR = $9532;
  GL_SUBGROUP_SUPPORTED_STAGES_KHR = $9533;
  GL_SUBGROUP_SUPPORTED_FEATURES_KHR = $9534;
  GL_SUBGROUP_QUAD_ALL_STAGES_KHR = $9535;
  GL_SUBGROUP_FEATURE_BASIC_BIT_KHR = $00000001;
  GL_SUBGROUP_FEATURE_VOTE_BIT_KHR = $00000002;
  GL_SUBGROUP_FEATURE_ARITHMETIC_BIT_KHR = $00000004;
  GL_SUBGROUP_FEATURE_BALLOT_BIT_KHR = $00000008;
  GL_SUBGROUP_FEATURE_SHUFFLE_BIT_KHR = $00000010;
  GL_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT_KHR = $00000020;
  GL_SUBGROUP_FEATURE_CLUSTERED_BIT_KHR = $00000040;
  GL_SUBGROUP_FEATURE_QUAD_BIT_KHR = $00000080;
var
  GLAD_GL_KHR_texture_compression_astc_hdr: boolean;
const
  GL_COMPRESSED_RGBA_ASTC_4x4_KHR = $93B0;
  GL_COMPRESSED_RGBA_ASTC_5x4_KHR = $93B1;
  GL_COMPRESSED_RGBA_ASTC_5x5_KHR = $93B2;
  GL_COMPRESSED_RGBA_ASTC_6x5_KHR = $93B3;
  GL_COMPRESSED_RGBA_ASTC_6x6_KHR = $93B4;
  GL_COMPRESSED_RGBA_ASTC_8x5_KHR = $93B5;
  GL_COMPRESSED_RGBA_ASTC_8x6_KHR = $93B6;
  GL_COMPRESSED_RGBA_ASTC_8x8_KHR = $93B7;
  GL_COMPRESSED_RGBA_ASTC_10x5_KHR = $93B8;
  GL_COMPRESSED_RGBA_ASTC_10x6_KHR = $93B9;
  GL_COMPRESSED_RGBA_ASTC_10x8_KHR = $93BA;
  GL_COMPRESSED_RGBA_ASTC_10x10_KHR = $93BB;
  GL_COMPRESSED_RGBA_ASTC_12x10_KHR = $93BC;
  GL_COMPRESSED_RGBA_ASTC_12x12_KHR = $93BD;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = $93D0;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = $93D1;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = $93D2;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = $93D3;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = $93D4;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = $93D5;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = $93D6;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = $93D7;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = $93D8;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = $93D9;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = $93DA;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = $93DB;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = $93DC;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = $93DD;
var
  GLAD_GL_KHR_texture_compression_astc_ldr: boolean;
var
  GLAD_GL_KHR_texture_compression_astc_sliced_3d: boolean;
var
  GLAD_GL_MESA_bgra: boolean;
const
  GL_BGR_EXT = $80E0;
var
  GLAD_GL_MESA_framebuffer_flip_x: boolean;
const
  GL_FRAMEBUFFER_FLIP_X_MESA = $8BBC;
var
  GLAD_GL_MESA_framebuffer_flip_y: boolean;
const
  GL_FRAMEBUFFER_FLIP_Y_MESA = $8BBB;
var
  GLAD_GL_MESA_framebuffer_swap_xy: boolean;
const
  GL_FRAMEBUFFER_SWAP_XY_MESA = $8BBD;
var
  GLAD_GL_MESA_program_binary_formats: boolean;
const
  GL_PROGRAM_BINARY_FORMAT_MESA = $875F;
var
  GLAD_GL_MESA_sampler_objects: boolean;
var
  GLAD_GL_MESA_shader_integer_functions: boolean;
var
  GLAD_GL_NVX_blend_equation_advanced_multi_draw_buffers: boolean;
var
  GLAD_GL_NV_bindless_texture: boolean;
var
  GLAD_GL_NV_blend_equation_advanced: boolean;
const
  GL_BLEND_OVERLAP_NV = $9281;
  GL_BLEND_PREMULTIPLIED_SRC_NV = $9280;
  GL_BLUE_NV = $1905;
  GL_COLORBURN_NV = $929A;
  GL_COLORDODGE_NV = $9299;
  GL_CONJOINT_NV = $9284;
  GL_CONTRAST_NV = $92A1;
  GL_DARKEN_NV = $9297;
  GL_DIFFERENCE_NV = $929E;
  GL_DISJOINT_NV = $9283;
  GL_DST_ATOP_NV = $928F;
  GL_DST_IN_NV = $928B;
  GL_DST_NV = $9287;
  GL_DST_OUT_NV = $928D;
  GL_DST_OVER_NV = $9289;
  GL_EXCLUSION_NV = $92A0;
  GL_GREEN_NV = $1904;
  GL_HARDLIGHT_NV = $929B;
  GL_HARDMIX_NV = $92A9;
  GL_HSL_COLOR_NV = $92AF;
  GL_HSL_HUE_NV = $92AD;
  GL_HSL_LUMINOSITY_NV = $92B0;
  GL_HSL_SATURATION_NV = $92AE;
  GL_INVERT_OVG_NV = $92B4;
  GL_INVERT_RGB_NV = $92A3;
  GL_LIGHTEN_NV = $9298;
  GL_LINEARBURN_NV = $92A5;
  GL_LINEARDODGE_NV = $92A4;
  GL_LINEARLIGHT_NV = $92A7;
  GL_MINUS_CLAMPED_NV = $92B3;
  GL_MINUS_NV = $929F;
  GL_MULTIPLY_NV = $9294;
  GL_OVERLAY_NV = $9296;
  GL_PINLIGHT_NV = $92A8;
  GL_PLUS_CLAMPED_ALPHA_NV = $92B2;
  GL_PLUS_CLAMPED_NV = $92B1;
  GL_PLUS_DARKER_NV = $9292;
  GL_PLUS_NV = $9291;
  GL_RED_NV = $1903;
  GL_SCREEN_NV = $9295;
  GL_SOFTLIGHT_NV = $929C;
  GL_SRC_ATOP_NV = $928E;
  GL_SRC_IN_NV = $928A;
  GL_SRC_NV = $9286;
  GL_SRC_OUT_NV = $928C;
  GL_SRC_OVER_NV = $9288;
  GL_UNCORRELATED_NV = $9282;
  GL_VIVIDLIGHT_NV = $92A6;
  GL_XOR_NV = $1506;
var
  GLAD_GL_NV_blend_equation_advanced_coherent: boolean;
const
  GL_BLEND_ADVANCED_COHERENT_NV = $9285;
var
  GLAD_GL_NV_blend_minmax_factor: boolean;
const
  GL_FACTOR_MIN_AMD = $901C;
  GL_FACTOR_MAX_AMD = $901D;
var
  GLAD_GL_NV_clip_space_w_scaling: boolean;
const
  GL_VIEWPORT_POSITION_W_SCALE_NV = $937C;
  GL_VIEWPORT_POSITION_W_SCALE_X_COEFF_NV = $937D;
  GL_VIEWPORT_POSITION_W_SCALE_Y_COEFF_NV = $937E;
var
  GLAD_GL_NV_compute_shader_derivatives: boolean;
var
  GLAD_GL_NV_conditional_render: boolean;
const
  GL_QUERY_WAIT_NV = $8E13;
  GL_QUERY_NO_WAIT_NV = $8E14;
  GL_QUERY_BY_REGION_WAIT_NV = $8E15;
  GL_QUERY_BY_REGION_NO_WAIT_NV = $8E16;
var
  GLAD_GL_NV_conservative_raster: boolean;
const
  GL_CONSERVATIVE_RASTERIZATION_NV = $9346;
  GL_SUBPIXEL_PRECISION_BIAS_X_BITS_NV = $9347;
  GL_SUBPIXEL_PRECISION_BIAS_Y_BITS_NV = $9348;
  GL_MAX_SUBPIXEL_PRECISION_BIAS_BITS_NV = $9349;
var
  GLAD_GL_NV_conservative_raster_pre_snap: boolean;
const
  GL_CONSERVATIVE_RASTER_MODE_PRE_SNAP_NV = $9550;
var
  GLAD_GL_NV_conservative_raster_pre_snap_triangles: boolean;
const
  GL_CONSERVATIVE_RASTER_MODE_NV = $954D;
  GL_CONSERVATIVE_RASTER_MODE_POST_SNAP_NV = $954E;
  GL_CONSERVATIVE_RASTER_MODE_PRE_SNAP_TRIANGLES_NV = $954F;
var
  GLAD_GL_NV_copy_buffer: boolean;
const
  GL_COPY_READ_BUFFER_NV = $8F36;
  GL_COPY_WRITE_BUFFER_NV = $8F37;
var
  GLAD_GL_NV_coverage_sample: boolean;
const
  GL_COVERAGE_COMPONENT_NV = $8ED0;
  GL_COVERAGE_COMPONENT4_NV = $8ED1;
  GL_COVERAGE_ATTACHMENT_NV = $8ED2;
  GL_COVERAGE_BUFFERS_NV = $8ED3;
  GL_COVERAGE_SAMPLES_NV = $8ED4;
  GL_COVERAGE_ALL_FRAGMENTS_NV = $8ED5;
  GL_COVERAGE_EDGE_FRAGMENTS_NV = $8ED6;
  GL_COVERAGE_AUTOMATIC_NV = $8ED7;
  GL_COVERAGE_BUFFER_BIT_NV = $00008000;
var
  GLAD_GL_NV_depth_nonlinear: boolean;
const
  GL_DEPTH_COMPONENT16_NONLINEAR_NV = $8E2C;
var
  GLAD_GL_NV_draw_buffers: boolean;
const
  GL_MAX_DRAW_BUFFERS_NV = $8824;
  GL_DRAW_BUFFER0_NV = $8825;
  GL_DRAW_BUFFER1_NV = $8826;
  GL_DRAW_BUFFER2_NV = $8827;
  GL_DRAW_BUFFER3_NV = $8828;
  GL_DRAW_BUFFER4_NV = $8829;
  GL_DRAW_BUFFER5_NV = $882A;
  GL_DRAW_BUFFER6_NV = $882B;
  GL_DRAW_BUFFER7_NV = $882C;
  GL_DRAW_BUFFER8_NV = $882D;
  GL_DRAW_BUFFER9_NV = $882E;
  GL_DRAW_BUFFER10_NV = $882F;
  GL_DRAW_BUFFER11_NV = $8830;
  GL_DRAW_BUFFER12_NV = $8831;
  GL_DRAW_BUFFER13_NV = $8832;
  GL_DRAW_BUFFER14_NV = $8833;
  GL_DRAW_BUFFER15_NV = $8834;
  GL_COLOR_ATTACHMENT0_NV = $8CE0;
  GL_COLOR_ATTACHMENT1_NV = $8CE1;
  GL_COLOR_ATTACHMENT2_NV = $8CE2;
  GL_COLOR_ATTACHMENT3_NV = $8CE3;
  GL_COLOR_ATTACHMENT4_NV = $8CE4;
  GL_COLOR_ATTACHMENT5_NV = $8CE5;
  GL_COLOR_ATTACHMENT6_NV = $8CE6;
  GL_COLOR_ATTACHMENT7_NV = $8CE7;
  GL_COLOR_ATTACHMENT8_NV = $8CE8;
  GL_COLOR_ATTACHMENT9_NV = $8CE9;
  GL_COLOR_ATTACHMENT10_NV = $8CEA;
  GL_COLOR_ATTACHMENT11_NV = $8CEB;
  GL_COLOR_ATTACHMENT12_NV = $8CEC;
  GL_COLOR_ATTACHMENT13_NV = $8CED;
  GL_COLOR_ATTACHMENT14_NV = $8CEE;
  GL_COLOR_ATTACHMENT15_NV = $8CEF;
var
  GLAD_GL_NV_draw_instanced: boolean;
var
  GLAD_GL_NV_draw_vulkan_image: boolean;
var
  GLAD_GL_NV_explicit_attrib_location: boolean;
var
  GLAD_GL_NV_fbo_color_attachments: boolean;
const
  GL_MAX_COLOR_ATTACHMENTS_NV = $8CDF;
var
  GLAD_GL_NV_fence: boolean;
const
  GL_ALL_COMPLETED_NV = $84F2;
  GL_FENCE_STATUS_NV = $84F3;
  GL_FENCE_CONDITION_NV = $84F4;
var
  GLAD_GL_NV_fill_rectangle: boolean;
const
  GL_FILL_RECTANGLE_NV = $933C;
var
  GLAD_GL_NV_fragment_coverage_to_color: boolean;
const
  GL_FRAGMENT_COVERAGE_TO_COLOR_NV = $92DD;
  GL_FRAGMENT_COVERAGE_COLOR_NV = $92DE;
var
  GLAD_GL_NV_fragment_shader_barycentric: boolean;
var
  GLAD_GL_NV_fragment_shader_interlock: boolean;
var
  GLAD_GL_NV_framebuffer_blit: boolean;
const
  GL_READ_FRAMEBUFFER_NV = $8CA8;
  GL_DRAW_FRAMEBUFFER_NV = $8CA9;
  GL_DRAW_FRAMEBUFFER_BINDING_NV = $8CA6;
  GL_READ_FRAMEBUFFER_BINDING_NV = $8CAA;
var
  GLAD_GL_NV_framebuffer_mixed_samples: boolean;
const
  GL_COVERAGE_MODULATION_TABLE_NV = $9331;
  GL_COLOR_SAMPLES_NV = $8E20;
  GL_DEPTH_SAMPLES_NV = $932D;
  GL_STENCIL_SAMPLES_NV = $932E;
  GL_MIXED_DEPTH_SAMPLES_SUPPORTED_NV = $932F;
  GL_MIXED_STENCIL_SAMPLES_SUPPORTED_NV = $9330;
  GL_COVERAGE_MODULATION_NV = $9332;
  GL_COVERAGE_MODULATION_TABLE_SIZE_NV = $9333;
var
  GLAD_GL_NV_framebuffer_multisample: boolean;
const
  GL_RENDERBUFFER_SAMPLES_NV = $8CAB;
  GL_FRAMEBUFFER_INCOMPLETE_MULTISAMPLE_NV = $8D56;
  GL_MAX_SAMPLES_NV = $8D57;
var
  GLAD_GL_NV_generate_mipmap_sRGB: boolean;
var
  GLAD_GL_NV_geometry_shader_passthrough: boolean;
var
  GLAD_GL_NV_gpu_shader5: boolean;
const
  GL_INT64_NV = $140E;
  GL_UNSIGNED_INT64_NV = $140F;
  GL_INT8_NV = $8FE0;
  GL_INT8_VEC2_NV = $8FE1;
  GL_INT8_VEC3_NV = $8FE2;
  GL_INT8_VEC4_NV = $8FE3;
  GL_INT16_NV = $8FE4;
  GL_INT16_VEC2_NV = $8FE5;
  GL_INT16_VEC3_NV = $8FE6;
  GL_INT16_VEC4_NV = $8FE7;
  GL_INT64_VEC2_NV = $8FE9;
  GL_INT64_VEC3_NV = $8FEA;
  GL_INT64_VEC4_NV = $8FEB;
  GL_UNSIGNED_INT8_NV = $8FEC;
  GL_UNSIGNED_INT8_VEC2_NV = $8FED;
  GL_UNSIGNED_INT8_VEC3_NV = $8FEE;
  GL_UNSIGNED_INT8_VEC4_NV = $8FEF;
  GL_UNSIGNED_INT16_NV = $8FF0;
  GL_UNSIGNED_INT16_VEC2_NV = $8FF1;
  GL_UNSIGNED_INT16_VEC3_NV = $8FF2;
  GL_UNSIGNED_INT16_VEC4_NV = $8FF3;
  GL_UNSIGNED_INT64_VEC2_NV = $8FF5;
  GL_UNSIGNED_INT64_VEC3_NV = $8FF6;
  GL_UNSIGNED_INT64_VEC4_NV = $8FF7;
  GL_FLOAT16_NV = $8FF8;
  GL_FLOAT16_VEC2_NV = $8FF9;
  GL_FLOAT16_VEC3_NV = $8FFA;
  GL_FLOAT16_VEC4_NV = $8FFB;
  GL_PATCHES = $000E;
var
  GLAD_GL_NV_image_formats: boolean;
var
  GLAD_GL_NV_instanced_arrays: boolean;
const
  GL_VERTEX_ATTRIB_ARRAY_DIVISOR_NV = $88FE;
var
  GLAD_GL_NV_internalformat_sample_query: boolean;
const
  GL_TEXTURE_2D_MULTISAMPLE = $9100;
  GL_TEXTURE_2D_MULTISAMPLE_ARRAY = $9102;
  GL_MULTISAMPLES_NV = $9371;
  GL_SUPERSAMPLE_SCALE_X_NV = $9372;
  GL_SUPERSAMPLE_SCALE_Y_NV = $9373;
  GL_CONFORMANT_NV = $9374;
var
  GLAD_GL_NV_memory_attachment: boolean;
const
  GL_ATTACHED_MEMORY_OBJECT_NV = $95A4;
  GL_ATTACHED_MEMORY_OFFSET_NV = $95A5;
  GL_MEMORY_ATTACHABLE_ALIGNMENT_NV = $95A6;
  GL_MEMORY_ATTACHABLE_SIZE_NV = $95A7;
  GL_MEMORY_ATTACHABLE_NV = $95A8;
  GL_DETACHED_MEMORY_INCARNATION_NV = $95A9;
  GL_DETACHED_TEXTURES_NV = $95AA;
  GL_DETACHED_BUFFERS_NV = $95AB;
  GL_MAX_DETACHED_TEXTURES_NV = $95AC;
  GL_MAX_DETACHED_BUFFERS_NV = $95AD;
var
  GLAD_GL_NV_memory_object_sparse: boolean;
var
  GLAD_GL_NV_mesh_shader: boolean;
const
  GL_MESH_SHADER_NV = $9559;
  GL_TASK_SHADER_NV = $955A;
  GL_MAX_MESH_UNIFORM_BLOCKS_NV = $8E60;
  GL_MAX_MESH_TEXTURE_IMAGE_UNITS_NV = $8E61;
  GL_MAX_MESH_IMAGE_UNIFORMS_NV = $8E62;
  GL_MAX_MESH_UNIFORM_COMPONENTS_NV = $8E63;
  GL_MAX_MESH_ATOMIC_COUNTER_BUFFERS_NV = $8E64;
  GL_MAX_MESH_ATOMIC_COUNTERS_NV = $8E65;
  GL_MAX_MESH_SHADER_STORAGE_BLOCKS_NV = $8E66;
  GL_MAX_COMBINED_MESH_UNIFORM_COMPONENTS_NV = $8E67;
  GL_MAX_TASK_UNIFORM_BLOCKS_NV = $8E68;
  GL_MAX_TASK_TEXTURE_IMAGE_UNITS_NV = $8E69;
  GL_MAX_TASK_IMAGE_UNIFORMS_NV = $8E6A;
  GL_MAX_TASK_UNIFORM_COMPONENTS_NV = $8E6B;
  GL_MAX_TASK_ATOMIC_COUNTER_BUFFERS_NV = $8E6C;
  GL_MAX_TASK_ATOMIC_COUNTERS_NV = $8E6D;
  GL_MAX_TASK_SHADER_STORAGE_BLOCKS_NV = $8E6E;
  GL_MAX_COMBINED_TASK_UNIFORM_COMPONENTS_NV = $8E6F;
  GL_MAX_MESH_WORK_GROUP_INVOCATIONS_NV = $95A2;
  GL_MAX_TASK_WORK_GROUP_INVOCATIONS_NV = $95A3;
  GL_MAX_MESH_TOTAL_MEMORY_SIZE_NV = $9536;
  GL_MAX_TASK_TOTAL_MEMORY_SIZE_NV = $9537;
  GL_MAX_MESH_OUTPUT_VERTICES_NV = $9538;
  GL_MAX_MESH_OUTPUT_PRIMITIVES_NV = $9539;
  GL_MAX_TASK_OUTPUT_COUNT_NV = $953A;
  GL_MAX_DRAW_MESH_TASKS_COUNT_NV = $953D;
  GL_MAX_MESH_VIEWS_NV = $9557;
  GL_MESH_OUTPUT_PER_VERTEX_GRANULARITY_NV = $92DF;
  GL_MESH_OUTPUT_PER_PRIMITIVE_GRANULARITY_NV = $9543;
  GL_MAX_MESH_WORK_GROUP_SIZE_NV = $953B;
  GL_MAX_TASK_WORK_GROUP_SIZE_NV = $953C;
  GL_MESH_WORK_GROUP_SIZE_NV = $953E;
  GL_TASK_WORK_GROUP_SIZE_NV = $953F;
  GL_MESH_VERTICES_OUT_NV = $9579;
  GL_MESH_PRIMITIVES_OUT_NV = $957A;
  GL_MESH_OUTPUT_TYPE_NV = $957B;
  GL_UNIFORM_BLOCK_REFERENCED_BY_MESH_SHADER_NV = $959C;
  GL_UNIFORM_BLOCK_REFERENCED_BY_TASK_SHADER_NV = $959D;
  GL_REFERENCED_BY_MESH_SHADER_NV = $95A0;
  GL_REFERENCED_BY_TASK_SHADER_NV = $95A1;
  GL_MESH_SHADER_BIT_NV = $00000040;
  GL_TASK_SHADER_BIT_NV = $00000080;
  GL_MESH_SUBROUTINE_NV = $957C;
  GL_TASK_SUBROUTINE_NV = $957D;
  GL_MESH_SUBROUTINE_UNIFORM_NV = $957E;
  GL_TASK_SUBROUTINE_UNIFORM_NV = $957F;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_MESH_SHADER_NV = $959E;
  GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TASK_SHADER_NV = $959F;
var
  GLAD_GL_NV_non_square_matrices: boolean;
const
  GL_FLOAT_MAT2x3_NV = $8B65;
  GL_FLOAT_MAT2x4_NV = $8B66;
  GL_FLOAT_MAT3x2_NV = $8B67;
  GL_FLOAT_MAT3x4_NV = $8B68;
  GL_FLOAT_MAT4x2_NV = $8B69;
  GL_FLOAT_MAT4x3_NV = $8B6A;
var
  GLAD_GL_NV_pack_subimage: boolean;
const
  GL_PACK_ROW_LENGTH_NV = $0D02;
  GL_PACK_SKIP_ROWS_NV = $0D03;
  GL_PACK_SKIP_PIXELS_NV = $0D04;
var
  GLAD_GL_NV_path_rendering: boolean;
const
  GL_PATH_FORMAT_SVG_NV = $9070;
  GL_PATH_FORMAT_PS_NV = $9071;
  GL_STANDARD_FONT_NAME_NV = $9072;
  GL_SYSTEM_FONT_NAME_NV = $9073;
  GL_FILE_NAME_NV = $9074;
  GL_PATH_STROKE_WIDTH_NV = $9075;
  GL_PATH_END_CAPS_NV = $9076;
  GL_PATH_INITIAL_END_CAP_NV = $9077;
  GL_PATH_TERMINAL_END_CAP_NV = $9078;
  GL_PATH_JOIN_STYLE_NV = $9079;
  GL_PATH_MITER_LIMIT_NV = $907A;
  GL_PATH_DASH_CAPS_NV = $907B;
  GL_PATH_INITIAL_DASH_CAP_NV = $907C;
  GL_PATH_TERMINAL_DASH_CAP_NV = $907D;
  GL_PATH_DASH_OFFSET_NV = $907E;
  GL_PATH_CLIENT_LENGTH_NV = $907F;
  GL_PATH_FILL_MODE_NV = $9080;
  GL_PATH_FILL_MASK_NV = $9081;
  GL_PATH_FILL_COVER_MODE_NV = $9082;
  GL_PATH_STROKE_COVER_MODE_NV = $9083;
  GL_PATH_STROKE_MASK_NV = $9084;
  GL_COUNT_UP_NV = $9088;
  GL_COUNT_DOWN_NV = $9089;
  GL_PATH_OBJECT_BOUNDING_BOX_NV = $908A;
  GL_CONVEX_HULL_NV = $908B;
  GL_BOUNDING_BOX_NV = $908D;
  GL_TRANSLATE_X_NV = $908E;
  GL_TRANSLATE_Y_NV = $908F;
  GL_TRANSLATE_2D_NV = $9090;
  GL_TRANSLATE_3D_NV = $9091;
  GL_AFFINE_2D_NV = $9092;
  GL_AFFINE_3D_NV = $9094;
  GL_TRANSPOSE_AFFINE_2D_NV = $9096;
  GL_TRANSPOSE_AFFINE_3D_NV = $9098;
  GL_UTF8_NV = $909A;
  GL_UTF16_NV = $909B;
  GL_BOUNDING_BOX_OF_BOUNDING_BOXES_NV = $909C;
  GL_PATH_COMMAND_COUNT_NV = $909D;
  GL_PATH_COORD_COUNT_NV = $909E;
  GL_PATH_DASH_ARRAY_COUNT_NV = $909F;
  GL_PATH_COMPUTED_LENGTH_NV = $90A0;
  GL_PATH_FILL_BOUNDING_BOX_NV = $90A1;
  GL_PATH_STROKE_BOUNDING_BOX_NV = $90A2;
  GL_SQUARE_NV = $90A3;
  GL_ROUND_NV = $90A4;
  GL_TRIANGULAR_NV = $90A5;
  GL_BEVEL_NV = $90A6;
  GL_MITER_REVERT_NV = $90A7;
  GL_MITER_TRUNCATE_NV = $90A8;
  GL_SKIP_MISSING_GLYPH_NV = $90A9;
  GL_USE_MISSING_GLYPH_NV = $90AA;
  GL_PATH_ERROR_POSITION_NV = $90AB;
  GL_ACCUM_ADJACENT_PAIRS_NV = $90AD;
  GL_ADJACENT_PAIRS_NV = $90AE;
  GL_FIRST_TO_REST_NV = $90AF;
  GL_PATH_GEN_MODE_NV = $90B0;
  GL_PATH_GEN_COEFF_NV = $90B1;
  GL_PATH_GEN_COMPONENTS_NV = $90B3;
  GL_PATH_STENCIL_FUNC_NV = $90B7;
  GL_PATH_STENCIL_REF_NV = $90B8;
  GL_PATH_STENCIL_VALUE_MASK_NV = $90B9;
  GL_PATH_STENCIL_DEPTH_OFFSET_FACTOR_NV = $90BD;
  GL_PATH_STENCIL_DEPTH_OFFSET_UNITS_NV = $90BE;
  GL_PATH_COVER_DEPTH_FUNC_NV = $90BF;
  GL_PATH_DASH_OFFSET_RESET_NV = $90B4;
  GL_MOVE_TO_RESETS_NV = $90B5;
  GL_MOVE_TO_CONTINUES_NV = $90B6;
  GL_CLOSE_PATH_NV = $00;
  GL_MOVE_TO_NV = $02;
  GL_RELATIVE_MOVE_TO_NV = $03;
  GL_LINE_TO_NV = $04;
  GL_RELATIVE_LINE_TO_NV = $05;
  GL_HORIZONTAL_LINE_TO_NV = $06;
  GL_RELATIVE_HORIZONTAL_LINE_TO_NV = $07;
  GL_VERTICAL_LINE_TO_NV = $08;
  GL_RELATIVE_VERTICAL_LINE_TO_NV = $09;
  GL_QUADRATIC_CURVE_TO_NV = $0A;
  GL_RELATIVE_QUADRATIC_CURVE_TO_NV = $0B;
  GL_CUBIC_CURVE_TO_NV = $0C;
  GL_RELATIVE_CUBIC_CURVE_TO_NV = $0D;
  GL_SMOOTH_QUADRATIC_CURVE_TO_NV = $0E;
  GL_RELATIVE_SMOOTH_QUADRATIC_CURVE_TO_NV = $0F;
  GL_SMOOTH_CUBIC_CURVE_TO_NV = $10;
  GL_RELATIVE_SMOOTH_CUBIC_CURVE_TO_NV = $11;
  GL_SMALL_CCW_ARC_TO_NV = $12;
  GL_RELATIVE_SMALL_CCW_ARC_TO_NV = $13;
  GL_SMALL_CW_ARC_TO_NV = $14;
  GL_RELATIVE_SMALL_CW_ARC_TO_NV = $15;
  GL_LARGE_CCW_ARC_TO_NV = $16;
  GL_RELATIVE_LARGE_CCW_ARC_TO_NV = $17;
  GL_LARGE_CW_ARC_TO_NV = $18;
  GL_RELATIVE_LARGE_CW_ARC_TO_NV = $19;
  GL_RESTART_PATH_NV = $F0;
  GL_DUP_FIRST_CUBIC_CURVE_TO_NV = $F2;
  GL_DUP_LAST_CUBIC_CURVE_TO_NV = $F4;
  GL_RECT_NV = $F6;
  GL_CIRCULAR_CCW_ARC_TO_NV = $F8;
  GL_CIRCULAR_CW_ARC_TO_NV = $FA;
  GL_CIRCULAR_TANGENT_ARC_TO_NV = $FC;
  GL_ARC_TO_NV = $FE;
  GL_RELATIVE_ARC_TO_NV = $FF;
  GL_BOLD_BIT_NV = $01;
  GL_ITALIC_BIT_NV = $02;
  GL_GLYPH_WIDTH_BIT_NV = $01;
  GL_GLYPH_HEIGHT_BIT_NV = $02;
  GL_GLYPH_HORIZONTAL_BEARING_X_BIT_NV = $04;
  GL_GLYPH_HORIZONTAL_BEARING_Y_BIT_NV = $08;
  GL_GLYPH_HORIZONTAL_BEARING_ADVANCE_BIT_NV = $10;
  GL_GLYPH_VERTICAL_BEARING_X_BIT_NV = $20;
  GL_GLYPH_VERTICAL_BEARING_Y_BIT_NV = $40;
  GL_GLYPH_VERTICAL_BEARING_ADVANCE_BIT_NV = $80;
  GL_GLYPH_HAS_KERNING_BIT_NV = $100;
  GL_FONT_X_MIN_BOUNDS_BIT_NV = $00010000;
  GL_FONT_Y_MIN_BOUNDS_BIT_NV = $00020000;
  GL_FONT_X_MAX_BOUNDS_BIT_NV = $00040000;
  GL_FONT_Y_MAX_BOUNDS_BIT_NV = $00080000;
  GL_FONT_UNITS_PER_EM_BIT_NV = $00100000;
  GL_FONT_ASCENDER_BIT_NV = $00200000;
  GL_FONT_DESCENDER_BIT_NV = $00400000;
  GL_FONT_HEIGHT_BIT_NV = $00800000;
  GL_FONT_MAX_ADVANCE_WIDTH_BIT_NV = $01000000;
  GL_FONT_MAX_ADVANCE_HEIGHT_BIT_NV = $02000000;
  GL_FONT_UNDERLINE_POSITION_BIT_NV = $04000000;
  GL_FONT_UNDERLINE_THICKNESS_BIT_NV = $08000000;
  GL_FONT_HAS_KERNING_BIT_NV = $10000000;
  GL_ROUNDED_RECT_NV = $E8;
  GL_RELATIVE_ROUNDED_RECT_NV = $E9;
  GL_ROUNDED_RECT2_NV = $EA;
  GL_RELATIVE_ROUNDED_RECT2_NV = $EB;
  GL_ROUNDED_RECT4_NV = $EC;
  GL_RELATIVE_ROUNDED_RECT4_NV = $ED;
  GL_ROUNDED_RECT8_NV = $EE;
  GL_RELATIVE_ROUNDED_RECT8_NV = $EF;
  GL_RELATIVE_RECT_NV = $F7;
  GL_FONT_GLYPHS_AVAILABLE_NV = $9368;
  GL_FONT_TARGET_UNAVAILABLE_NV = $9369;
  GL_FONT_UNAVAILABLE_NV = $936A;
  GL_FONT_UNINTELLIGIBLE_NV = $936B;
  GL_CONIC_CURVE_TO_NV = $1A;
  GL_RELATIVE_CONIC_CURVE_TO_NV = $1B;
  GL_FONT_NUM_GLYPH_INDICES_BIT_NV = $20000000;
  GL_STANDARD_FONT_FORMAT_NV = $936C;
  GL_2_BYTES_NV = $1407;
  GL_3_BYTES_NV = $1408;
  GL_4_BYTES_NV = $1409;
  GL_EYE_LINEAR_NV = $2400;
  GL_OBJECT_LINEAR_NV = $2401;
  GL_CONSTANT_NV = $8576;
  GL_PATH_FOG_GEN_MODE_NV = $90AC;
  GL_PRIMARY_COLOR = $8577;
  GL_PRIMARY_COLOR_NV = $852C;
  GL_SECONDARY_COLOR_NV = $852D;
  GL_PATH_GEN_COLOR_FORMAT_NV = $90B2;
  GL_PATH_PROJECTION_NV = $1701;
  GL_PATH_MODELVIEW_NV = $1700;
  GL_PATH_MODELVIEW_STACK_DEPTH_NV = $0BA3;
  GL_PATH_MODELVIEW_MATRIX_NV = $0BA6;
  GL_PATH_MAX_MODELVIEW_STACK_DEPTH_NV = $0D36;
  GL_PATH_TRANSPOSE_MODELVIEW_MATRIX_NV = $84E3;
  GL_PATH_PROJECTION_STACK_DEPTH_NV = $0BA4;
  GL_PATH_PROJECTION_MATRIX_NV = $0BA7;
  GL_PATH_MAX_PROJECTION_STACK_DEPTH_NV = $0D38;
  GL_PATH_TRANSPOSE_PROJECTION_MATRIX_NV = $84E4;
  GL_FRAGMENT_INPUT_NV = $936D;
var
  GLAD_GL_NV_path_rendering_shared_edge: boolean;
const
  GL_SHARED_EDGE_NV = $C0;
var
  GLAD_GL_NV_pixel_buffer_object: boolean;
const
  GL_PIXEL_PACK_BUFFER_NV = $88EB;
  GL_PIXEL_UNPACK_BUFFER_NV = $88EC;
  GL_PIXEL_PACK_BUFFER_BINDING_NV = $88ED;
  GL_PIXEL_UNPACK_BUFFER_BINDING_NV = $88EF;
var
  GLAD_GL_NV_polygon_mode: boolean;
const
  GL_POLYGON_MODE_NV = $0B40;
  GL_POLYGON_OFFSET_POINT_NV = $2A01;
  GL_POLYGON_OFFSET_LINE_NV = $2A02;
  GL_POINT_NV = $1B00;
  GL_LINE_NV = $1B01;
  GL_FILL_NV = $1B02;
var
  GLAD_GL_NV_primitive_shading_rate: boolean;
const
  GL_SHADING_RATE_IMAGE_PER_PRIMITIVE_NV = $95B1;
  GL_SHADING_RATE_IMAGE_PALETTE_COUNT_NV = $95B2;
var
  GLAD_GL_NV_read_buffer: boolean;
const
  GL_READ_BUFFER_NV = $0C02;
var
  GLAD_GL_NV_read_buffer_front: boolean;
var
  GLAD_GL_NV_read_depth: boolean;
var
  GLAD_GL_NV_read_depth_stencil: boolean;
var
  GLAD_GL_NV_read_stencil: boolean;
var
  GLAD_GL_NV_representative_fragment_test: boolean;
const
  GL_REPRESENTATIVE_FRAGMENT_TEST_NV = $937F;
var
  GLAD_GL_NV_sRGB_formats: boolean;
const
  GL_SLUMINANCE_NV = $8C46;
  GL_SLUMINANCE_ALPHA_NV = $8C44;
  GL_SRGB8_NV = $8C41;
  GL_SLUMINANCE8_NV = $8C47;
  GL_SLUMINANCE8_ALPHA8_NV = $8C45;
  GL_COMPRESSED_SRGB_S3TC_DXT1_NV = $8C4C;
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_NV = $8C4D;
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_NV = $8C4E;
  GL_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_NV = $8C4F;
  GL_ETC1_SRGB8_NV = $88EE;
var
  GLAD_GL_NV_sample_locations: boolean;
const
  GL_SAMPLE_LOCATION_SUBPIXEL_BITS_NV = $933D;
  GL_SAMPLE_LOCATION_PIXEL_GRID_WIDTH_NV = $933E;
  GL_SAMPLE_LOCATION_PIXEL_GRID_HEIGHT_NV = $933F;
  GL_PROGRAMMABLE_SAMPLE_LOCATION_TABLE_SIZE_NV = $9340;
  GL_SAMPLE_LOCATION_NV = $8E50;
  GL_PROGRAMMABLE_SAMPLE_LOCATION_NV = $9341;
  GL_FRAMEBUFFER_PROGRAMMABLE_SAMPLE_LOCATIONS_NV = $9342;
  GL_FRAMEBUFFER_SAMPLE_LOCATION_PIXEL_GRID_NV = $9343;
var
  GLAD_GL_NV_sample_mask_override_coverage: boolean;
var
  GLAD_GL_NV_scissor_exclusive: boolean;
const
  GL_SCISSOR_TEST_EXCLUSIVE_NV = $9555;
  GL_SCISSOR_BOX_EXCLUSIVE_NV = $9556;
var
  GLAD_GL_NV_shader_atomic_fp16_vector: boolean;
var
  GLAD_GL_NV_shader_noperspective_interpolation: boolean;
var
  GLAD_GL_NV_shader_subgroup_partitioned: boolean;
const
  GL_SUBGROUP_FEATURE_PARTITIONED_BIT_NV = $00000100;
var
  GLAD_GL_NV_shader_texture_footprint: boolean;
var
  GLAD_GL_NV_shading_rate_image: boolean;
const
  GL_SHADING_RATE_IMAGE_NV = $9563;
  GL_SHADING_RATE_NO_INVOCATIONS_NV = $9564;
  GL_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV = $9565;
  GL_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV = $9566;
  GL_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV = $9567;
  GL_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV = $9568;
  GL_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV = $9569;
  GL_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV = $956A;
  GL_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV = $956B;
  GL_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV = $956C;
  GL_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV = $956D;
  GL_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV = $956E;
  GL_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV = $956F;
  GL_SHADING_RATE_IMAGE_BINDING_NV = $955B;
  GL_SHADING_RATE_IMAGE_TEXEL_WIDTH_NV = $955C;
  GL_SHADING_RATE_IMAGE_TEXEL_HEIGHT_NV = $955D;
  GL_SHADING_RATE_IMAGE_PALETTE_SIZE_NV = $955E;
  GL_MAX_COARSE_FRAGMENT_SAMPLES_NV = $955F;
  GL_SHADING_RATE_SAMPLE_ORDER_DEFAULT_NV = $95AE;
  GL_SHADING_RATE_SAMPLE_ORDER_PIXEL_MAJOR_NV = $95AF;
  GL_SHADING_RATE_SAMPLE_ORDER_SAMPLE_MAJOR_NV = $95B0;
var
  GLAD_GL_NV_shadow_samplers_array: boolean;
const
  GL_SAMPLER_2D_ARRAY_SHADOW_NV = $8DC4;
var
  GLAD_GL_NV_shadow_samplers_cube: boolean;
const
  GL_SAMPLER_CUBE_SHADOW_NV = $8DC5;
var
  GLAD_GL_NV_stereo_view_rendering: boolean;
var
  GLAD_GL_NV_texture_border_clamp: boolean;
const
  GL_TEXTURE_BORDER_COLOR_NV = $1004;
  GL_CLAMP_TO_BORDER_NV = $812D;
var
  GLAD_GL_NV_texture_compression_s3tc_update: boolean;
var
  GLAD_GL_NV_texture_npot_2D_mipmap: boolean;
var
  GLAD_GL_NV_timeline_semaphore: boolean;
const
  GL_TIMELINE_SEMAPHORE_VALUE_NV = $9595;
  GL_SEMAPHORE_TYPE_NV = $95B3;
  GL_SEMAPHORE_TYPE_BINARY_NV = $95B4;
  GL_SEMAPHORE_TYPE_TIMELINE_NV = $95B5;
  GL_MAX_TIMELINE_SEMAPHORE_VALUE_DIFFERENCE_NV = $95B6;
var
  GLAD_GL_NV_viewport_array: boolean;
const
  GL_MAX_VIEWPORTS_NV = $825B;
  GL_VIEWPORT_SUBPIXEL_BITS_NV = $825C;
  GL_VIEWPORT_BOUNDS_RANGE_NV = $825D;
  GL_VIEWPORT_INDEX_PROVOKING_VERTEX_NV = $825F;
var
  GLAD_GL_NV_viewport_array2: boolean;
var
  GLAD_GL_NV_viewport_swizzle: boolean;
const
  GL_VIEWPORT_SWIZZLE_POSITIVE_X_NV = $9350;
  GL_VIEWPORT_SWIZZLE_NEGATIVE_X_NV = $9351;
  GL_VIEWPORT_SWIZZLE_POSITIVE_Y_NV = $9352;
  GL_VIEWPORT_SWIZZLE_NEGATIVE_Y_NV = $9353;
  GL_VIEWPORT_SWIZZLE_POSITIVE_Z_NV = $9354;
  GL_VIEWPORT_SWIZZLE_NEGATIVE_Z_NV = $9355;
  GL_VIEWPORT_SWIZZLE_POSITIVE_W_NV = $9356;
  GL_VIEWPORT_SWIZZLE_NEGATIVE_W_NV = $9357;
  GL_VIEWPORT_SWIZZLE_X_NV = $9358;
  GL_VIEWPORT_SWIZZLE_Y_NV = $9359;
  GL_VIEWPORT_SWIZZLE_Z_NV = $935A;
  GL_VIEWPORT_SWIZZLE_W_NV = $935B;
var
  GLAD_GL_OES_EGL_image: boolean;
var
  GLAD_GL_OES_EGL_image_external: boolean;
const
  GL_SAMPLER_EXTERNAL_OES = $8D66;
var
  GLAD_GL_OES_EGL_image_external_essl3: boolean;
var
  GLAD_GL_OES_compressed_ETC1_RGB8_sub_texture: boolean;
var
  GLAD_GL_OES_compressed_ETC1_RGB8_texture: boolean;
const
  GL_ETC1_RGB8_OES = $8D64;
var
  GLAD_GL_OES_compressed_paletted_texture: boolean;
const
  GL_PALETTE4_RGB8_OES = $8B90;
  GL_PALETTE4_RGBA8_OES = $8B91;
  GL_PALETTE4_R5_G6_B5_OES = $8B92;
  GL_PALETTE4_RGBA4_OES = $8B93;
  GL_PALETTE4_RGB5_A1_OES = $8B94;
  GL_PALETTE8_RGB8_OES = $8B95;
  GL_PALETTE8_RGBA8_OES = $8B96;
  GL_PALETTE8_R5_G6_B5_OES = $8B97;
  GL_PALETTE8_RGBA4_OES = $8B98;
  GL_PALETTE8_RGB5_A1_OES = $8B99;
var
  GLAD_GL_OES_copy_image: boolean;
var
  GLAD_GL_OES_depth24: boolean;
const
  GL_DEPTH_COMPONENT24_OES = $81A6;
var
  GLAD_GL_OES_depth32: boolean;
var
  GLAD_GL_OES_depth_texture: boolean;
var
  GLAD_GL_OES_draw_buffers_indexed: boolean;
var
  GLAD_GL_OES_draw_elements_base_vertex: boolean;
var
  GLAD_GL_OES_element_index_uint: boolean;
var
  GLAD_GL_OES_fbo_render_mipmap: boolean;
var
  GLAD_GL_OES_fragment_precision_high: boolean;
var
  GLAD_GL_OES_geometry_point_size: boolean;
var
  GLAD_GL_OES_geometry_shader: boolean;
const
  GL_GEOMETRY_SHADER_OES = $8DD9;
  GL_GEOMETRY_SHADER_BIT_OES = $00000004;
  GL_GEOMETRY_LINKED_VERTICES_OUT_OES = $8916;
  GL_GEOMETRY_LINKED_INPUT_TYPE_OES = $8917;
  GL_GEOMETRY_LINKED_OUTPUT_TYPE_OES = $8918;
  GL_GEOMETRY_SHADER_INVOCATIONS_OES = $887F;
  GL_LAYER_PROVOKING_VERTEX_OES = $825E;
  GL_LINES_ADJACENCY_OES = $000A;
  GL_LINE_STRIP_ADJACENCY_OES = $000B;
  GL_TRIANGLES_ADJACENCY_OES = $000C;
  GL_TRIANGLE_STRIP_ADJACENCY_OES = $000D;
  GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_OES = $8DDF;
  GL_MAX_GEOMETRY_UNIFORM_BLOCKS_OES = $8A2C;
  GL_MAX_COMBINED_GEOMETRY_UNIFORM_COMPONENTS_OES = $8A32;
  GL_MAX_GEOMETRY_INPUT_COMPONENTS_OES = $9123;
  GL_MAX_GEOMETRY_OUTPUT_COMPONENTS_OES = $9124;
  GL_MAX_GEOMETRY_OUTPUT_VERTICES_OES = $8DE0;
  GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_OES = $8DE1;
  GL_MAX_GEOMETRY_SHADER_INVOCATIONS_OES = $8E5A;
  GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_OES = $8C29;
  GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS_OES = $92CF;
  GL_MAX_GEOMETRY_ATOMIC_COUNTERS_OES = $92D5;
  GL_MAX_GEOMETRY_IMAGE_UNIFORMS_OES = $90CD;
  GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS_OES = $90D7;
  GL_FIRST_VERTEX_CONVENTION_OES = $8E4D;
  GL_LAST_VERTEX_CONVENTION_OES = $8E4E;
  GL_UNDEFINED_VERTEX_OES = $8260;
  GL_PRIMITIVES_GENERATED_OES = $8C87;
  GL_FRAMEBUFFER_DEFAULT_LAYERS_OES = $9312;
  GL_MAX_FRAMEBUFFER_LAYERS_OES = $9317;
  GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_OES = $8DA8;
  GL_FRAMEBUFFER_ATTACHMENT_LAYERED_OES = $8DA7;
  GL_REFERENCED_BY_GEOMETRY_SHADER_OES = $9309;
var
  GLAD_GL_OES_get_program_binary: boolean;
const
  GL_PROGRAM_BINARY_LENGTH_OES = $8741;
  GL_NUM_PROGRAM_BINARY_FORMATS_OES = $87FE;
  GL_PROGRAM_BINARY_FORMATS_OES = $87FF;
var
  GLAD_GL_OES_gpu_shader5: boolean;
var
  GLAD_GL_OES_mapbuffer: boolean;
const
  GL_WRITE_ONLY_OES = $88B9;
  GL_BUFFER_ACCESS_OES = $88BB;
  GL_BUFFER_MAPPED_OES = $88BC;
  GL_BUFFER_MAP_POINTER_OES = $88BD;
var
  GLAD_GL_OES_packed_depth_stencil: boolean;
var
  GLAD_GL_OES_primitive_bounding_box: boolean;
const
  GL_PRIMITIVE_BOUNDING_BOX_OES = $92BE;
var
  GLAD_GL_OES_required_internalformat: boolean;
const
  GL_ALPHA8_OES = $803C;
  GL_DEPTH_COMPONENT16_OES = $81A5;
  GL_LUMINANCE4_ALPHA4_OES = $8043;
  GL_LUMINANCE8_ALPHA8_OES = $8045;
  GL_LUMINANCE8_OES = $8040;
  GL_RGBA4_OES = $8056;
  GL_RGB5_A1_OES = $8057;
  GL_RGB565_OES = $8D62;
  GL_RGB8_OES = $8051;
  GL_RGBA8_OES = $8058;
var
  GLAD_GL_OES_rgb8_rgba8: boolean;
var
  GLAD_GL_OES_sample_shading: boolean;
const
  GL_SAMPLE_SHADING_OES = $8C36;
  GL_MIN_SAMPLE_SHADING_VALUE_OES = $8C37;
var
  GLAD_GL_OES_sample_variables: boolean;
var
  GLAD_GL_OES_shader_image_atomic: boolean;
var
  GLAD_GL_OES_shader_io_blocks: boolean;
var
  GLAD_GL_OES_shader_multisample_interpolation: boolean;
const
  GL_MIN_FRAGMENT_INTERPOLATION_OFFSET_OES = $8E5B;
  GL_MAX_FRAGMENT_INTERPOLATION_OFFSET_OES = $8E5C;
  GL_FRAGMENT_INTERPOLATION_OFFSET_BITS_OES = $8E5D;
var
  GLAD_GL_OES_standard_derivatives: boolean;
const
  GL_FRAGMENT_SHADER_DERIVATIVE_HINT_OES = $8B8B;
var
  GLAD_GL_OES_stencil1: boolean;
const
  GL_STENCIL_INDEX1_OES = $8D46;
var
  GLAD_GL_OES_stencil4: boolean;
const
  GL_STENCIL_INDEX4_OES = $8D47;
var
  GLAD_GL_OES_surfaceless_context: boolean;
const
  GL_FRAMEBUFFER_UNDEFINED_OES = $8219;
var
  GLAD_GL_OES_tessellation_point_size: boolean;
var
  GLAD_GL_OES_tessellation_shader: boolean;
const
  GL_PATCHES_OES = $000E;
  GL_PATCH_VERTICES_OES = $8E72;
  GL_TESS_CONTROL_OUTPUT_VERTICES_OES = $8E75;
  GL_TESS_GEN_MODE_OES = $8E76;
  GL_TESS_GEN_SPACING_OES = $8E77;
  GL_TESS_GEN_VERTEX_ORDER_OES = $8E78;
  GL_TESS_GEN_POINT_MODE_OES = $8E79;
  GL_ISOLINES_OES = $8E7A;
  GL_QUADS_OES = $0007;
  GL_FRACTIONAL_ODD_OES = $8E7B;
  GL_FRACTIONAL_EVEN_OES = $8E7C;
  GL_MAX_PATCH_VERTICES_OES = $8E7D;
  GL_MAX_TESS_GEN_LEVEL_OES = $8E7E;
  GL_MAX_TESS_CONTROL_UNIFORM_COMPONENTS_OES = $8E7F;
  GL_MAX_TESS_EVALUATION_UNIFORM_COMPONENTS_OES = $8E80;
  GL_MAX_TESS_CONTROL_TEXTURE_IMAGE_UNITS_OES = $8E81;
  GL_MAX_TESS_EVALUATION_TEXTURE_IMAGE_UNITS_OES = $8E82;
  GL_MAX_TESS_CONTROL_OUTPUT_COMPONENTS_OES = $8E83;
  GL_MAX_TESS_PATCH_COMPONENTS_OES = $8E84;
  GL_MAX_TESS_CONTROL_TOTAL_OUTPUT_COMPONENTS_OES = $8E85;
  GL_MAX_TESS_EVALUATION_OUTPUT_COMPONENTS_OES = $8E86;
  GL_MAX_TESS_CONTROL_UNIFORM_BLOCKS_OES = $8E89;
  GL_MAX_TESS_EVALUATION_UNIFORM_BLOCKS_OES = $8E8A;
  GL_MAX_TESS_CONTROL_INPUT_COMPONENTS_OES = $886C;
  GL_MAX_TESS_EVALUATION_INPUT_COMPONENTS_OES = $886D;
  GL_MAX_COMBINED_TESS_CONTROL_UNIFORM_COMPONENTS_OES = $8E1E;
  GL_MAX_COMBINED_TESS_EVALUATION_UNIFORM_COMPONENTS_OES = $8E1F;
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS_OES = $92CD;
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS_OES = $92CE;
  GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS_OES = $92D3;
  GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS_OES = $92D4;
  GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS_OES = $90CB;
  GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS_OES = $90CC;
  GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS_OES = $90D8;
  GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS_OES = $90D9;
  GL_PRIMITIVE_RESTART_FOR_PATCHES_SUPPORTED_OES = $8221;
  GL_IS_PER_PATCH_OES = $92E7;
  GL_REFERENCED_BY_TESS_CONTROL_SHADER_OES = $9307;
  GL_REFERENCED_BY_TESS_EVALUATION_SHADER_OES = $9308;
  GL_TESS_CONTROL_SHADER_OES = $8E88;
  GL_TESS_EVALUATION_SHADER_OES = $8E87;
  GL_TESS_CONTROL_SHADER_BIT_OES = $00000008;
  GL_TESS_EVALUATION_SHADER_BIT_OES = $00000010;
var
  GLAD_GL_OES_texture_3D: boolean;
const
  GL_TEXTURE_WRAP_R_OES = $8072;
  GL_TEXTURE_3D_OES = $806F;
  GL_TEXTURE_BINDING_3D_OES = $806A;
  GL_MAX_3D_TEXTURE_SIZE_OES = $8073;
  GL_SAMPLER_3D_OES = $8B5F;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_3D_ZOFFSET_OES = $8CD4;
var
  GLAD_GL_OES_texture_border_clamp: boolean;
const
  GL_TEXTURE_BORDER_COLOR_OES = $1004;
  GL_CLAMP_TO_BORDER_OES = $812D;
var
  GLAD_GL_OES_texture_buffer: boolean;
const
  GL_TEXTURE_BUFFER_OES = $8C2A;
  GL_TEXTURE_BUFFER_BINDING_OES = $8C2A;
  GL_MAX_TEXTURE_BUFFER_SIZE_OES = $8C2B;
  GL_TEXTURE_BINDING_BUFFER_OES = $8C2C;
  GL_TEXTURE_BUFFER_DATA_STORE_BINDING_OES = $8C2D;
  GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT_OES = $919F;
  GL_SAMPLER_BUFFER_OES = $8DC2;
  GL_INT_SAMPLER_BUFFER_OES = $8DD0;
  GL_UNSIGNED_INT_SAMPLER_BUFFER_OES = $8DD8;
  GL_IMAGE_BUFFER_OES = $9051;
  GL_INT_IMAGE_BUFFER_OES = $905C;
  GL_UNSIGNED_INT_IMAGE_BUFFER_OES = $9067;
  GL_TEXTURE_BUFFER_OFFSET_OES = $919D;
  GL_TEXTURE_BUFFER_SIZE_OES = $919E;
var
  GLAD_GL_OES_texture_compression_astc: boolean;
const
  GL_COMPRESSED_RGBA_ASTC_3x3x3_OES = $93C0;
  GL_COMPRESSED_RGBA_ASTC_4x3x3_OES = $93C1;
  GL_COMPRESSED_RGBA_ASTC_4x4x3_OES = $93C2;
  GL_COMPRESSED_RGBA_ASTC_4x4x4_OES = $93C3;
  GL_COMPRESSED_RGBA_ASTC_5x4x4_OES = $93C4;
  GL_COMPRESSED_RGBA_ASTC_5x5x4_OES = $93C5;
  GL_COMPRESSED_RGBA_ASTC_5x5x5_OES = $93C6;
  GL_COMPRESSED_RGBA_ASTC_6x5x5_OES = $93C7;
  GL_COMPRESSED_RGBA_ASTC_6x6x5_OES = $93C8;
  GL_COMPRESSED_RGBA_ASTC_6x6x6_OES = $93C9;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_3x3x3_OES = $93E0;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x3x3_OES = $93E1;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x3_OES = $93E2;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4x4_OES = $93E3;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x4x4_OES = $93E4;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x4_OES = $93E5;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_5x5x5_OES = $93E6;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x5x5_OES = $93E7;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x5_OES = $93E8;
  GL_COMPRESSED_SRGB8_ALPHA8_ASTC_6x6x6_OES = $93E9;
var
  GLAD_GL_OES_texture_cube_map_array: boolean;
const
  GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_OES = $900A;
  GL_SAMPLER_CUBE_MAP_ARRAY_OES = $900C;
  GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_OES = $900D;
  GL_INT_SAMPLER_CUBE_MAP_ARRAY_OES = $900E;
  GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_OES = $900F;
  GL_IMAGE_CUBE_MAP_ARRAY_OES = $9054;
  GL_INT_IMAGE_CUBE_MAP_ARRAY_OES = $905F;
  GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY_OES = $906A;
var
  GLAD_GL_OES_texture_float: boolean;
var
  GLAD_GL_OES_texture_float_linear: boolean;
var
  GLAD_GL_OES_texture_half_float: boolean;
const
  GL_HALF_FLOAT_OES = $8D61;
var
  GLAD_GL_OES_texture_half_float_linear: boolean;
var
  GLAD_GL_OES_texture_npot: boolean;
var
  GLAD_GL_OES_texture_stencil8: boolean;
const
  GL_STENCIL_INDEX_OES = $1901;
  GL_STENCIL_INDEX8_OES = $8D48;
var
  GLAD_GL_OES_texture_storage_multisample_2d_array: boolean;
const
  GL_TEXTURE_2D_MULTISAMPLE_ARRAY_OES = $9102;
  GL_TEXTURE_BINDING_2D_MULTISAMPLE_ARRAY_OES = $9105;
  GL_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = $910B;
  GL_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = $910C;
  GL_UNSIGNED_INT_SAMPLER_2D_MULTISAMPLE_ARRAY_OES = $910D;
var
  GLAD_GL_OES_texture_view: boolean;
const
  GL_TEXTURE_VIEW_MIN_LEVEL_OES = $82DB;
  GL_TEXTURE_VIEW_NUM_LEVELS_OES = $82DC;
  GL_TEXTURE_VIEW_MIN_LAYER_OES = $82DD;
  GL_TEXTURE_VIEW_NUM_LAYERS_OES = $82DE;
var
  GLAD_GL_OES_vertex_array_object: boolean;
const
  GL_VERTEX_ARRAY_BINDING_OES = $85B5;
var
  GLAD_GL_OES_vertex_half_float: boolean;
var
  GLAD_GL_OES_vertex_type_10_10_10_2: boolean;
const
  GL_UNSIGNED_INT_10_10_10_2_OES = $8DF6;
  GL_INT_10_10_10_2_OES = $8DF7;
var
  GLAD_GL_OES_viewport_array: boolean;
const
  GL_MAX_VIEWPORTS_OES = $825B;
  GL_VIEWPORT_SUBPIXEL_BITS_OES = $825C;
  GL_VIEWPORT_BOUNDS_RANGE_OES = $825D;
  GL_VIEWPORT_INDEX_PROVOKING_VERTEX_OES = $825F;
var
  GLAD_GL_OVR_multiview: boolean;
const
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_NUM_VIEWS_OVR = $9630;
  GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_BASE_VIEW_INDEX_OVR = $9632;
  GL_MAX_VIEWS_OVR = $9631;
  GL_FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR = $9633;
var
  GLAD_GL_OVR_multiview2: boolean;
var
  GLAD_GL_OVR_multiview_multisampled_render_to_texture: boolean;
var
  GLAD_GL_QCOM_YUV_texture_gather: boolean;
var
  GLAD_GL_QCOM_alpha_test: boolean;
const
  GL_ALPHA_TEST_QCOM = $0BC0;
  GL_ALPHA_TEST_FUNC_QCOM = $0BC1;
  GL_ALPHA_TEST_REF_QCOM = $0BC2;
var
  GLAD_GL_QCOM_binning_control: boolean;
const
  GL_BINNING_CONTROL_HINT_QCOM = $8FB0;
  GL_CPU_OPTIMIZED_QCOM = $8FB1;
  GL_GPU_OPTIMIZED_QCOM = $8FB2;
  GL_RENDER_DIRECT_TO_FRAMEBUFFER_QCOM = $8FB3;
var
  GLAD_GL_QCOM_driver_control: boolean;
var
  GLAD_GL_QCOM_extended_get: boolean;
const
  GL_TEXTURE_WIDTH_QCOM = $8BD2;
  GL_TEXTURE_HEIGHT_QCOM = $8BD3;
  GL_TEXTURE_DEPTH_QCOM = $8BD4;
  GL_TEXTURE_INTERNAL_FORMAT_QCOM = $8BD5;
  GL_TEXTURE_FORMAT_QCOM = $8BD6;
  GL_TEXTURE_TYPE_QCOM = $8BD7;
  GL_TEXTURE_IMAGE_VALID_QCOM = $8BD8;
  GL_TEXTURE_NUM_LEVELS_QCOM = $8BD9;
  GL_TEXTURE_TARGET_QCOM = $8BDA;
  GL_TEXTURE_OBJECT_VALID_QCOM = $8BDB;
  GL_STATE_RESTORE = $8BDC;
var
  GLAD_GL_QCOM_extended_get2: boolean;
var
  GLAD_GL_QCOM_frame_extrapolation: boolean;
var
  GLAD_GL_QCOM_framebuffer_foveated: boolean;
const
  GL_FOVEATION_ENABLE_BIT_QCOM = $00000001;
  GL_FOVEATION_SCALED_BIN_METHOD_BIT_QCOM = $00000002;
var
  GLAD_GL_QCOM_motion_estimation: boolean;
const
  GL_MOTION_ESTIMATION_SEARCH_BLOCK_X_QCOM = $8C90;
  GL_MOTION_ESTIMATION_SEARCH_BLOCK_Y_QCOM = $8C91;
var
  GLAD_GL_QCOM_perfmon_global_mode: boolean;
const
  GL_PERFMON_GLOBAL_MODE_QCOM = $8FA0;
var
  GLAD_GL_QCOM_render_sRGB_R8_RG8: boolean;
var
  GLAD_GL_QCOM_render_shared_exponent: boolean;
var
  GLAD_GL_QCOM_shader_framebuffer_fetch_noncoherent: boolean;
const
  GL_FRAMEBUFFER_FETCH_NONCOHERENT_QCOM = $96A2;
var
  GLAD_GL_QCOM_shader_framebuffer_fetch_rate: boolean;
var
  GLAD_GL_QCOM_shading_rate: boolean;
const
  GL_SHADING_RATE_QCOM = $96A4;
  GL_SHADING_RATE_PRESERVE_ASPECT_RATIO_QCOM = $96A5;
  GL_SHADING_RATE_1X1_PIXELS_QCOM = $96A6;
  GL_SHADING_RATE_1X2_PIXELS_QCOM = $96A7;
  GL_SHADING_RATE_2X1_PIXELS_QCOM = $96A8;
  GL_SHADING_RATE_2X2_PIXELS_QCOM = $96A9;
  GL_SHADING_RATE_4X2_PIXELS_QCOM = $96AC;
  GL_SHADING_RATE_4X4_PIXELS_QCOM = $96AE;
var
  GLAD_GL_QCOM_texture_foveated: boolean;
const
  GL_TEXTURE_FOVEATED_FEATURE_BITS_QCOM = $8BFB;
  GL_TEXTURE_FOVEATED_MIN_PIXEL_DENSITY_QCOM = $8BFC;
  GL_TEXTURE_FOVEATED_FEATURE_QUERY_QCOM = $8BFD;
  GL_TEXTURE_FOVEATED_NUM_FOCAL_POINTS_QUERY_QCOM = $8BFE;
  GL_FRAMEBUFFER_INCOMPLETE_FOVEATION_QCOM = $8BFF;
var
  GLAD_GL_QCOM_texture_foveated2: boolean;
const
  GL_TEXTURE_FOVEATED_CUTOFF_DENSITY_QCOM = $96A0;
var
  GLAD_GL_QCOM_texture_foveated_subsampled_layout: boolean;
const
  GL_FOVEATION_SUBSAMPLED_LAYOUT_METHOD_BIT_QCOM = $00000004;
  GL_MAX_SHADER_SUBSAMPLED_IMAGE_UNITS_QCOM = $8FA1;
var
  GLAD_GL_QCOM_texture_lod_bias: boolean;
const
  GL_TEXTURE_LOD_BIAS_QCOM = $8C96;
var
  GLAD_GL_QCOM_tiled_rendering: boolean;
const
  GL_COLOR_BUFFER_BIT0_QCOM = $00000001;
  GL_COLOR_BUFFER_BIT1_QCOM = $00000002;
  GL_COLOR_BUFFER_BIT2_QCOM = $00000004;
  GL_COLOR_BUFFER_BIT3_QCOM = $00000008;
  GL_COLOR_BUFFER_BIT4_QCOM = $00000010;
  GL_COLOR_BUFFER_BIT5_QCOM = $00000020;
  GL_COLOR_BUFFER_BIT6_QCOM = $00000040;
  GL_COLOR_BUFFER_BIT7_QCOM = $00000080;
  GL_DEPTH_BUFFER_BIT0_QCOM = $00000100;
  GL_DEPTH_BUFFER_BIT1_QCOM = $00000200;
  GL_DEPTH_BUFFER_BIT2_QCOM = $00000400;
  GL_DEPTH_BUFFER_BIT3_QCOM = $00000800;
  GL_DEPTH_BUFFER_BIT4_QCOM = $00001000;
  GL_DEPTH_BUFFER_BIT5_QCOM = $00002000;
  GL_DEPTH_BUFFER_BIT6_QCOM = $00004000;
  GL_DEPTH_BUFFER_BIT7_QCOM = $00008000;
  GL_STENCIL_BUFFER_BIT0_QCOM = $00010000;
  GL_STENCIL_BUFFER_BIT1_QCOM = $00020000;
  GL_STENCIL_BUFFER_BIT2_QCOM = $00040000;
  GL_STENCIL_BUFFER_BIT3_QCOM = $00080000;
  GL_STENCIL_BUFFER_BIT4_QCOM = $00100000;
  GL_STENCIL_BUFFER_BIT5_QCOM = $00200000;
  GL_STENCIL_BUFFER_BIT6_QCOM = $00400000;
  GL_STENCIL_BUFFER_BIT7_QCOM = $00800000;
  GL_MULTISAMPLE_BUFFER_BIT0_QCOM = $01000000;
  GL_MULTISAMPLE_BUFFER_BIT1_QCOM = $02000000;
  GL_MULTISAMPLE_BUFFER_BIT2_QCOM = $04000000;
  GL_MULTISAMPLE_BUFFER_BIT3_QCOM = $08000000;
  GL_MULTISAMPLE_BUFFER_BIT4_QCOM = $10000000;
  GL_MULTISAMPLE_BUFFER_BIT5_QCOM = $20000000;
  GL_MULTISAMPLE_BUFFER_BIT6_QCOM = $40000000;
  GL_MULTISAMPLE_BUFFER_BIT7_QCOM = $80000000;
var
  GLAD_GL_QCOM_writeonly_rendering: boolean;
const
  GL_WRITEONLY_RENDERING_QCOM = $8823;
var
  GLAD_GL_QCOM_ycbcr_degamma: boolean;
const
  GL_TEXTURE_Y_DEGAMMA_QCOM = $9710;
  GL_TEXTURE_CBCR_DEGAMMA_QCOM = $9711;
var
  GLAD_GL_VIV_shader_binary: boolean;
const
  GL_SHADER_BINARY_VIV = $8FC4;

var
  glRenderbufferStorageMultisampleAdvancedAMD: procedure (target: GLenum; samples: GLsizei; storageSamples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedRenderbufferStorageMultisampleAdvancedAMD: procedure (renderbuffer: GLuint; samples: GLsizei; storageSamples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPerfMonitorGroupsAMD: procedure (numGroups: PGLint; groupsSize: GLsizei; groups: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPerfMonitorCountersAMD: procedure (group: GLuint; numCounters: PGLint; maxActiveCounters: PGLint; counterSize: GLsizei; counters: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPerfMonitorGroupStringAMD: procedure (group: GLuint; bufSize: GLsizei; length: PGLsizei; groupString: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPerfMonitorCounterStringAMD: procedure (group: GLuint; counter: GLuint; bufSize: GLsizei; length: PGLsizei; counterString: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPerfMonitorCounterInfoAMD: procedure (group: GLuint; counter: GLuint; pname: GLenum; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenPerfMonitorsAMD: procedure (n: GLsizei; monitors: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeletePerfMonitorsAMD: procedure (n: GLsizei; monitors: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSelectPerfMonitorCountersAMD: procedure (monitor: GLuint; enable: GLboolean; group: GLuint; numCounters: GLint; counterList: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBeginPerfMonitorAMD: procedure (monitor: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndPerfMonitorAMD: procedure (monitor: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPerfMonitorCounterDataAMD: procedure (monitor: GLuint; pname: GLenum; dataSize: GLsizei; data: PGLuint; bytesWritten: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlitFramebufferANGLE: procedure (srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; mask: GLbitfield; filter: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRenderbufferStorageMultisampleANGLE: procedure (target: GLenum; samples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawArraysInstancedANGLE: procedure (mode: GLenum; first: GLint; count: GLsizei; primcount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElementsInstancedANGLE: procedure (mode: GLenum; count: GLsizei; type_: GLenum; indices: Pointer; primcount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribDivisorANGLE: procedure (index: GLuint; divisor: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTranslatedShaderSourceANGLE: procedure (shader: GLuint; bufSize: GLsizei; length: PGLsizei; source: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTextureLevelsAPPLE: procedure (destinationTexture: GLuint; sourceTexture: GLuint; sourceBaseLevel: GLint; sourceLevelCount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRenderbufferStorageMultisampleAPPLE: procedure (target: GLenum; samples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glResolveMultisampleFramebufferAPPLE: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFenceSyncAPPLE: function (condition: GLenum; flags: GLbitfield): GLsync; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsSyncAPPLE: function (sync: GLsync): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteSyncAPPLE: procedure (sync: GLsync); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClientWaitSyncAPPLE: function (sync: GLsync; flags: GLbitfield; timeout: GLuint64): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWaitSyncAPPLE: procedure (sync: GLsync; flags: GLbitfield; timeout: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetInteger64vAPPLE: procedure (pname: GLenum; params: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSyncivAPPLE: procedure (sync: GLsync; pname: GLenum; count: GLsizei; length: PGLsizei; values: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMaxActiveShaderCoresARM: procedure (count: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEGLImageTargetTexStorageEXT: procedure (target: GLenum; image: GLeglImageOES; attrib_list: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEGLImageTargetTextureStorageEXT: procedure (texture: GLuint; image: GLeglImageOES; attrib_list: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawArraysInstancedBaseInstanceEXT: procedure (mode: GLenum; first: GLint; count: GLsizei; instancecount: GLsizei; baseinstance: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElementsInstancedBaseInstanceEXT: procedure (mode: GLenum; count: GLsizei; type_: GLenum; indices: Pointer; instancecount: GLsizei; baseinstance: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElementsInstancedBaseVertexBaseInstanceEXT: procedure (mode: GLenum; count: GLsizei; type_: GLenum; indices: Pointer; instancecount: GLsizei; basevertex: GLint; baseinstance: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindFragDataLocationIndexedEXT: procedure (program_: GLuint; colorNumber: GLuint; index: GLuint; name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindFragDataLocationEXT: procedure (program_: GLuint; color: GLuint; name: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramResourceLocationIndexEXT: function (program_: GLuint; programInterface: GLenum; name: PGLchar): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFragDataIndexEXT: function (program_: GLuint; name: PGLchar): GLint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendEquationEXT: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBufferStorageEXT: procedure (target: GLenum; size: GLsizeiptr; data: Pointer; flags: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearTexImageEXT: procedure (texture: GLuint; level: GLint; format: GLenum; type_: GLenum; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearTexSubImageEXT: procedure (texture: GLuint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; format: GLenum; type_: GLenum; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClipControlEXT: procedure (origin: GLenum; depth: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyImageSubDataEXT: procedure (srcName: GLuint; srcTarget: GLenum; srcLevel: GLint; srcX: GLint; srcY: GLint; srcZ: GLint; dstName: GLuint; dstTarget: GLenum; dstLevel: GLint; dstX: GLint; dstY: GLint; dstZ: GLint; srcWidth: GLsizei; srcHeight: GLsizei; srcDepth: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glLabelObjectEXT: procedure (type_: GLenum; object_: GLuint; length: GLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetObjectLabelEXT: procedure (type_: GLenum; object_: GLuint; bufSize: GLsizei; length: PGLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glInsertEventMarkerEXT: procedure (length: GLsizei; marker: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPushGroupMarkerEXT: procedure (length: GLsizei; marker: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPopGroupMarkerEXT: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDiscardFramebufferEXT: procedure (target: GLenum; numAttachments: GLsizei; attachments: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenQueriesEXT: procedure (n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteQueriesEXT: procedure (n: GLsizei; ids: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsQueryEXT: function (id: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBeginQueryEXT: procedure (target: GLenum; id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndQueryEXT: procedure (target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glQueryCounterEXT: procedure (id: GLuint; target: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryivEXT: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryObjectivEXT: procedure (id: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryObjectuivEXT: procedure (id: GLuint; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryObjecti64vEXT: procedure (id: GLuint; pname: GLenum; params: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetQueryObjectui64vEXT: procedure (id: GLuint; pname: GLenum; params: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetInteger64vEXT: procedure (pname: GLenum; data: PGLint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawBuffersEXT: procedure (n: GLsizei; bufs: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEnableiEXT: procedure (target: GLenum; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDisableiEXT: procedure (target: GLenum; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendEquationiEXT: procedure (buf: GLuint; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendEquationSeparateiEXT: procedure (buf: GLuint; modeRGB: GLenum; modeAlpha: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendFunciEXT: procedure (buf: GLuint; src: GLenum; dst: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendFuncSeparateiEXT: procedure (buf: GLuint; srcRGB: GLenum; dstRGB: GLenum; srcAlpha: GLenum; dstAlpha: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorMaskiEXT: procedure (index: GLuint; r: GLboolean; g: GLboolean; b: GLboolean; a: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsEnablediEXT: function (target: GLenum; index: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElementsBaseVertexEXT: procedure (mode: GLenum; count: GLsizei; type_: GLenum; indices: Pointer; basevertex: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawRangeElementsBaseVertexEXT: procedure (mode: GLenum; start: GLuint; end_: GLuint; count: GLsizei; type_: GLenum; indices: Pointer; basevertex: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElementsInstancedBaseVertexEXT: procedure (mode: GLenum; count: GLsizei; type_: GLenum; indices: Pointer; instancecount: GLsizei; basevertex: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawElementsBaseVertexEXT: procedure (mode: GLenum; count: PGLsizei; type_: GLenum; indices: PPointer; drawcount: GLsizei; basevertex: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawArraysInstancedEXT: procedure (mode: GLenum; start: GLint; count: GLsizei; primcount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElementsInstancedEXT: procedure (mode: GLenum; count: GLsizei; type_: GLenum; indices: Pointer; primcount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawTransformFeedbackEXT: procedure (mode: GLenum; id: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawTransformFeedbackInstancedEXT: procedure (mode: GLenum; id: GLuint; instancecount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBufferStorageExternalEXT: procedure (target: GLenum; offset: GLintptr; size: GLsizeiptr; clientBuffer: GLeglClientBufferEXT; flags: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedBufferStorageExternalEXT: procedure (buffer: GLuint; offset: GLintptr; size: GLsizeiptr; clientBuffer: GLeglClientBufferEXT; flags: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFragmentShadingRatesEXT: procedure (samples: GLsizei; maxCount: GLsizei; count: PGLsizei; shadingRates: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShadingRateEXT: procedure (rate: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShadingRateCombinerOpsEXT: procedure (combinerOp0: GLenum; combinerOp1: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferShadingRateEXT: procedure (target: GLenum; attachment: GLenum; texture: GLuint; baseLayer: GLint; numLayers: GLsizei; texelWidth: GLsizei; texelHeight: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlitFramebufferLayersEXT: procedure (srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; mask: GLbitfield; filter: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlitFramebufferLayerEXT: procedure (srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; srcLayer: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; dstLayer: GLint; mask: GLbitfield; filter: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTextureEXT: procedure (target: GLenum; attachment: GLenum; texture: GLuint; level: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribDivisorEXT: procedure (index: GLuint; divisor: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapBufferRangeEXT: function (target: GLenum; offset: GLintptr; length: GLsizeiptr; access: GLbitfield): Pointer; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFlushMappedBufferRangeEXT: procedure (target: GLenum; offset: GLintptr; length: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUnsignedBytevEXT: procedure (pname: GLenum; data: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUnsignedBytei_vEXT: procedure (target: GLenum; index: GLuint; data: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteMemoryObjectsEXT: procedure (n: GLsizei; memoryObjects: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsMemoryObjectEXT: function (memoryObject: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateMemoryObjectsEXT: procedure (n: GLsizei; memoryObjects: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMemoryObjectParameterivEXT: procedure (memoryObject: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMemoryObjectParameterivEXT: procedure (memoryObject: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorageMem2DEXT: procedure (target: GLenum; levels: GLsizei; internalFormat: GLenum; width: GLsizei; height: GLsizei; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorageMem2DMultisampleEXT: procedure (target: GLenum; samples: GLsizei; internalFormat: GLenum; width: GLsizei; height: GLsizei; fixedSampleLocations: GLboolean; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorageMem3DEXT: procedure (target: GLenum; levels: GLsizei; internalFormat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorageMem3DMultisampleEXT: procedure (target: GLenum; samples: GLsizei; internalFormat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; fixedSampleLocations: GLboolean; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBufferStorageMemEXT: procedure (target: GLenum; size: GLsizeiptr; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorageMem2DEXT: procedure (texture: GLuint; levels: GLsizei; internalFormat: GLenum; width: GLsizei; height: GLsizei; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorageMem2DMultisampleEXT: procedure (texture: GLuint; samples: GLsizei; internalFormat: GLenum; width: GLsizei; height: GLsizei; fixedSampleLocations: GLboolean; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorageMem3DEXT: procedure (texture: GLuint; levels: GLsizei; internalFormat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorageMem3DMultisampleEXT: procedure (texture: GLuint; samples: GLsizei; internalFormat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; fixedSampleLocations: GLboolean; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedBufferStorageMemEXT: procedure (buffer: GLuint; size: GLsizeiptr; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorageMem1DEXT: procedure (target: GLenum; levels: GLsizei; internalFormat: GLenum; width: GLsizei; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorageMem1DEXT: procedure (texture: GLuint; levels: GLsizei; internalFormat: GLenum; width: GLsizei; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glImportMemoryFdEXT: procedure (memory: GLuint; size: GLuint64; handleType: GLenum; fd: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glImportMemoryWin32HandleEXT: procedure (memory: GLuint; size: GLuint64; handleType: GLenum; handle: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glImportMemoryWin32NameEXT: procedure (memory: GLuint; size: GLuint64; handleType: GLenum; name: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawArraysEXT: procedure (mode: GLenum; first: PGLint; count: PGLsizei; primcount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawElementsEXT: procedure (mode: GLenum; count: PGLsizei; type_: GLenum; indices: PPointer; primcount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawArraysIndirectEXT: procedure (mode: GLenum; indirect: Pointer; drawcount: GLsizei; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawElementsIndirectEXT: procedure (mode: GLenum; type_: GLenum; indirect: Pointer; drawcount: GLsizei; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRenderbufferStorageMultisampleEXT: procedure (target: GLenum; samples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTexture2DMultisampleEXT: procedure (target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint; samples: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReadBufferIndexedEXT: procedure (src: GLenum; index: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawBuffersIndexedEXT: procedure (n: GLint; location: PGLenum; indices: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetIntegeri_vEXT: procedure (target: GLenum; index: GLuint; data: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPolygonOffsetClampEXT: procedure (factor: GLfloat; units: GLfloat; clamp: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPrimitiveBoundingBoxEXT: procedure (minX: GLfloat; minY: GLfloat; minZ: GLfloat; minW: GLfloat; maxX: GLfloat; maxY: GLfloat; maxZ: GLfloat; maxW: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRasterSamplesEXT: procedure (samples: GLuint; fixedsamplelocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetGraphicsResetStatusEXT: function (): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReadnPixelsEXT: procedure (x: GLint; y: GLint; width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; bufSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnUniformfvEXT: procedure (program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnUniformivEXT: procedure (program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenSemaphoresEXT: procedure (n: GLsizei; semaphores: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteSemaphoresEXT: procedure (n: GLsizei; semaphores: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsSemaphoreEXT: function (semaphore: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSemaphoreParameterui64vEXT: procedure (semaphore: GLuint; pname: GLenum; params: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSemaphoreParameterui64vEXT: procedure (semaphore: GLuint; pname: GLenum; params: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWaitSemaphoreEXT: procedure (semaphore: GLuint; numBufferBarriers: GLuint; buffers: PGLuint; numTextureBarriers: GLuint; textures: PGLuint; srcLayouts: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSignalSemaphoreEXT: procedure (semaphore: GLuint; numBufferBarriers: GLuint; buffers: PGLuint; numTextureBarriers: GLuint; textures: PGLuint; dstLayouts: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glImportSemaphoreFdEXT: procedure (semaphore: GLuint; handleType: GLenum; fd: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glImportSemaphoreWin32HandleEXT: procedure (semaphore: GLuint; handleType: GLenum; handle: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glImportSemaphoreWin32NameEXT: procedure (semaphore: GLuint; handleType: GLenum; name: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUseShaderProgramEXT: procedure (type_: GLenum; program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glActiveProgramEXT: procedure (program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateShaderProgramEXT: function (type_: GLenum; string_: PGLchar): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glActiveShaderProgramEXT: procedure (pipeline: GLuint; program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindProgramPipelineEXT: procedure (pipeline: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateShaderProgramvEXT: function (type_: GLenum; count: GLsizei; strings: PPGLchar): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteProgramPipelinesEXT: procedure (n: GLsizei; pipelines: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenProgramPipelinesEXT: procedure (n: GLsizei; pipelines: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramPipelineInfoLogEXT: procedure (pipeline: GLuint; bufSize: GLsizei; length: PGLsizei; infoLog: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramPipelineivEXT: procedure (pipeline: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsProgramPipelineEXT: function (pipeline: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramParameteriEXT: procedure (program_: GLuint; pname: GLenum; value: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1fEXT: procedure (program_: GLuint; location: GLint; v0: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1iEXT: procedure (program_: GLuint; location: GLint; v0: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1ivEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2fEXT: procedure (program_: GLuint; location: GLint; v0: GLfloat; v1: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2iEXT: procedure (program_: GLuint; location: GLint; v0: GLint; v1: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2ivEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3fEXT: procedure (program_: GLuint; location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3iEXT: procedure (program_: GLuint; location: GLint; v0: GLint; v1: GLint; v2: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3ivEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4fEXT: procedure (program_: GLuint; location: GLint; v0: GLfloat; v1: GLfloat; v2: GLfloat; v3: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4iEXT: procedure (program_: GLuint; location: GLint; v0: GLint; v1: GLint; v2: GLint; v3: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4ivEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix2fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix3fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix4fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUseProgramStagesEXT: procedure (pipeline: GLuint; stages: GLbitfield; program_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glValidateProgramPipelineEXT: procedure (pipeline: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1uiEXT: procedure (program_: GLuint; location: GLint; v0: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2uiEXT: procedure (program_: GLuint; location: GLint; v0: GLuint; v1: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3uiEXT: procedure (program_: GLuint; location: GLint; v0: GLuint; v1: GLuint; v2: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4uiEXT: procedure (program_: GLuint; location: GLint; v0: GLuint; v1: GLuint; v2: GLuint; v3: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1uivEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2uivEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3uivEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4uivEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix2x3fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix3x2fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix2x4fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix4x2fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix3x4fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformMatrix4x3fvEXT: procedure (program_: GLuint; location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferFetchBarrierEXT: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferPixelLocalStorageSizeEXT: procedure (target: GLuint; size: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFramebufferPixelLocalStorageSizeEXT: function (target: GLuint): GLsizei; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glClearPixelLocalStorageuiEXT: procedure (offset: GLsizei; n: GLsizei; values: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexPageCommitmentEXT: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; commit: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPatchParameteriEXT: procedure (pname: GLenum; value: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexParameterIivEXT: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexParameterIuivEXT: procedure (target: GLenum; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexParameterIivEXT: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexParameterIuivEXT: procedure (target: GLenum; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSamplerParameterIivEXT: procedure (sampler: GLuint; pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSamplerParameterIuivEXT: procedure (sampler: GLuint; pname: GLenum; param: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSamplerParameterIivEXT: procedure (sampler: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSamplerParameterIuivEXT: procedure (sampler: GLuint; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexBufferEXT: procedure (target: GLenum; internalformat: GLenum; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexBufferRangeEXT: procedure (target: GLenum; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorage1DEXT: procedure (target: GLenum; levels: GLsizei; internalformat: GLenum; width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorage2DEXT: procedure (target: GLenum; levels: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorage3DEXT: procedure (target: GLenum; levels: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorage1DEXT: procedure (texture: GLuint; target: GLenum; levels: GLsizei; internalformat: GLenum; width: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorage2DEXT: procedure (texture: GLuint; target: GLenum; levels: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureStorage3DEXT: procedure (texture: GLuint; target: GLenum; levels: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorageAttribs2DEXT: procedure (target: GLenum; levels: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei; attrib_list: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorageAttribs3DEXT: procedure (target: GLenum; levels: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; attrib_list: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureViewEXT: procedure (texture: GLuint; target: GLenum; origtexture: GLuint; internalformat: GLenum; minlevel: GLuint; numlevels: GLuint; minlayer: GLuint; numlayers: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glAcquireKeyedMutexWin32EXT: function (memory: GLuint; key: GLuint64; timeout: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReleaseKeyedMutexWin32EXT: function (memory: GLuint; key: GLuint64): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWindowRectanglesEXT: procedure (mode: GLenum; count: GLsizei; box: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureHandleIMG: function (texture: GLuint): GLuint64; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureSamplerHandleIMG: function (texture: GLuint; sampler: GLuint): GLuint64; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformHandleui64IMG: procedure (location: GLint; value: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformHandleui64vIMG: procedure (location: GLint; count: GLsizei; value: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformHandleui64IMG: procedure (program_: GLuint; location: GLint; value: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformHandleui64vIMG: procedure (program_: GLuint; location: GLint; count: GLsizei; values: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTexture2DDownsampleIMG: procedure (target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint; xscale: GLint; yscale: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTextureLayerDownsampleIMG: procedure (target: GLenum; attachment: GLenum; texture: GLuint; level: GLint; layer: GLint; xscale: GLint; yscale: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRenderbufferStorageMultisampleIMG: procedure (target: GLenum; samples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTexture2DMultisampleIMG: procedure (target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint; samples: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glApplyFramebufferAttachmentCMAAINTEL: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBeginPerfQueryINTEL: procedure (queryHandle: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreatePerfQueryINTEL: procedure (queryId: GLuint; queryHandle: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeletePerfQueryINTEL: procedure (queryHandle: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndPerfQueryINTEL: procedure (queryHandle: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFirstPerfQueryIdINTEL: procedure (queryId: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetNextPerfQueryIdINTEL: procedure (queryId: GLuint; nextQueryId: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPerfCounterInfoINTEL: procedure (queryId: GLuint; counterId: GLuint; counterNameLength: GLuint; counterName: PGLchar; counterDescLength: GLuint; counterDesc: PGLchar; counterOffset: PGLuint; counterDataSize: PGLuint; counterTypeEnum: PGLuint; counterDataTypeEnum: PGLuint; rawCounterMaxValue: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPerfQueryDataINTEL: procedure (queryHandle: GLuint; flags: GLuint; dataSize: GLsizei; data: Pointer; bytesWritten: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPerfQueryIdByNameINTEL: procedure (queryName: PGLchar; queryId: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPerfQueryInfoINTEL: procedure (queryId: GLuint; queryNameLength: GLuint; queryName: PGLchar; dataSize: PGLuint; noCounters: PGLuint; noInstances: PGLuint; capsMask: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendBarrierKHR: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDebugMessageControl: procedure (source: GLenum; type_: GLenum; severity: GLenum; count: GLsizei; ids: PGLuint; enabled: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDebugMessageInsert: procedure (source: GLenum; type_: GLenum; id: GLuint; severity: GLenum; length: GLsizei; buf: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDebugMessageCallback: procedure (callback: GLDEBUGPROC; userParam: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetDebugMessageLog: function (count: GLuint; bufSize: GLsizei; sources: PGLenum; types: PGLenum; ids: PGLuint; severities: PGLenum; lengths: PGLsizei; messageLog: PGLchar): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPushDebugGroup: procedure (source: GLenum; id: GLuint; length: GLsizei; message: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPopDebugGroup: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glObjectLabel: procedure (identifier: GLenum; name: GLuint; length: GLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetObjectLabel: procedure (identifier: GLenum; name: GLuint; bufSize: GLsizei; length: PGLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glObjectPtrLabel: procedure (ptr: Pointer; length: GLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetObjectPtrLabel: procedure (ptr: Pointer; bufSize: GLsizei; length: PGLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPointerv: procedure (pname: GLenum; params: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDebugMessageControlKHR: procedure (source: GLenum; type_: GLenum; severity: GLenum; count: GLsizei; ids: PGLuint; enabled: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDebugMessageInsertKHR: procedure (source: GLenum; type_: GLenum; id: GLuint; severity: GLenum; length: GLsizei; buf: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDebugMessageCallbackKHR: procedure (callback: GLDEBUGPROCKHR; userParam: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetDebugMessageLogKHR: function (count: GLuint; bufSize: GLsizei; sources: PGLenum; types: PGLenum; ids: PGLuint; severities: PGLenum; lengths: PGLsizei; messageLog: PGLchar): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPushDebugGroupKHR: procedure (source: GLenum; id: GLuint; length: GLsizei; message: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPopDebugGroupKHR: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glObjectLabelKHR: procedure (identifier: GLenum; name: GLuint; length: GLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetObjectLabelKHR: procedure (identifier: GLenum; name: GLuint; bufSize: GLsizei; length: PGLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glObjectPtrLabelKHR: procedure (ptr: Pointer; length: GLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetObjectPtrLabelKHR: procedure (ptr: Pointer; bufSize: GLsizei; length: PGLsizei; label_: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPointervKHR: procedure (pname: GLenum; params: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMaxShaderCompilerThreadsKHR: procedure (count: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetGraphicsResetStatus: function (): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReadnPixels: procedure (x: GLint; y: GLint; width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; bufSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnUniformfv: procedure (program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnUniformiv: procedure (program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnUniformuiv: procedure (program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetGraphicsResetStatusKHR: function (): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReadnPixelsKHR: procedure (x: GLint; y: GLint; width: GLsizei; height: GLsizei; format: GLenum; type_: GLenum; bufSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnUniformfvKHR: procedure (program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnUniformivKHR: procedure (program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetnUniformuivKHR: procedure (program_: GLuint; location: GLint; bufSize: GLsizei; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferParameteriMESA: procedure (target: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFramebufferParameterivMESA: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureHandleNV: function (texture: GLuint): GLuint64; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTextureSamplerHandleNV: function (texture: GLuint; sampler: GLuint): GLuint64; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMakeTextureHandleResidentNV: procedure (handle: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMakeTextureHandleNonResidentNV: procedure (handle: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetImageHandleNV: function (texture: GLuint; level: GLint; layered: GLboolean; layer: GLint; format: GLenum): GLuint64; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMakeImageHandleResidentNV: procedure (handle: GLuint64; access: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMakeImageHandleNonResidentNV: procedure (handle: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformHandleui64NV: procedure (location: GLint; value: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformHandleui64vNV: procedure (location: GLint; count: GLsizei; value: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformHandleui64NV: procedure (program_: GLuint; location: GLint; value: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniformHandleui64vNV: procedure (program_: GLuint; location: GLint; count: GLsizei; values: PGLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsTextureHandleResidentNV: function (handle: GLuint64): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsImageHandleResidentNV: function (handle: GLuint64): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendParameteriNV: procedure (pname: GLenum; value: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendBarrierNV: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glViewportPositionWScaleNV: procedure (index: GLuint; xcoeff: GLfloat; ycoeff: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBeginConditionalRenderNV: procedure (id: GLuint; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndConditionalRenderNV: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSubpixelPrecisionBiasNV: procedure (xbits: GLuint; ybits: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glConservativeRasterParameteriNV: procedure (pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyBufferSubDataNV: procedure (readTarget: GLenum; writeTarget: GLenum; readOffset: GLintptr; writeOffset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCoverageMaskNV: procedure (mask: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCoverageOperationNV: procedure (operation: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawBuffersNV: procedure (n: GLsizei; bufs: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawArraysInstancedNV: procedure (mode: GLenum; first: GLint; count: GLsizei; primcount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElementsInstancedNV: procedure (mode: GLenum; count: GLsizei; type_: GLenum; indices: Pointer; primcount: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawVkImageNV: procedure (vkImage: GLuint64; sampler: GLuint; x0: GLfloat; y0: GLfloat; x1: GLfloat; y1: GLfloat; z: GLfloat; s0: GLfloat; t0: GLfloat; s1: GLfloat; t1: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetVkProcAddrNV: function (name: PGLchar): GLVULKANPROCNV; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWaitVkSemaphoreNV: procedure (vkSemaphore: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSignalVkSemaphoreNV: procedure (vkSemaphore: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSignalVkFenceNV: procedure (vkFence: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteFencesNV: procedure (n: GLsizei; fences: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenFencesNV: procedure (n: GLsizei; fences: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsFenceNV: function (fence: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTestFenceNV: function (fence: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFenceivNV: procedure (fence: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFinishFenceNV: procedure (fence: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSetFenceNV: procedure (fence: GLuint; condition: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFragmentCoverageColorNV: procedure (color: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlitFramebufferNV: procedure (srcX0: GLint; srcY0: GLint; srcX1: GLint; srcY1: GLint; dstX0: GLint; dstY0: GLint; dstX1: GLint; dstY1: GLint; mask: GLbitfield; filter: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCoverageModulationTableNV: procedure (n: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetCoverageModulationTableNV: procedure (bufSize: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCoverageModulationNV: procedure (components: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glRenderbufferStorageMultisampleNV: procedure (target: GLenum; samples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1i64NV: procedure (location: GLint; x: GLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2i64NV: procedure (location: GLint; x: GLint64EXT; y: GLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3i64NV: procedure (location: GLint; x: GLint64EXT; y: GLint64EXT; z: GLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4i64NV: procedure (location: GLint; x: GLint64EXT; y: GLint64EXT; z: GLint64EXT; w: GLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1i64vNV: procedure (location: GLint; count: GLsizei; value: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2i64vNV: procedure (location: GLint; count: GLsizei; value: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3i64vNV: procedure (location: GLint; count: GLsizei; value: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4i64vNV: procedure (location: GLint; count: GLsizei; value: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1ui64NV: procedure (location: GLint; x: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2ui64NV: procedure (location: GLint; x: GLuint64EXT; y: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3ui64NV: procedure (location: GLint; x: GLuint64EXT; y: GLuint64EXT; z: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4ui64NV: procedure (location: GLint; x: GLuint64EXT; y: GLuint64EXT; z: GLuint64EXT; w: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform1ui64vNV: procedure (location: GLint; count: GLsizei; value: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform2ui64vNV: procedure (location: GLint; count: GLsizei; value: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform3ui64vNV: procedure (location: GLint; count: GLsizei; value: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniform4ui64vNV: procedure (location: GLint; count: GLsizei; value: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetUniformi64vNV: procedure (program_: GLuint; location: GLint; params: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1i64NV: procedure (program_: GLuint; location: GLint; x: GLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2i64NV: procedure (program_: GLuint; location: GLint; x: GLint64EXT; y: GLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3i64NV: procedure (program_: GLuint; location: GLint; x: GLint64EXT; y: GLint64EXT; z: GLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4i64NV: procedure (program_: GLuint; location: GLint; x: GLint64EXT; y: GLint64EXT; z: GLint64EXT; w: GLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1i64vNV: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2i64vNV: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3i64vNV: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4i64vNV: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1ui64NV: procedure (program_: GLuint; location: GLint; x: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2ui64NV: procedure (program_: GLuint; location: GLint; x: GLuint64EXT; y: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3ui64NV: procedure (program_: GLuint; location: GLint; x: GLuint64EXT; y: GLuint64EXT; z: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4ui64NV: procedure (program_: GLuint; location: GLint; x: GLuint64EXT; y: GLuint64EXT; z: GLuint64EXT; w: GLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform1ui64vNV: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform2ui64vNV: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform3ui64vNV: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramUniform4ui64vNV: procedure (program_: GLuint; location: GLint; count: GLsizei; value: PGLuint64EXT); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glVertexAttribDivisorNV: procedure (index: GLuint; divisor: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetInternalformatSampleivNV: procedure (target: GLenum; internalformat: GLenum; samples: GLsizei; pname: GLenum; count: GLsizei; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetMemoryObjectDetachedResourcesuivNV: procedure (memory: GLuint; pname: GLenum; first: GLint; count: GLsizei; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glResetMemoryObjectParameterNV: procedure (memory: GLuint; pname: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexAttachMemoryNV: procedure (target: GLenum; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBufferAttachMemoryNV: procedure (target: GLenum; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureAttachMemoryNV: procedure (texture: GLuint; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedBufferAttachMemoryNV: procedure (buffer: GLuint; memory: GLuint; offset: GLuint64); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBufferPageCommitmentMemNV: procedure (target: GLenum; offset: GLintptr; size: GLsizeiptr; memory: GLuint; memOffset: GLuint64; commit: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexPageCommitmentMemNV: procedure (target: GLenum; layer: GLint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; memory: GLuint; offset: GLuint64; commit: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedBufferPageCommitmentMemNV: procedure (buffer: GLuint; offset: GLintptr; size: GLsizeiptr; memory: GLuint; memOffset: GLuint64; commit: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexturePageCommitmentMemNV: procedure (texture: GLuint; layer: GLint; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; memory: GLuint; offset: GLuint64; commit: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawMeshTasksNV: procedure (first: GLuint; count: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawMeshTasksIndirectNV: procedure (indirect: GLintptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawMeshTasksIndirectNV: procedure (indirect: GLintptr; drawcount: GLsizei; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMultiDrawMeshTasksIndirectCountNV: procedure (indirect: GLintptr; drawcount: GLintptr; maxdrawcount: GLsizei; stride: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix2x3fvNV: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix3x2fvNV: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix2x4fvNV: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix4x2fvNV: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix3x4fvNV: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUniformMatrix4x3fvNV: procedure (location: GLint; count: GLsizei; transpose: GLboolean; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenPathsNV: function (range: GLsizei): GLuint; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeletePathsNV: procedure (path: GLuint; range: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsPathNV: function (path: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathCommandsNV: procedure (path: GLuint; numCommands: GLsizei; commands: PGLubyte; numCoords: GLsizei; coordType: GLenum; coords: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathCoordsNV: procedure (path: GLuint; numCoords: GLsizei; coordType: GLenum; coords: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathSubCommandsNV: procedure (path: GLuint; commandStart: GLsizei; commandsToDelete: GLsizei; numCommands: GLsizei; commands: PGLubyte; numCoords: GLsizei; coordType: GLenum; coords: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathSubCoordsNV: procedure (path: GLuint; coordStart: GLsizei; numCoords: GLsizei; coordType: GLenum; coords: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathStringNV: procedure (path: GLuint; format: GLenum; length: GLsizei; pathString: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathGlyphsNV: procedure (firstPathName: GLuint; fontTarget: GLenum; fontName: Pointer; fontStyle: GLbitfield; numGlyphs: GLsizei; type_: GLenum; charcodes: Pointer; handleMissingGlyphs: GLenum; pathParameterTemplate: GLuint; emScale: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathGlyphRangeNV: procedure (firstPathName: GLuint; fontTarget: GLenum; fontName: Pointer; fontStyle: GLbitfield; firstGlyph: GLuint; numGlyphs: GLsizei; handleMissingGlyphs: GLenum; pathParameterTemplate: GLuint; emScale: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glWeightPathsNV: procedure (resultPath: GLuint; numPaths: GLsizei; paths: PGLuint; weights: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyPathNV: procedure (resultPath: GLuint; srcPath: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glInterpolatePathsNV: procedure (resultPath: GLuint; pathA: GLuint; pathB: GLuint; weight: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTransformPathNV: procedure (resultPath: GLuint; srcPath: GLuint; transformType: GLenum; transformValues: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathParameterivNV: procedure (path: GLuint; pname: GLenum; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathParameteriNV: procedure (path: GLuint; pname: GLenum; value: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathParameterfvNV: procedure (path: GLuint; pname: GLenum; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathParameterfNV: procedure (path: GLuint; pname: GLenum; value: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathDashArrayNV: procedure (path: GLuint; dashCount: GLsizei; dashArray: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathStencilFuncNV: procedure (func: GLenum; ref: GLint; mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathStencilDepthOffsetNV: procedure (factor: GLfloat; units: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilFillPathNV: procedure (path: GLuint; fillMode: GLenum; mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilStrokePathNV: procedure (path: GLuint; reference: GLint; mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilFillPathInstancedNV: procedure (numPaths: GLsizei; pathNameType: GLenum; paths: Pointer; pathBase: GLuint; fillMode: GLenum; mask: GLuint; transformType: GLenum; transformValues: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilStrokePathInstancedNV: procedure (numPaths: GLsizei; pathNameType: GLenum; paths: Pointer; pathBase: GLuint; reference: GLint; mask: GLuint; transformType: GLenum; transformValues: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathCoverDepthFuncNV: procedure (func: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCoverFillPathNV: procedure (path: GLuint; coverMode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCoverStrokePathNV: procedure (path: GLuint; coverMode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCoverFillPathInstancedNV: procedure (numPaths: GLsizei; pathNameType: GLenum; paths: Pointer; pathBase: GLuint; coverMode: GLenum; transformType: GLenum; transformValues: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCoverStrokePathInstancedNV: procedure (numPaths: GLsizei; pathNameType: GLenum; paths: Pointer; pathBase: GLuint; coverMode: GLenum; transformType: GLenum; transformValues: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathParameterivNV: procedure (path: GLuint; pname: GLenum; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathParameterfvNV: procedure (path: GLuint; pname: GLenum; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathCommandsNV: procedure (path: GLuint; commands: PGLubyte); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathCoordsNV: procedure (path: GLuint; coords: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathDashArrayNV: procedure (path: GLuint; dashArray: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathMetricsNV: procedure (metricQueryMask: GLbitfield; numPaths: GLsizei; pathNameType: GLenum; paths: Pointer; pathBase: GLuint; stride: GLsizei; metrics: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathMetricRangeNV: procedure (metricQueryMask: GLbitfield; firstPathName: GLuint; numPaths: GLsizei; stride: GLsizei; metrics: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathSpacingNV: procedure (pathListMode: GLenum; numPaths: GLsizei; pathNameType: GLenum; paths: Pointer; pathBase: GLuint; advanceScale: GLfloat; kerningScale: GLfloat; transformType: GLenum; returnedSpacing: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsPointInFillPathNV: function (path: GLuint; mask: GLuint; x: GLfloat; y: GLfloat): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsPointInStrokePathNV: function (path: GLuint; x: GLfloat; y: GLfloat): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathLengthNV: function (path: GLuint; startSegment: GLsizei; numSegments: GLsizei): GLfloat; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPointAlongPathNV: function (path: GLuint; startSegment: GLsizei; numSegments: GLsizei; distance: GLfloat; x: PGLfloat; y: PGLfloat; tangentX: PGLfloat; tangentY: PGLfloat): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixLoad3x2fNV: procedure (matrixMode: GLenum; m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixLoad3x3fNV: procedure (matrixMode: GLenum; m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixLoadTranspose3x3fNV: procedure (matrixMode: GLenum; m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixMult3x2fNV: procedure (matrixMode: GLenum; m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixMult3x3fNV: procedure (matrixMode: GLenum; m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixMultTranspose3x3fNV: procedure (matrixMode: GLenum; m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilThenCoverFillPathNV: procedure (path: GLuint; fillMode: GLenum; mask: GLuint; coverMode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilThenCoverStrokePathNV: procedure (path: GLuint; reference: GLint; mask: GLuint; coverMode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilThenCoverFillPathInstancedNV: procedure (numPaths: GLsizei; pathNameType: GLenum; paths: Pointer; pathBase: GLuint; fillMode: GLenum; mask: GLuint; coverMode: GLenum; transformType: GLenum; transformValues: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStencilThenCoverStrokePathInstancedNV: procedure (numPaths: GLsizei; pathNameType: GLenum; paths: Pointer; pathBase: GLuint; reference: GLint; mask: GLuint; coverMode: GLenum; transformType: GLenum; transformValues: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathGlyphIndexRangeNV: function (fontTarget: GLenum; fontName: Pointer; fontStyle: GLbitfield; pathParameterTemplate: GLuint; emScale: GLfloat; baseAndCount: PGLuint): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathGlyphIndexArrayNV: function (firstPathName: GLuint; fontTarget: GLenum; fontName: Pointer; fontStyle: GLbitfield; firstGlyphIndex: GLuint; numGlyphs: GLsizei; pathParameterTemplate: GLuint; emScale: GLfloat): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathMemoryGlyphIndexArrayNV: function (firstPathName: GLuint; fontTarget: GLenum; fontSize: GLsizeiptr; fontData: Pointer; faceIndex: GLsizei; firstGlyphIndex: GLuint; numGlyphs: GLsizei; pathParameterTemplate: GLuint; emScale: GLfloat): GLenum; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramPathFragmentInputGenNV: procedure (program_: GLuint; location: GLint; genMode: GLenum; components: GLint; coeffs: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramResourcefvNV: procedure (program_: GLuint; programInterface: GLenum; index: GLuint; propCount: GLsizei; props: PGLenum; count: GLsizei; length: PGLsizei; params: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathColorGenNV: procedure (color: GLenum; genMode: GLenum; colorFormat: GLenum; coeffs: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathTexGenNV: procedure (texCoordSet: GLenum; genMode: GLenum; components: GLint; coeffs: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPathFogGenNV: procedure (genMode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathColorGenivNV: procedure (color: GLenum; pname: GLenum; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathColorGenfvNV: procedure (color: GLenum; pname: GLenum; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathTexGenivNV: procedure (texCoordSet: GLenum; pname: GLenum; value: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetPathTexGenfvNV: procedure (texCoordSet: GLenum; pname: GLenum; value: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixFrustumEXT: procedure (mode: GLenum; left: GLdouble; right: GLdouble; bottom: GLdouble; top: GLdouble; zNear: GLdouble; zFar: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixLoadIdentityEXT: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixLoadTransposefEXT: procedure (mode: GLenum; m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixLoadTransposedEXT: procedure (mode: GLenum; m: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixLoadfEXT: procedure (mode: GLenum; m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixLoaddEXT: procedure (mode: GLenum; m: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixMultTransposefEXT: procedure (mode: GLenum; m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixMultTransposedEXT: procedure (mode: GLenum; m: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixMultfEXT: procedure (mode: GLenum; m: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixMultdEXT: procedure (mode: GLenum; m: PGLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixOrthoEXT: procedure (mode: GLenum; left: GLdouble; right: GLdouble; bottom: GLdouble; top: GLdouble; zNear: GLdouble; zFar: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixPopEXT: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixPushEXT: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixRotatefEXT: procedure (mode: GLenum; angle: GLfloat; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixRotatedEXT: procedure (mode: GLenum; angle: GLdouble; x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixScalefEXT: procedure (mode: GLenum; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixScaledEXT: procedure (mode: GLenum; x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixTranslatefEXT: procedure (mode: GLenum; x: GLfloat; y: GLfloat; z: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMatrixTranslatedEXT: procedure (mode: GLenum; x: GLdouble; y: GLdouble; z: GLdouble); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPolygonModeNV: procedure (face: GLenum; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glReadBufferNV: procedure (mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferSampleLocationsfvNV: procedure (target: GLenum; start: GLuint; count: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferSampleLocationsfvNV: procedure (framebuffer: GLuint; start: GLuint; count: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glResolveDepthValuesNV: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glScissorExclusiveNV: procedure (x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glScissorExclusiveArrayvNV: procedure (first: GLuint; count: GLsizei; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindShadingRateImageNV: procedure (texture: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetShadingRateImagePaletteNV: procedure (viewport: GLuint; entry: GLuint; rate: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetShadingRateSampleLocationivNV: procedure (rate: GLenum; samples: GLuint; index: GLuint; location: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShadingRateImageBarrierNV: procedure (synchronize: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShadingRateImagePaletteNV: procedure (viewport: GLuint; first: GLuint; count: GLsizei; rates: PGLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShadingRateSampleOrderNV: procedure (order: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShadingRateSampleOrderCustomNV: procedure (rate: GLenum; samples: GLuint; locations: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCreateSemaphoresNV: procedure (n: GLsizei; semaphores: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSemaphoreParameterivNV: procedure (semaphore: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSemaphoreParameterivNV: procedure (semaphore: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glViewportArrayvNV: procedure (first: GLuint; count: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glViewportIndexedfNV: procedure (index: GLuint; x: GLfloat; y: GLfloat; w: GLfloat; h: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glViewportIndexedfvNV: procedure (index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glScissorArrayvNV: procedure (first: GLuint; count: GLsizei; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glScissorIndexedNV: procedure (index: GLuint; left: GLint; bottom: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glScissorIndexedvNV: procedure (index: GLuint; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDepthRangeArrayfvNV: procedure (first: GLuint; count: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDepthRangeIndexedfNV: procedure (index: GLuint; n: GLfloat; f: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFloati_vNV: procedure (target: GLenum; index: GLuint; data: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEnableiNV: procedure (target: GLenum; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDisableiNV: procedure (target: GLenum; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsEnablediNV: function (target: GLenum; index: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glViewportSwizzleNV: procedure (index: GLuint; swizzlex: GLenum; swizzley: GLenum; swizzlez: GLenum; swizzlew: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEGLImageTargetTexture2DOES: procedure (target: GLenum; image: GLeglImageOES); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEGLImageTargetRenderbufferStorageOES: procedure (target: GLenum; image: GLeglImageOES); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyImageSubDataOES: procedure (srcName: GLuint; srcTarget: GLenum; srcLevel: GLint; srcX: GLint; srcY: GLint; srcZ: GLint; dstName: GLuint; dstTarget: GLenum; dstLevel: GLint; dstX: GLint; dstY: GLint; dstZ: GLint; srcWidth: GLsizei; srcHeight: GLsizei; srcDepth: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEnableiOES: procedure (target: GLenum; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDisableiOES: procedure (target: GLenum; index: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendEquationiOES: procedure (buf: GLuint; mode: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendEquationSeparateiOES: procedure (buf: GLuint; modeRGB: GLenum; modeAlpha: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendFunciOES: procedure (buf: GLuint; src: GLenum; dst: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBlendFuncSeparateiOES: procedure (buf: GLuint; srcRGB: GLenum; dstRGB: GLenum; srcAlpha: GLenum; dstAlpha: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glColorMaskiOES: procedure (index: GLuint; r: GLboolean; g: GLboolean; b: GLboolean; a: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsEnablediOES: function (target: GLenum; index: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElementsBaseVertexOES: procedure (mode: GLenum; count: GLsizei; type_: GLenum; indices: Pointer; basevertex: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawRangeElementsBaseVertexOES: procedure (mode: GLenum; start: GLuint; end_: GLuint; count: GLsizei; type_: GLenum; indices: Pointer; basevertex: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDrawElementsInstancedBaseVertexOES: procedure (mode: GLenum; count: GLsizei; type_: GLenum; indices: Pointer; instancecount: GLsizei; basevertex: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTextureOES: procedure (target: GLenum; attachment: GLenum; texture: GLuint; level: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetProgramBinaryOES: procedure (program_: GLuint; bufSize: GLsizei; length: PGLsizei; binaryFormat: PGLenum; binary: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glProgramBinaryOES: procedure (program_: GLuint; binaryFormat: GLenum; binary: Pointer; length: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMapBufferOES: function (target: GLenum; access: GLenum): Pointer; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glUnmapBufferOES: function (target: GLenum): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetBufferPointervOES: procedure (target: GLenum; pname: GLenum; params: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPrimitiveBoundingBoxOES: procedure (minX: GLfloat; minY: GLfloat; minZ: GLfloat; minW: GLfloat; maxX: GLfloat; maxY: GLfloat; maxZ: GLfloat; maxW: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glMinSampleShadingOES: procedure (value: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glPatchParameteriOES: procedure (pname: GLenum; value: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexImage3DOES: procedure (target: GLenum; level: GLint; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; border: GLint; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexSubImage3DOES: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; format: GLenum; type_: GLenum; pixels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCopyTexSubImage3DOES: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; x: GLint; y: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTexImage3DOES: procedure (target: GLenum; level: GLint; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; border: GLint; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glCompressedTexSubImage3DOES: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; format: GLenum; imageSize: GLsizei; data: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTexture3DOES: procedure (target: GLenum; attachment: GLenum; textarget: GLenum; texture: GLuint; level: GLint; zoffset: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexParameterIivOES: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexParameterIuivOES: procedure (target: GLenum; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexParameterIivOES: procedure (target: GLenum; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetTexParameterIuivOES: procedure (target: GLenum; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSamplerParameterIivOES: procedure (sampler: GLuint; pname: GLenum; param: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glSamplerParameterIuivOES: procedure (sampler: GLuint; pname: GLenum; param: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSamplerParameterIivOES: procedure (sampler: GLuint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetSamplerParameterIuivOES: procedure (sampler: GLuint; pname: GLenum; params: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexBufferOES: procedure (target: GLenum; internalformat: GLenum; buffer: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexBufferRangeOES: procedure (target: GLenum; internalformat: GLenum; buffer: GLuint; offset: GLintptr; size: GLsizeiptr); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexStorage3DMultisampleOES: procedure (target: GLenum; samples: GLsizei; internalformat: GLenum; width: GLsizei; height: GLsizei; depth: GLsizei; fixedsamplelocations: GLboolean); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureViewOES: procedure (texture: GLuint; target: GLenum; origtexture: GLuint; internalformat: GLenum; minlevel: GLuint; numlevels: GLuint; minlayer: GLuint; numlayers: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glBindVertexArrayOES: procedure (array_: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDeleteVertexArraysOES: procedure (n: GLsizei; arrays: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGenVertexArraysOES: procedure (n: GLsizei; arrays: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glIsVertexArrayOES: function (array_: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glViewportArrayvOES: procedure (first: GLuint; count: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glViewportIndexedfOES: procedure (index: GLuint; x: GLfloat; y: GLfloat; w: GLfloat; h: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glViewportIndexedfvOES: procedure (index: GLuint; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glScissorArrayvOES: procedure (first: GLuint; count: GLsizei; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glScissorIndexedOES: procedure (index: GLuint; left: GLint; bottom: GLint; width: GLsizei; height: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glScissorIndexedvOES: procedure (index: GLuint; v: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDepthRangeArrayfvOES: procedure (first: GLuint; count: GLsizei; v: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDepthRangeIndexedfOES: procedure (index: GLuint; n: GLfloat; f: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetFloati_vOES: procedure (target: GLenum; index: GLuint; data: PGLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTextureMultiviewOVR: procedure (target: GLenum; attachment: GLenum; texture: GLuint; level: GLint; baseViewIndex: GLint; numViews: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glNamedFramebufferTextureMultiviewOVR: procedure (framebuffer: GLuint; attachment: GLenum; texture: GLuint; level: GLint; baseViewIndex: GLint; numViews: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferTextureMultisampleMultiviewOVR: procedure (target: GLenum; attachment: GLenum; texture: GLuint; level: GLint; samples: GLsizei; baseViewIndex: GLint; numViews: GLsizei); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glAlphaFuncQCOM: procedure (func: GLenum; ref: GLclampf); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetDriverControlsQCOM: procedure (num: PGLint; size: GLsizei; driverControls: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glGetDriverControlStringQCOM: procedure (driverControl: GLuint; bufSize: GLsizei; length: PGLsizei; driverControlString: PGLchar); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEnableDriverControlQCOM: procedure (driverControl: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glDisableDriverControlQCOM: procedure (driverControl: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glExtGetTexturesQCOM: procedure (textures: PGLuint; maxTextures: GLint; numTextures: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glExtGetBuffersQCOM: procedure (buffers: PGLuint; maxBuffers: GLint; numBuffers: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glExtGetRenderbuffersQCOM: procedure (renderbuffers: PGLuint; maxRenderbuffers: GLint; numRenderbuffers: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glExtGetFramebuffersQCOM: procedure (framebuffers: PGLuint; maxFramebuffers: GLint; numFramebuffers: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glExtGetTexLevelParameterivQCOM: procedure (texture: GLuint; face: GLenum; level: GLint; pname: GLenum; params: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glExtTexObjectStateOverrideiQCOM: procedure (target: GLenum; pname: GLenum; param: GLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glExtGetTexSubImageQCOM: procedure (target: GLenum; level: GLint; xoffset: GLint; yoffset: GLint; zoffset: GLint; width: GLsizei; height: GLsizei; depth: GLsizei; format: GLenum; type_: GLenum; texels: Pointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glExtGetBufferPointervQCOM: procedure (target: GLenum; params: PPointer); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glExtGetShadersQCOM: procedure (shaders: PGLuint; maxShaders: GLint; numShaders: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glExtGetProgramsQCOM: procedure (programs: PGLuint; maxPrograms: GLint; numPrograms: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glExtIsProgramBinaryQCOM: function (program_: GLuint): GLboolean; {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glExtGetProgramBinarySourceQCOM: procedure (program_: GLuint; shadertype: GLenum; source: PGLchar; length: PGLint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glExtrapolateTex2DQCOM: procedure (src1: GLuint; src2: GLuint; output: GLuint; scaleFactor: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferFoveationConfigQCOM: procedure (framebuffer: GLuint; numLayers: GLuint; focalPointsPerLayer: GLuint; requestedFeatures: GLuint; providedFeatures: PGLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferFoveationParametersQCOM: procedure (framebuffer: GLuint; layer: GLuint; focalPoint: GLuint; focalX: GLfloat; focalY: GLfloat; gainX: GLfloat; gainY: GLfloat; foveaArea: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexEstimateMotionQCOM: procedure (ref: GLuint; target: GLuint; output: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTexEstimateMotionRegionsQCOM: procedure (ref: GLuint; target: GLuint; output: GLuint; mask: GLuint); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glFramebufferFetchBarrierQCOM: procedure (); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glShadingRateQCOM: procedure (rate: GLenum); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glTextureFoveationParametersQCOM: procedure (texture: GLuint; layer: GLuint; focalPoint: GLuint; focalX: GLfloat; focalY: GLfloat; gainX: GLfloat; gainY: GLfloat; foveaArea: GLfloat); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glStartTilingQCOM: procedure (x: GLuint; y: GLuint; width: GLuint; height: GLuint; preserveMask: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}
  glEndTilingQCOM: procedure (preserveMask: GLbitfield); {$IF Defined(Windows) or Defined(MSWindows)}stdcall;{$ELSE}cdecl;{$ENDIF}

type
  TLoadProc = function(proc: PAnsiChar): Pointer;

function gladLoadGLES2(load: TLoadProc): boolean;


implementation

procedure load_GL_ES_VERSION_2_0(load: TLoadProc);
begin
  if not GLAD_GL_ES_VERSION_2_0 then exit;
  glActiveTexture := load('glActiveTexture');
  glAttachShader := load('glAttachShader');
  glBindAttribLocation := load('glBindAttribLocation');
  glBindBuffer := load('glBindBuffer');
  glBindFramebuffer := load('glBindFramebuffer');
  glBindRenderbuffer := load('glBindRenderbuffer');
  glBindTexture := load('glBindTexture');
  glBlendColor := load('glBlendColor');
  glBlendEquation := load('glBlendEquation');
  glBlendEquationSeparate := load('glBlendEquationSeparate');
  glBlendFunc := load('glBlendFunc');
  glBlendFuncSeparate := load('glBlendFuncSeparate');
  glBufferData := load('glBufferData');
  glBufferSubData := load('glBufferSubData');
  glCheckFramebufferStatus := load('glCheckFramebufferStatus');
  glClear := load('glClear');
  glClearColor := load('glClearColor');
  glClearDepthf := load('glClearDepthf');
  glClearStencil := load('glClearStencil');
  glColorMask := load('glColorMask');
  glCompileShader := load('glCompileShader');
  glCompressedTexImage2D := load('glCompressedTexImage2D');
  glCompressedTexSubImage2D := load('glCompressedTexSubImage2D');
  glCopyTexImage2D := load('glCopyTexImage2D');
  glCopyTexSubImage2D := load('glCopyTexSubImage2D');
  glCreateProgram := load('glCreateProgram');
  glCreateShader := load('glCreateShader');
  glCullFace := load('glCullFace');
  glDeleteBuffers := load('glDeleteBuffers');
  glDeleteFramebuffers := load('glDeleteFramebuffers');
  glDeleteProgram := load('glDeleteProgram');
  glDeleteRenderbuffers := load('glDeleteRenderbuffers');
  glDeleteShader := load('glDeleteShader');
  glDeleteTextures := load('glDeleteTextures');
  glDepthFunc := load('glDepthFunc');
  glDepthMask := load('glDepthMask');
  glDepthRangef := load('glDepthRangef');
  glDetachShader := load('glDetachShader');
  glDisable := load('glDisable');
  glDisableVertexAttribArray := load('glDisableVertexAttribArray');
  glDrawArrays := load('glDrawArrays');
  glDrawElements := load('glDrawElements');
  glEnable := load('glEnable');
  glEnableVertexAttribArray := load('glEnableVertexAttribArray');
  glFinish := load('glFinish');
  glFlush := load('glFlush');
  glFramebufferRenderbuffer := load('glFramebufferRenderbuffer');
  glFramebufferTexture2D := load('glFramebufferTexture2D');
  glFrontFace := load('glFrontFace');
  glGenBuffers := load('glGenBuffers');
  glGenerateMipmap := load('glGenerateMipmap');
  glGenFramebuffers := load('glGenFramebuffers');
  glGenRenderbuffers := load('glGenRenderbuffers');
  glGenTextures := load('glGenTextures');
  glGetActiveAttrib := load('glGetActiveAttrib');
  glGetActiveUniform := load('glGetActiveUniform');
  glGetAttachedShaders := load('glGetAttachedShaders');
  glGetAttribLocation := load('glGetAttribLocation');
  glGetBooleanv := load('glGetBooleanv');
  glGetBufferParameteriv := load('glGetBufferParameteriv');
  glGetError := load('glGetError');
  glGetFloatv := load('glGetFloatv');
  glGetFramebufferAttachmentParameteriv := load('glGetFramebufferAttachmentParameteriv');
  glGetIntegerv := load('glGetIntegerv');
  glGetProgramiv := load('glGetProgramiv');
  glGetProgramInfoLog := load('glGetProgramInfoLog');
  glGetRenderbufferParameteriv := load('glGetRenderbufferParameteriv');
  glGetShaderiv := load('glGetShaderiv');
  glGetShaderInfoLog := load('glGetShaderInfoLog');
  glGetShaderPrecisionFormat := load('glGetShaderPrecisionFormat');
  glGetShaderSource := load('glGetShaderSource');
  glGetString := load('glGetString');
  glGetTexParameterfv := load('glGetTexParameterfv');
  glGetTexParameteriv := load('glGetTexParameteriv');
  glGetUniformfv := load('glGetUniformfv');
  glGetUniformiv := load('glGetUniformiv');
  glGetUniformLocation := load('glGetUniformLocation');
  glGetVertexAttribfv := load('glGetVertexAttribfv');
  glGetVertexAttribiv := load('glGetVertexAttribiv');
  glGetVertexAttribPointerv := load('glGetVertexAttribPointerv');
  glHint := load('glHint');
  glIsBuffer := load('glIsBuffer');
  glIsEnabled := load('glIsEnabled');
  glIsFramebuffer := load('glIsFramebuffer');
  glIsProgram := load('glIsProgram');
  glIsRenderbuffer := load('glIsRenderbuffer');
  glIsShader := load('glIsShader');
  glIsTexture := load('glIsTexture');
  glLineWidth := load('glLineWidth');
  glLinkProgram := load('glLinkProgram');
  glPixelStorei := load('glPixelStorei');
  glPolygonOffset := load('glPolygonOffset');
  glReadPixels := load('glReadPixels');
  glReleaseShaderCompiler := load('glReleaseShaderCompiler');
  glRenderbufferStorage := load('glRenderbufferStorage');
  glSampleCoverage := load('glSampleCoverage');
  glScissor := load('glScissor');
  glShaderBinary := load('glShaderBinary');
  glShaderSource := load('glShaderSource');
  glStencilFunc := load('glStencilFunc');
  glStencilFuncSeparate := load('glStencilFuncSeparate');
  glStencilMask := load('glStencilMask');
  glStencilMaskSeparate := load('glStencilMaskSeparate');
  glStencilOp := load('glStencilOp');
  glStencilOpSeparate := load('glStencilOpSeparate');
  glTexImage2D := load('glTexImage2D');
  glTexParameterf := load('glTexParameterf');
  glTexParameterfv := load('glTexParameterfv');
  glTexParameteri := load('glTexParameteri');
  glTexParameteriv := load('glTexParameteriv');
  glTexSubImage2D := load('glTexSubImage2D');
  glUniform1f := load('glUniform1f');
  glUniform1fv := load('glUniform1fv');
  glUniform1i := load('glUniform1i');
  glUniform1iv := load('glUniform1iv');
  glUniform2f := load('glUniform2f');
  glUniform2fv := load('glUniform2fv');
  glUniform2i := load('glUniform2i');
  glUniform2iv := load('glUniform2iv');
  glUniform3f := load('glUniform3f');
  glUniform3fv := load('glUniform3fv');
  glUniform3i := load('glUniform3i');
  glUniform3iv := load('glUniform3iv');
  glUniform4f := load('glUniform4f');
  glUniform4fv := load('glUniform4fv');
  glUniform4i := load('glUniform4i');
  glUniform4iv := load('glUniform4iv');
  glUniformMatrix2fv := load('glUniformMatrix2fv');
  glUniformMatrix3fv := load('glUniformMatrix3fv');
  glUniformMatrix4fv := load('glUniformMatrix4fv');
  glUseProgram := load('glUseProgram');
  glValidateProgram := load('glValidateProgram');
  glVertexAttrib1f := load('glVertexAttrib1f');
  glVertexAttrib1fv := load('glVertexAttrib1fv');
  glVertexAttrib2f := load('glVertexAttrib2f');
  glVertexAttrib2fv := load('glVertexAttrib2fv');
  glVertexAttrib3f := load('glVertexAttrib3f');
  glVertexAttrib3fv := load('glVertexAttrib3fv');
  glVertexAttrib4f := load('glVertexAttrib4f');
  glVertexAttrib4fv := load('glVertexAttrib4fv');
  glVertexAttribPointer := load('glVertexAttribPointer');
  glViewport := load('glViewport');
end;

procedure load_GL_ES_VERSION_3_0(load: TLoadProc);
begin
  if not GLAD_GL_ES_VERSION_3_0 then exit;
  glReadBuffer := load('glReadBuffer');
  glDrawRangeElements := load('glDrawRangeElements');
  glTexImage3D := load('glTexImage3D');
  glTexSubImage3D := load('glTexSubImage3D');
  glCopyTexSubImage3D := load('glCopyTexSubImage3D');
  glCompressedTexImage3D := load('glCompressedTexImage3D');
  glCompressedTexSubImage3D := load('glCompressedTexSubImage3D');
  glGenQueries := load('glGenQueries');
  glDeleteQueries := load('glDeleteQueries');
  glIsQuery := load('glIsQuery');
  glBeginQuery := load('glBeginQuery');
  glEndQuery := load('glEndQuery');
  glGetQueryiv := load('glGetQueryiv');
  glGetQueryObjectuiv := load('glGetQueryObjectuiv');
  glUnmapBuffer := load('glUnmapBuffer');
  glGetBufferPointerv := load('glGetBufferPointerv');
  glDrawBuffers := load('glDrawBuffers');
  glUniformMatrix2x3fv := load('glUniformMatrix2x3fv');
  glUniformMatrix3x2fv := load('glUniformMatrix3x2fv');
  glUniformMatrix2x4fv := load('glUniformMatrix2x4fv');
  glUniformMatrix4x2fv := load('glUniformMatrix4x2fv');
  glUniformMatrix3x4fv := load('glUniformMatrix3x4fv');
  glUniformMatrix4x3fv := load('glUniformMatrix4x3fv');
  glBlitFramebuffer := load('glBlitFramebuffer');
  glRenderbufferStorageMultisample := load('glRenderbufferStorageMultisample');
  glFramebufferTextureLayer := load('glFramebufferTextureLayer');
  glMapBufferRange := load('glMapBufferRange');
  glFlushMappedBufferRange := load('glFlushMappedBufferRange');
  glBindVertexArray := load('glBindVertexArray');
  glDeleteVertexArrays := load('glDeleteVertexArrays');
  glGenVertexArrays := load('glGenVertexArrays');
  glIsVertexArray := load('glIsVertexArray');
  glGetIntegeri_v := load('glGetIntegeri_v');
  glBeginTransformFeedback := load('glBeginTransformFeedback');
  glEndTransformFeedback := load('glEndTransformFeedback');
  glBindBufferRange := load('glBindBufferRange');
  glBindBufferBase := load('glBindBufferBase');
  glTransformFeedbackVaryings := load('glTransformFeedbackVaryings');
  glGetTransformFeedbackVarying := load('glGetTransformFeedbackVarying');
  glVertexAttribIPointer := load('glVertexAttribIPointer');
  glGetVertexAttribIiv := load('glGetVertexAttribIiv');
  glGetVertexAttribIuiv := load('glGetVertexAttribIuiv');
  glVertexAttribI4i := load('glVertexAttribI4i');
  glVertexAttribI4ui := load('glVertexAttribI4ui');
  glVertexAttribI4iv := load('glVertexAttribI4iv');
  glVertexAttribI4uiv := load('glVertexAttribI4uiv');
  glGetUniformuiv := load('glGetUniformuiv');
  glGetFragDataLocation := load('glGetFragDataLocation');
  glUniform1ui := load('glUniform1ui');
  glUniform2ui := load('glUniform2ui');
  glUniform3ui := load('glUniform3ui');
  glUniform4ui := load('glUniform4ui');
  glUniform1uiv := load('glUniform1uiv');
  glUniform2uiv := load('glUniform2uiv');
  glUniform3uiv := load('glUniform3uiv');
  glUniform4uiv := load('glUniform4uiv');
  glClearBufferiv := load('glClearBufferiv');
  glClearBufferuiv := load('glClearBufferuiv');
  glClearBufferfv := load('glClearBufferfv');
  glClearBufferfi := load('glClearBufferfi');
  glGetStringi := load('glGetStringi');
  glCopyBufferSubData := load('glCopyBufferSubData');
  glGetUniformIndices := load('glGetUniformIndices');
  glGetActiveUniformsiv := load('glGetActiveUniformsiv');
  glGetUniformBlockIndex := load('glGetUniformBlockIndex');
  glGetActiveUniformBlockiv := load('glGetActiveUniformBlockiv');
  glGetActiveUniformBlockName := load('glGetActiveUniformBlockName');
  glUniformBlockBinding := load('glUniformBlockBinding');
  glDrawArraysInstanced := load('glDrawArraysInstanced');
  glDrawElementsInstanced := load('glDrawElementsInstanced');
  glFenceSync := load('glFenceSync');
  glIsSync := load('glIsSync');
  glDeleteSync := load('glDeleteSync');
  glClientWaitSync := load('glClientWaitSync');
  glWaitSync := load('glWaitSync');
  glGetInteger64v := load('glGetInteger64v');
  glGetSynciv := load('glGetSynciv');
  glGetInteger64i_v := load('glGetInteger64i_v');
  glGetBufferParameteri64v := load('glGetBufferParameteri64v');
  glGenSamplers := load('glGenSamplers');
  glDeleteSamplers := load('glDeleteSamplers');
  glIsSampler := load('glIsSampler');
  glBindSampler := load('glBindSampler');
  glSamplerParameteri := load('glSamplerParameteri');
  glSamplerParameteriv := load('glSamplerParameteriv');
  glSamplerParameterf := load('glSamplerParameterf');
  glSamplerParameterfv := load('glSamplerParameterfv');
  glGetSamplerParameteriv := load('glGetSamplerParameteriv');
  glGetSamplerParameterfv := load('glGetSamplerParameterfv');
  glVertexAttribDivisor := load('glVertexAttribDivisor');
  glBindTransformFeedback := load('glBindTransformFeedback');
  glDeleteTransformFeedbacks := load('glDeleteTransformFeedbacks');
  glGenTransformFeedbacks := load('glGenTransformFeedbacks');
  glIsTransformFeedback := load('glIsTransformFeedback');
  glPauseTransformFeedback := load('glPauseTransformFeedback');
  glResumeTransformFeedback := load('glResumeTransformFeedback');
  glGetProgramBinary := load('glGetProgramBinary');
  glProgramBinary := load('glProgramBinary');
  glProgramParameteri := load('glProgramParameteri');
  glInvalidateFramebuffer := load('glInvalidateFramebuffer');
  glInvalidateSubFramebuffer := load('glInvalidateSubFramebuffer');
  glTexStorage2D := load('glTexStorage2D');
  glTexStorage3D := load('glTexStorage3D');
  glGetInternalformativ := load('glGetInternalformativ');
end;

procedure load_GL_AMD_framebuffer_multisample_advanced(load: TLoadProc);
begin
  if not GLAD_GL_AMD_framebuffer_multisample_advanced then exit;
  glRenderbufferStorageMultisampleAdvancedAMD := load('glRenderbufferStorageMultisampleAdvancedAMD');
  glNamedRenderbufferStorageMultisampleAdvancedAMD := load('glNamedRenderbufferStorageMultisampleAdvancedAMD');
end;

procedure load_GL_AMD_performance_monitor(load: TLoadProc);
begin
  if not GLAD_GL_AMD_performance_monitor then exit;
  glGetPerfMonitorGroupsAMD := load('glGetPerfMonitorGroupsAMD');
  glGetPerfMonitorCountersAMD := load('glGetPerfMonitorCountersAMD');
  glGetPerfMonitorGroupStringAMD := load('glGetPerfMonitorGroupStringAMD');
  glGetPerfMonitorCounterStringAMD := load('glGetPerfMonitorCounterStringAMD');
  glGetPerfMonitorCounterInfoAMD := load('glGetPerfMonitorCounterInfoAMD');
  glGenPerfMonitorsAMD := load('glGenPerfMonitorsAMD');
  glDeletePerfMonitorsAMD := load('glDeletePerfMonitorsAMD');
  glSelectPerfMonitorCountersAMD := load('glSelectPerfMonitorCountersAMD');
  glBeginPerfMonitorAMD := load('glBeginPerfMonitorAMD');
  glEndPerfMonitorAMD := load('glEndPerfMonitorAMD');
  glGetPerfMonitorCounterDataAMD := load('glGetPerfMonitorCounterDataAMD');
end;

procedure load_GL_ANGLE_framebuffer_blit(load: TLoadProc);
begin
  if not GLAD_GL_ANGLE_framebuffer_blit then exit;
  glBlitFramebufferANGLE := load('glBlitFramebufferANGLE');
end;

procedure load_GL_ANGLE_framebuffer_multisample(load: TLoadProc);
begin
  if not GLAD_GL_ANGLE_framebuffer_multisample then exit;
  glRenderbufferStorageMultisampleANGLE := load('glRenderbufferStorageMultisampleANGLE');
end;

procedure load_GL_ANGLE_instanced_arrays(load: TLoadProc);
begin
  if not GLAD_GL_ANGLE_instanced_arrays then exit;
  glDrawArraysInstancedANGLE := load('glDrawArraysInstancedANGLE');
  glDrawElementsInstancedANGLE := load('glDrawElementsInstancedANGLE');
  glVertexAttribDivisorANGLE := load('glVertexAttribDivisorANGLE');
end;

procedure load_GL_ANGLE_translated_shader_source(load: TLoadProc);
begin
  if not GLAD_GL_ANGLE_translated_shader_source then exit;
  glGetTranslatedShaderSourceANGLE := load('glGetTranslatedShaderSourceANGLE');
end;

procedure load_GL_APPLE_copy_texture_levels(load: TLoadProc);
begin
  if not GLAD_GL_APPLE_copy_texture_levels then exit;
  glCopyTextureLevelsAPPLE := load('glCopyTextureLevelsAPPLE');
end;

procedure load_GL_APPLE_framebuffer_multisample(load: TLoadProc);
begin
  if not GLAD_GL_APPLE_framebuffer_multisample then exit;
  glRenderbufferStorageMultisampleAPPLE := load('glRenderbufferStorageMultisampleAPPLE');
  glResolveMultisampleFramebufferAPPLE := load('glResolveMultisampleFramebufferAPPLE');
end;

procedure load_GL_APPLE_sync(load: TLoadProc);
begin
  if not GLAD_GL_APPLE_sync then exit;
  glFenceSyncAPPLE := load('glFenceSyncAPPLE');
  glIsSyncAPPLE := load('glIsSyncAPPLE');
  glDeleteSyncAPPLE := load('glDeleteSyncAPPLE');
  glClientWaitSyncAPPLE := load('glClientWaitSyncAPPLE');
  glWaitSyncAPPLE := load('glWaitSyncAPPLE');
  glGetInteger64vAPPLE := load('glGetInteger64vAPPLE');
  glGetSyncivAPPLE := load('glGetSyncivAPPLE');
end;

procedure load_GL_ARM_shader_core_properties(load: TLoadProc);
begin
  if not GLAD_GL_ARM_shader_core_properties then exit;
  glMaxActiveShaderCoresARM := load('glMaxActiveShaderCoresARM');
end;

procedure load_GL_EXT_EGL_image_storage(load: TLoadProc);
begin
  if not GLAD_GL_EXT_EGL_image_storage then exit;
  glEGLImageTargetTexStorageEXT := load('glEGLImageTargetTexStorageEXT');
  glEGLImageTargetTextureStorageEXT := load('glEGLImageTargetTextureStorageEXT');
end;

procedure load_GL_EXT_base_instance(load: TLoadProc);
begin
  if not GLAD_GL_EXT_base_instance then exit;
  glDrawArraysInstancedBaseInstanceEXT := load('glDrawArraysInstancedBaseInstanceEXT');
  glDrawElementsInstancedBaseInstanceEXT := load('glDrawElementsInstancedBaseInstanceEXT');
  glDrawElementsInstancedBaseVertexBaseInstanceEXT := load('glDrawElementsInstancedBaseVertexBaseInstanceEXT');
end;

procedure load_GL_EXT_blend_func_extended(load: TLoadProc);
begin
  if not GLAD_GL_EXT_blend_func_extended then exit;
  glBindFragDataLocationIndexedEXT := load('glBindFragDataLocationIndexedEXT');
  glBindFragDataLocationEXT := load('glBindFragDataLocationEXT');
  glGetProgramResourceLocationIndexEXT := load('glGetProgramResourceLocationIndexEXT');
  glGetFragDataIndexEXT := load('glGetFragDataIndexEXT');
end;

procedure load_GL_EXT_blend_minmax(load: TLoadProc);
begin
  if not GLAD_GL_EXT_blend_minmax then exit;
  glBlendEquationEXT := load('glBlendEquationEXT');
end;

procedure load_GL_EXT_buffer_storage(load: TLoadProc);
begin
  if not GLAD_GL_EXT_buffer_storage then exit;
  glBufferStorageEXT := load('glBufferStorageEXT');
end;

procedure load_GL_EXT_clear_texture(load: TLoadProc);
begin
  if not GLAD_GL_EXT_clear_texture then exit;
  glClearTexImageEXT := load('glClearTexImageEXT');
  glClearTexSubImageEXT := load('glClearTexSubImageEXT');
end;

procedure load_GL_EXT_clip_control(load: TLoadProc);
begin
  if not GLAD_GL_EXT_clip_control then exit;
  glClipControlEXT := load('glClipControlEXT');
end;

procedure load_GL_EXT_copy_image(load: TLoadProc);
begin
  if not GLAD_GL_EXT_copy_image then exit;
  glCopyImageSubDataEXT := load('glCopyImageSubDataEXT');
end;

procedure load_GL_EXT_debug_label(load: TLoadProc);
begin
  if not GLAD_GL_EXT_debug_label then exit;
  glLabelObjectEXT := load('glLabelObjectEXT');
  glGetObjectLabelEXT := load('glGetObjectLabelEXT');
end;

procedure load_GL_EXT_debug_marker(load: TLoadProc);
begin
  if not GLAD_GL_EXT_debug_marker then exit;
  glInsertEventMarkerEXT := load('glInsertEventMarkerEXT');
  glPushGroupMarkerEXT := load('glPushGroupMarkerEXT');
  glPopGroupMarkerEXT := load('glPopGroupMarkerEXT');
end;

procedure load_GL_EXT_discard_framebuffer(load: TLoadProc);
begin
  if not GLAD_GL_EXT_discard_framebuffer then exit;
  glDiscardFramebufferEXT := load('glDiscardFramebufferEXT');
end;

procedure load_GL_EXT_disjoint_timer_query(load: TLoadProc);
begin
  if not GLAD_GL_EXT_disjoint_timer_query then exit;
  glGenQueriesEXT := load('glGenQueriesEXT');
  glDeleteQueriesEXT := load('glDeleteQueriesEXT');
  glIsQueryEXT := load('glIsQueryEXT');
  glBeginQueryEXT := load('glBeginQueryEXT');
  glEndQueryEXT := load('glEndQueryEXT');
  glQueryCounterEXT := load('glQueryCounterEXT');
  glGetQueryivEXT := load('glGetQueryivEXT');
  glGetQueryObjectivEXT := load('glGetQueryObjectivEXT');
  glGetQueryObjectuivEXT := load('glGetQueryObjectuivEXT');
  glGetQueryObjecti64vEXT := load('glGetQueryObjecti64vEXT');
  glGetQueryObjectui64vEXT := load('glGetQueryObjectui64vEXT');
  glGetInteger64vEXT := load('glGetInteger64vEXT');
end;

procedure load_GL_EXT_draw_buffers(load: TLoadProc);
begin
  if not GLAD_GL_EXT_draw_buffers then exit;
  glDrawBuffersEXT := load('glDrawBuffersEXT');
end;

procedure load_GL_EXT_draw_buffers_indexed(load: TLoadProc);
begin
  if not GLAD_GL_EXT_draw_buffers_indexed then exit;
  glEnableiEXT := load('glEnableiEXT');
  glDisableiEXT := load('glDisableiEXT');
  glBlendEquationiEXT := load('glBlendEquationiEXT');
  glBlendEquationSeparateiEXT := load('glBlendEquationSeparateiEXT');
  glBlendFunciEXT := load('glBlendFunciEXT');
  glBlendFuncSeparateiEXT := load('glBlendFuncSeparateiEXT');
  glColorMaskiEXT := load('glColorMaskiEXT');
  glIsEnablediEXT := load('glIsEnablediEXT');
end;

procedure load_GL_EXT_draw_elements_base_vertex(load: TLoadProc);
begin
  if not GLAD_GL_EXT_draw_elements_base_vertex then exit;
  glDrawElementsBaseVertexEXT := load('glDrawElementsBaseVertexEXT');
  glDrawRangeElementsBaseVertexEXT := load('glDrawRangeElementsBaseVertexEXT');
  glDrawElementsInstancedBaseVertexEXT := load('glDrawElementsInstancedBaseVertexEXT');
  glMultiDrawElementsBaseVertexEXT := load('glMultiDrawElementsBaseVertexEXT');
end;

procedure load_GL_EXT_draw_instanced(load: TLoadProc);
begin
  if not GLAD_GL_EXT_draw_instanced then exit;
  glDrawArraysInstancedEXT := load('glDrawArraysInstancedEXT');
  glDrawElementsInstancedEXT := load('glDrawElementsInstancedEXT');
end;

procedure load_GL_EXT_draw_transform_feedback(load: TLoadProc);
begin
  if not GLAD_GL_EXT_draw_transform_feedback then exit;
  glDrawTransformFeedbackEXT := load('glDrawTransformFeedbackEXT');
  glDrawTransformFeedbackInstancedEXT := load('glDrawTransformFeedbackInstancedEXT');
end;

procedure load_GL_EXT_external_buffer(load: TLoadProc);
begin
  if not GLAD_GL_EXT_external_buffer then exit;
  glBufferStorageExternalEXT := load('glBufferStorageExternalEXT');
  glNamedBufferStorageExternalEXT := load('glNamedBufferStorageExternalEXT');
end;

procedure load_GL_EXT_fragment_shading_rate(load: TLoadProc);
begin
  if not GLAD_GL_EXT_fragment_shading_rate then exit;
  glGetFragmentShadingRatesEXT := load('glGetFragmentShadingRatesEXT');
  glShadingRateEXT := load('glShadingRateEXT');
  glShadingRateCombinerOpsEXT := load('glShadingRateCombinerOpsEXT');
  glFramebufferShadingRateEXT := load('glFramebufferShadingRateEXT');
end;

procedure load_GL_EXT_framebuffer_blit_layers(load: TLoadProc);
begin
  if not GLAD_GL_EXT_framebuffer_blit_layers then exit;
  glBlitFramebufferLayersEXT := load('glBlitFramebufferLayersEXT');
  glBlitFramebufferLayerEXT := load('glBlitFramebufferLayerEXT');
end;

procedure load_GL_EXT_geometry_shader(load: TLoadProc);
begin
  if not GLAD_GL_EXT_geometry_shader then exit;
  glFramebufferTextureEXT := load('glFramebufferTextureEXT');
end;

procedure load_GL_EXT_instanced_arrays(load: TLoadProc);
begin
  if not GLAD_GL_EXT_instanced_arrays then exit;
  glDrawArraysInstancedEXT := load('glDrawArraysInstancedEXT');
  glDrawElementsInstancedEXT := load('glDrawElementsInstancedEXT');
  glVertexAttribDivisorEXT := load('glVertexAttribDivisorEXT');
end;

procedure load_GL_EXT_map_buffer_range(load: TLoadProc);
begin
  if not GLAD_GL_EXT_map_buffer_range then exit;
  glMapBufferRangeEXT := load('glMapBufferRangeEXT');
  glFlushMappedBufferRangeEXT := load('glFlushMappedBufferRangeEXT');
end;

procedure load_GL_EXT_memory_object(load: TLoadProc);
begin
  if not GLAD_GL_EXT_memory_object then exit;
  glGetUnsignedBytevEXT := load('glGetUnsignedBytevEXT');
  glGetUnsignedBytei_vEXT := load('glGetUnsignedBytei_vEXT');
  glDeleteMemoryObjectsEXT := load('glDeleteMemoryObjectsEXT');
  glIsMemoryObjectEXT := load('glIsMemoryObjectEXT');
  glCreateMemoryObjectsEXT := load('glCreateMemoryObjectsEXT');
  glMemoryObjectParameterivEXT := load('glMemoryObjectParameterivEXT');
  glGetMemoryObjectParameterivEXT := load('glGetMemoryObjectParameterivEXT');
  glTexStorageMem2DEXT := load('glTexStorageMem2DEXT');
  glTexStorageMem2DMultisampleEXT := load('glTexStorageMem2DMultisampleEXT');
  glTexStorageMem3DEXT := load('glTexStorageMem3DEXT');
  glTexStorageMem3DMultisampleEXT := load('glTexStorageMem3DMultisampleEXT');
  glBufferStorageMemEXT := load('glBufferStorageMemEXT');
  glTextureStorageMem2DEXT := load('glTextureStorageMem2DEXT');
  glTextureStorageMem2DMultisampleEXT := load('glTextureStorageMem2DMultisampleEXT');
  glTextureStorageMem3DEXT := load('glTextureStorageMem3DEXT');
  glTextureStorageMem3DMultisampleEXT := load('glTextureStorageMem3DMultisampleEXT');
  glNamedBufferStorageMemEXT := load('glNamedBufferStorageMemEXT');
  glTexStorageMem1DEXT := load('glTexStorageMem1DEXT');
  glTextureStorageMem1DEXT := load('glTextureStorageMem1DEXT');
end;

procedure load_GL_EXT_memory_object_fd(load: TLoadProc);
begin
  if not GLAD_GL_EXT_memory_object_fd then exit;
  glImportMemoryFdEXT := load('glImportMemoryFdEXT');
end;

procedure load_GL_EXT_memory_object_win32(load: TLoadProc);
begin
  if not GLAD_GL_EXT_memory_object_win32 then exit;
  glImportMemoryWin32HandleEXT := load('glImportMemoryWin32HandleEXT');
  glImportMemoryWin32NameEXT := load('glImportMemoryWin32NameEXT');
end;

procedure load_GL_EXT_multi_draw_arrays(load: TLoadProc);
begin
  if not GLAD_GL_EXT_multi_draw_arrays then exit;
  glMultiDrawArraysEXT := load('glMultiDrawArraysEXT');
  glMultiDrawElementsEXT := load('glMultiDrawElementsEXT');
end;

procedure load_GL_EXT_multi_draw_indirect(load: TLoadProc);
begin
  if not GLAD_GL_EXT_multi_draw_indirect then exit;
  glMultiDrawArraysIndirectEXT := load('glMultiDrawArraysIndirectEXT');
  glMultiDrawElementsIndirectEXT := load('glMultiDrawElementsIndirectEXT');
end;

procedure load_GL_EXT_multisampled_render_to_texture(load: TLoadProc);
begin
  if not GLAD_GL_EXT_multisampled_render_to_texture then exit;
  glRenderbufferStorageMultisampleEXT := load('glRenderbufferStorageMultisampleEXT');
  glFramebufferTexture2DMultisampleEXT := load('glFramebufferTexture2DMultisampleEXT');
end;

procedure load_GL_EXT_multiview_draw_buffers(load: TLoadProc);
begin
  if not GLAD_GL_EXT_multiview_draw_buffers then exit;
  glReadBufferIndexedEXT := load('glReadBufferIndexedEXT');
  glDrawBuffersIndexedEXT := load('glDrawBuffersIndexedEXT');
  glGetIntegeri_vEXT := load('glGetIntegeri_vEXT');
end;

procedure load_GL_EXT_occlusion_query_boolean(load: TLoadProc);
begin
  if not GLAD_GL_EXT_occlusion_query_boolean then exit;
  glGenQueriesEXT := load('glGenQueriesEXT');
  glDeleteQueriesEXT := load('glDeleteQueriesEXT');
  glIsQueryEXT := load('glIsQueryEXT');
  glBeginQueryEXT := load('glBeginQueryEXT');
  glEndQueryEXT := load('glEndQueryEXT');
  glGetQueryivEXT := load('glGetQueryivEXT');
  glGetQueryObjectuivEXT := load('glGetQueryObjectuivEXT');
end;

procedure load_GL_EXT_polygon_offset_clamp(load: TLoadProc);
begin
  if not GLAD_GL_EXT_polygon_offset_clamp then exit;
  glPolygonOffsetClampEXT := load('glPolygonOffsetClampEXT');
end;

procedure load_GL_EXT_primitive_bounding_box(load: TLoadProc);
begin
  if not GLAD_GL_EXT_primitive_bounding_box then exit;
  glPrimitiveBoundingBoxEXT := load('glPrimitiveBoundingBoxEXT');
end;

procedure load_GL_EXT_raster_multisample(load: TLoadProc);
begin
  if not GLAD_GL_EXT_raster_multisample then exit;
  glRasterSamplesEXT := load('glRasterSamplesEXT');
end;

procedure load_GL_EXT_robustness(load: TLoadProc);
begin
  if not GLAD_GL_EXT_robustness then exit;
  glGetGraphicsResetStatusEXT := load('glGetGraphicsResetStatusEXT');
  glReadnPixelsEXT := load('glReadnPixelsEXT');
  glGetnUniformfvEXT := load('glGetnUniformfvEXT');
  glGetnUniformivEXT := load('glGetnUniformivEXT');
end;

procedure load_GL_EXT_semaphore(load: TLoadProc);
begin
  if not GLAD_GL_EXT_semaphore then exit;
  glGetUnsignedBytevEXT := load('glGetUnsignedBytevEXT');
  glGetUnsignedBytei_vEXT := load('glGetUnsignedBytei_vEXT');
  glGenSemaphoresEXT := load('glGenSemaphoresEXT');
  glDeleteSemaphoresEXT := load('glDeleteSemaphoresEXT');
  glIsSemaphoreEXT := load('glIsSemaphoreEXT');
  glSemaphoreParameterui64vEXT := load('glSemaphoreParameterui64vEXT');
  glGetSemaphoreParameterui64vEXT := load('glGetSemaphoreParameterui64vEXT');
  glWaitSemaphoreEXT := load('glWaitSemaphoreEXT');
  glSignalSemaphoreEXT := load('glSignalSemaphoreEXT');
end;

procedure load_GL_EXT_semaphore_fd(load: TLoadProc);
begin
  if not GLAD_GL_EXT_semaphore_fd then exit;
  glImportSemaphoreFdEXT := load('glImportSemaphoreFdEXT');
end;

procedure load_GL_EXT_semaphore_win32(load: TLoadProc);
begin
  if not GLAD_GL_EXT_semaphore_win32 then exit;
  glImportSemaphoreWin32HandleEXT := load('glImportSemaphoreWin32HandleEXT');
  glImportSemaphoreWin32NameEXT := load('glImportSemaphoreWin32NameEXT');
end;

procedure load_GL_EXT_separate_shader_objects(load: TLoadProc);
begin
  if not GLAD_GL_EXT_separate_shader_objects then exit;
  glUseShaderProgramEXT := load('glUseShaderProgramEXT');
  glActiveProgramEXT := load('glActiveProgramEXT');
  glCreateShaderProgramEXT := load('glCreateShaderProgramEXT');
  glActiveShaderProgramEXT := load('glActiveShaderProgramEXT');
  glBindProgramPipelineEXT := load('glBindProgramPipelineEXT');
  glCreateShaderProgramvEXT := load('glCreateShaderProgramvEXT');
  glDeleteProgramPipelinesEXT := load('glDeleteProgramPipelinesEXT');
  glGenProgramPipelinesEXT := load('glGenProgramPipelinesEXT');
  glGetProgramPipelineInfoLogEXT := load('glGetProgramPipelineInfoLogEXT');
  glGetProgramPipelineivEXT := load('glGetProgramPipelineivEXT');
  glIsProgramPipelineEXT := load('glIsProgramPipelineEXT');
  glProgramParameteriEXT := load('glProgramParameteriEXT');
  glProgramUniform1fEXT := load('glProgramUniform1fEXT');
  glProgramUniform1fvEXT := load('glProgramUniform1fvEXT');
  glProgramUniform1iEXT := load('glProgramUniform1iEXT');
  glProgramUniform1ivEXT := load('glProgramUniform1ivEXT');
  glProgramUniform2fEXT := load('glProgramUniform2fEXT');
  glProgramUniform2fvEXT := load('glProgramUniform2fvEXT');
  glProgramUniform2iEXT := load('glProgramUniform2iEXT');
  glProgramUniform2ivEXT := load('glProgramUniform2ivEXT');
  glProgramUniform3fEXT := load('glProgramUniform3fEXT');
  glProgramUniform3fvEXT := load('glProgramUniform3fvEXT');
  glProgramUniform3iEXT := load('glProgramUniform3iEXT');
  glProgramUniform3ivEXT := load('glProgramUniform3ivEXT');
  glProgramUniform4fEXT := load('glProgramUniform4fEXT');
  glProgramUniform4fvEXT := load('glProgramUniform4fvEXT');
  glProgramUniform4iEXT := load('glProgramUniform4iEXT');
  glProgramUniform4ivEXT := load('glProgramUniform4ivEXT');
  glProgramUniformMatrix2fvEXT := load('glProgramUniformMatrix2fvEXT');
  glProgramUniformMatrix3fvEXT := load('glProgramUniformMatrix3fvEXT');
  glProgramUniformMatrix4fvEXT := load('glProgramUniformMatrix4fvEXT');
  glUseProgramStagesEXT := load('glUseProgramStagesEXT');
  glValidateProgramPipelineEXT := load('glValidateProgramPipelineEXT');
  glProgramUniform1uiEXT := load('glProgramUniform1uiEXT');
  glProgramUniform2uiEXT := load('glProgramUniform2uiEXT');
  glProgramUniform3uiEXT := load('glProgramUniform3uiEXT');
  glProgramUniform4uiEXT := load('glProgramUniform4uiEXT');
  glProgramUniform1uivEXT := load('glProgramUniform1uivEXT');
  glProgramUniform2uivEXT := load('glProgramUniform2uivEXT');
  glProgramUniform3uivEXT := load('glProgramUniform3uivEXT');
  glProgramUniform4uivEXT := load('glProgramUniform4uivEXT');
  glProgramUniformMatrix2x3fvEXT := load('glProgramUniformMatrix2x3fvEXT');
  glProgramUniformMatrix3x2fvEXT := load('glProgramUniformMatrix3x2fvEXT');
  glProgramUniformMatrix2x4fvEXT := load('glProgramUniformMatrix2x4fvEXT');
  glProgramUniformMatrix4x2fvEXT := load('glProgramUniformMatrix4x2fvEXT');
  glProgramUniformMatrix3x4fvEXT := load('glProgramUniformMatrix3x4fvEXT');
  glProgramUniformMatrix4x3fvEXT := load('glProgramUniformMatrix4x3fvEXT');
end;

procedure load_GL_EXT_shader_framebuffer_fetch_non_coherent(load: TLoadProc);
begin
  if not GLAD_GL_EXT_shader_framebuffer_fetch_non_coherent then exit;
  glFramebufferFetchBarrierEXT := load('glFramebufferFetchBarrierEXT');
end;

procedure load_GL_EXT_shader_pixel_local_storage2(load: TLoadProc);
begin
  if not GLAD_GL_EXT_shader_pixel_local_storage2 then exit;
  glFramebufferPixelLocalStorageSizeEXT := load('glFramebufferPixelLocalStorageSizeEXT');
  glGetFramebufferPixelLocalStorageSizeEXT := load('glGetFramebufferPixelLocalStorageSizeEXT');
  glClearPixelLocalStorageuiEXT := load('glClearPixelLocalStorageuiEXT');
end;

procedure load_GL_EXT_sparse_texture(load: TLoadProc);
begin
  if not GLAD_GL_EXT_sparse_texture then exit;
  glTexPageCommitmentEXT := load('glTexPageCommitmentEXT');
end;

procedure load_GL_EXT_tessellation_shader(load: TLoadProc);
begin
  if not GLAD_GL_EXT_tessellation_shader then exit;
  glPatchParameteriEXT := load('glPatchParameteriEXT');
end;

procedure load_GL_EXT_texture_border_clamp(load: TLoadProc);
begin
  if not GLAD_GL_EXT_texture_border_clamp then exit;
  glTexParameterIivEXT := load('glTexParameterIivEXT');
  glTexParameterIuivEXT := load('glTexParameterIuivEXT');
  glGetTexParameterIivEXT := load('glGetTexParameterIivEXT');
  glGetTexParameterIuivEXT := load('glGetTexParameterIuivEXT');
  glSamplerParameterIivEXT := load('glSamplerParameterIivEXT');
  glSamplerParameterIuivEXT := load('glSamplerParameterIuivEXT');
  glGetSamplerParameterIivEXT := load('glGetSamplerParameterIivEXT');
  glGetSamplerParameterIuivEXT := load('glGetSamplerParameterIuivEXT');
end;

procedure load_GL_EXT_texture_buffer(load: TLoadProc);
begin
  if not GLAD_GL_EXT_texture_buffer then exit;
  glTexBufferEXT := load('glTexBufferEXT');
  glTexBufferRangeEXT := load('glTexBufferRangeEXT');
end;

procedure load_GL_EXT_texture_storage(load: TLoadProc);
begin
  if not GLAD_GL_EXT_texture_storage then exit;
  glTexStorage1DEXT := load('glTexStorage1DEXT');
  glTexStorage2DEXT := load('glTexStorage2DEXT');
  glTexStorage3DEXT := load('glTexStorage3DEXT');
  glTextureStorage1DEXT := load('glTextureStorage1DEXT');
  glTextureStorage2DEXT := load('glTextureStorage2DEXT');
  glTextureStorage3DEXT := load('glTextureStorage3DEXT');
end;

procedure load_GL_EXT_texture_storage_compression(load: TLoadProc);
begin
  if not GLAD_GL_EXT_texture_storage_compression then exit;
  glTexStorageAttribs2DEXT := load('glTexStorageAttribs2DEXT');
  glTexStorageAttribs3DEXT := load('glTexStorageAttribs3DEXT');
end;

procedure load_GL_EXT_texture_view(load: TLoadProc);
begin
  if not GLAD_GL_EXT_texture_view then exit;
  glTextureViewEXT := load('glTextureViewEXT');
end;

procedure load_GL_EXT_win32_keyed_mutex(load: TLoadProc);
begin
  if not GLAD_GL_EXT_win32_keyed_mutex then exit;
  glAcquireKeyedMutexWin32EXT := load('glAcquireKeyedMutexWin32EXT');
  glReleaseKeyedMutexWin32EXT := load('glReleaseKeyedMutexWin32EXT');
end;

procedure load_GL_EXT_window_rectangles(load: TLoadProc);
begin
  if not GLAD_GL_EXT_window_rectangles then exit;
  glWindowRectanglesEXT := load('glWindowRectanglesEXT');
end;

procedure load_GL_IMG_bindless_texture(load: TLoadProc);
begin
  if not GLAD_GL_IMG_bindless_texture then exit;
  glGetTextureHandleIMG := load('glGetTextureHandleIMG');
  glGetTextureSamplerHandleIMG := load('glGetTextureSamplerHandleIMG');
  glUniformHandleui64IMG := load('glUniformHandleui64IMG');
  glUniformHandleui64vIMG := load('glUniformHandleui64vIMG');
  glProgramUniformHandleui64IMG := load('glProgramUniformHandleui64IMG');
  glProgramUniformHandleui64vIMG := load('glProgramUniformHandleui64vIMG');
end;

procedure load_GL_IMG_framebuffer_downsample(load: TLoadProc);
begin
  if not GLAD_GL_IMG_framebuffer_downsample then exit;
  glFramebufferTexture2DDownsampleIMG := load('glFramebufferTexture2DDownsampleIMG');
  glFramebufferTextureLayerDownsampleIMG := load('glFramebufferTextureLayerDownsampleIMG');
end;

procedure load_GL_IMG_multisampled_render_to_texture(load: TLoadProc);
begin
  if not GLAD_GL_IMG_multisampled_render_to_texture then exit;
  glRenderbufferStorageMultisampleIMG := load('glRenderbufferStorageMultisampleIMG');
  glFramebufferTexture2DMultisampleIMG := load('glFramebufferTexture2DMultisampleIMG');
end;

procedure load_GL_INTEL_framebuffer_CMAA(load: TLoadProc);
begin
  if not GLAD_GL_INTEL_framebuffer_CMAA then exit;
  glApplyFramebufferAttachmentCMAAINTEL := load('glApplyFramebufferAttachmentCMAAINTEL');
end;

procedure load_GL_INTEL_performance_query(load: TLoadProc);
begin
  if not GLAD_GL_INTEL_performance_query then exit;
  glBeginPerfQueryINTEL := load('glBeginPerfQueryINTEL');
  glCreatePerfQueryINTEL := load('glCreatePerfQueryINTEL');
  glDeletePerfQueryINTEL := load('glDeletePerfQueryINTEL');
  glEndPerfQueryINTEL := load('glEndPerfQueryINTEL');
  glGetFirstPerfQueryIdINTEL := load('glGetFirstPerfQueryIdINTEL');
  glGetNextPerfQueryIdINTEL := load('glGetNextPerfQueryIdINTEL');
  glGetPerfCounterInfoINTEL := load('glGetPerfCounterInfoINTEL');
  glGetPerfQueryDataINTEL := load('glGetPerfQueryDataINTEL');
  glGetPerfQueryIdByNameINTEL := load('glGetPerfQueryIdByNameINTEL');
  glGetPerfQueryInfoINTEL := load('glGetPerfQueryInfoINTEL');
end;

procedure load_GL_KHR_blend_equation_advanced(load: TLoadProc);
begin
  if not GLAD_GL_KHR_blend_equation_advanced then exit;
  glBlendBarrierKHR := load('glBlendBarrierKHR');
end;

procedure load_GL_KHR_debug(load: TLoadProc);
begin
  if not GLAD_GL_KHR_debug then exit;
  glDebugMessageControl := load('glDebugMessageControl');
  glDebugMessageInsert := load('glDebugMessageInsert');
  glDebugMessageCallback := load('glDebugMessageCallback');
  glGetDebugMessageLog := load('glGetDebugMessageLog');
  glPushDebugGroup := load('glPushDebugGroup');
  glPopDebugGroup := load('glPopDebugGroup');
  glObjectLabel := load('glObjectLabel');
  glGetObjectLabel := load('glGetObjectLabel');
  glObjectPtrLabel := load('glObjectPtrLabel');
  glGetObjectPtrLabel := load('glGetObjectPtrLabel');
  glGetPointerv := load('glGetPointerv');
  glDebugMessageControlKHR := load('glDebugMessageControlKHR');
  glDebugMessageInsertKHR := load('glDebugMessageInsertKHR');
  glDebugMessageCallbackKHR := load('glDebugMessageCallbackKHR');
  glGetDebugMessageLogKHR := load('glGetDebugMessageLogKHR');
  glPushDebugGroupKHR := load('glPushDebugGroupKHR');
  glPopDebugGroupKHR := load('glPopDebugGroupKHR');
  glObjectLabelKHR := load('glObjectLabelKHR');
  glGetObjectLabelKHR := load('glGetObjectLabelKHR');
  glObjectPtrLabelKHR := load('glObjectPtrLabelKHR');
  glGetObjectPtrLabelKHR := load('glGetObjectPtrLabelKHR');
  glGetPointervKHR := load('glGetPointervKHR');
end;

procedure load_GL_KHR_parallel_shader_compile(load: TLoadProc);
begin
  if not GLAD_GL_KHR_parallel_shader_compile then exit;
  glMaxShaderCompilerThreadsKHR := load('glMaxShaderCompilerThreadsKHR');
end;

procedure load_GL_KHR_robustness(load: TLoadProc);
begin
  if not GLAD_GL_KHR_robustness then exit;
  glGetGraphicsResetStatus := load('glGetGraphicsResetStatus');
  glReadnPixels := load('glReadnPixels');
  glGetnUniformfv := load('glGetnUniformfv');
  glGetnUniformiv := load('glGetnUniformiv');
  glGetnUniformuiv := load('glGetnUniformuiv');
  glGetGraphicsResetStatusKHR := load('glGetGraphicsResetStatusKHR');
  glReadnPixelsKHR := load('glReadnPixelsKHR');
  glGetnUniformfvKHR := load('glGetnUniformfvKHR');
  glGetnUniformivKHR := load('glGetnUniformivKHR');
  glGetnUniformuivKHR := load('glGetnUniformuivKHR');
end;

procedure load_GL_MESA_framebuffer_flip_y(load: TLoadProc);
begin
  if not GLAD_GL_MESA_framebuffer_flip_y then exit;
  glFramebufferParameteriMESA := load('glFramebufferParameteriMESA');
  glGetFramebufferParameterivMESA := load('glGetFramebufferParameterivMESA');
end;

procedure load_GL_MESA_sampler_objects(load: TLoadProc);
begin
  if not GLAD_GL_MESA_sampler_objects then exit;
  glGenSamplers := load('glGenSamplers');
  glDeleteSamplers := load('glDeleteSamplers');
  glIsSampler := load('glIsSampler');
  glBindSampler := load('glBindSampler');
  glSamplerParameteri := load('glSamplerParameteri');
  glSamplerParameteriv := load('glSamplerParameteriv');
  glSamplerParameterf := load('glSamplerParameterf');
  glSamplerParameterfv := load('glSamplerParameterfv');
  glGetSamplerParameteriv := load('glGetSamplerParameteriv');
  glGetSamplerParameterfv := load('glGetSamplerParameterfv');
end;

procedure load_GL_NV_bindless_texture(load: TLoadProc);
begin
  if not GLAD_GL_NV_bindless_texture then exit;
  glGetTextureHandleNV := load('glGetTextureHandleNV');
  glGetTextureSamplerHandleNV := load('glGetTextureSamplerHandleNV');
  glMakeTextureHandleResidentNV := load('glMakeTextureHandleResidentNV');
  glMakeTextureHandleNonResidentNV := load('glMakeTextureHandleNonResidentNV');
  glGetImageHandleNV := load('glGetImageHandleNV');
  glMakeImageHandleResidentNV := load('glMakeImageHandleResidentNV');
  glMakeImageHandleNonResidentNV := load('glMakeImageHandleNonResidentNV');
  glUniformHandleui64NV := load('glUniformHandleui64NV');
  glUniformHandleui64vNV := load('glUniformHandleui64vNV');
  glProgramUniformHandleui64NV := load('glProgramUniformHandleui64NV');
  glProgramUniformHandleui64vNV := load('glProgramUniformHandleui64vNV');
  glIsTextureHandleResidentNV := load('glIsTextureHandleResidentNV');
  glIsImageHandleResidentNV := load('glIsImageHandleResidentNV');
end;

procedure load_GL_NV_blend_equation_advanced(load: TLoadProc);
begin
  if not GLAD_GL_NV_blend_equation_advanced then exit;
  glBlendParameteriNV := load('glBlendParameteriNV');
  glBlendBarrierNV := load('glBlendBarrierNV');
end;

procedure load_GL_NV_clip_space_w_scaling(load: TLoadProc);
begin
  if not GLAD_GL_NV_clip_space_w_scaling then exit;
  glViewportPositionWScaleNV := load('glViewportPositionWScaleNV');
end;

procedure load_GL_NV_conditional_render(load: TLoadProc);
begin
  if not GLAD_GL_NV_conditional_render then exit;
  glBeginConditionalRenderNV := load('glBeginConditionalRenderNV');
  glEndConditionalRenderNV := load('glEndConditionalRenderNV');
end;

procedure load_GL_NV_conservative_raster(load: TLoadProc);
begin
  if not GLAD_GL_NV_conservative_raster then exit;
  glSubpixelPrecisionBiasNV := load('glSubpixelPrecisionBiasNV');
end;

procedure load_GL_NV_conservative_raster_pre_snap_triangles(load: TLoadProc);
begin
  if not GLAD_GL_NV_conservative_raster_pre_snap_triangles then exit;
  glConservativeRasterParameteriNV := load('glConservativeRasterParameteriNV');
end;

procedure load_GL_NV_copy_buffer(load: TLoadProc);
begin
  if not GLAD_GL_NV_copy_buffer then exit;
  glCopyBufferSubDataNV := load('glCopyBufferSubDataNV');
end;

procedure load_GL_NV_coverage_sample(load: TLoadProc);
begin
  if not GLAD_GL_NV_coverage_sample then exit;
  glCoverageMaskNV := load('glCoverageMaskNV');
  glCoverageOperationNV := load('glCoverageOperationNV');
end;

procedure load_GL_NV_draw_buffers(load: TLoadProc);
begin
  if not GLAD_GL_NV_draw_buffers then exit;
  glDrawBuffersNV := load('glDrawBuffersNV');
end;

procedure load_GL_NV_draw_instanced(load: TLoadProc);
begin
  if not GLAD_GL_NV_draw_instanced then exit;
  glDrawArraysInstancedNV := load('glDrawArraysInstancedNV');
  glDrawElementsInstancedNV := load('glDrawElementsInstancedNV');
end;

procedure load_GL_NV_draw_vulkan_image(load: TLoadProc);
begin
  if not GLAD_GL_NV_draw_vulkan_image then exit;
  glDrawVkImageNV := load('glDrawVkImageNV');
  glGetVkProcAddrNV := load('glGetVkProcAddrNV');
  glWaitVkSemaphoreNV := load('glWaitVkSemaphoreNV');
  glSignalVkSemaphoreNV := load('glSignalVkSemaphoreNV');
  glSignalVkFenceNV := load('glSignalVkFenceNV');
end;

procedure load_GL_NV_fence(load: TLoadProc);
begin
  if not GLAD_GL_NV_fence then exit;
  glDeleteFencesNV := load('glDeleteFencesNV');
  glGenFencesNV := load('glGenFencesNV');
  glIsFenceNV := load('glIsFenceNV');
  glTestFenceNV := load('glTestFenceNV');
  glGetFenceivNV := load('glGetFenceivNV');
  glFinishFenceNV := load('glFinishFenceNV');
  glSetFenceNV := load('glSetFenceNV');
end;

procedure load_GL_NV_fragment_coverage_to_color(load: TLoadProc);
begin
  if not GLAD_GL_NV_fragment_coverage_to_color then exit;
  glFragmentCoverageColorNV := load('glFragmentCoverageColorNV');
end;

procedure load_GL_NV_framebuffer_blit(load: TLoadProc);
begin
  if not GLAD_GL_NV_framebuffer_blit then exit;
  glBlitFramebufferNV := load('glBlitFramebufferNV');
end;

procedure load_GL_NV_framebuffer_mixed_samples(load: TLoadProc);
begin
  if not GLAD_GL_NV_framebuffer_mixed_samples then exit;
  glRasterSamplesEXT := load('glRasterSamplesEXT');
  glCoverageModulationTableNV := load('glCoverageModulationTableNV');
  glGetCoverageModulationTableNV := load('glGetCoverageModulationTableNV');
  glCoverageModulationNV := load('glCoverageModulationNV');
end;

procedure load_GL_NV_framebuffer_multisample(load: TLoadProc);
begin
  if not GLAD_GL_NV_framebuffer_multisample then exit;
  glRenderbufferStorageMultisampleNV := load('glRenderbufferStorageMultisampleNV');
end;

procedure load_GL_NV_gpu_shader5(load: TLoadProc);
begin
  if not GLAD_GL_NV_gpu_shader5 then exit;
  glUniform1i64NV := load('glUniform1i64NV');
  glUniform2i64NV := load('glUniform2i64NV');
  glUniform3i64NV := load('glUniform3i64NV');
  glUniform4i64NV := load('glUniform4i64NV');
  glUniform1i64vNV := load('glUniform1i64vNV');
  glUniform2i64vNV := load('glUniform2i64vNV');
  glUniform3i64vNV := load('glUniform3i64vNV');
  glUniform4i64vNV := load('glUniform4i64vNV');
  glUniform1ui64NV := load('glUniform1ui64NV');
  glUniform2ui64NV := load('glUniform2ui64NV');
  glUniform3ui64NV := load('glUniform3ui64NV');
  glUniform4ui64NV := load('glUniform4ui64NV');
  glUniform1ui64vNV := load('glUniform1ui64vNV');
  glUniform2ui64vNV := load('glUniform2ui64vNV');
  glUniform3ui64vNV := load('glUniform3ui64vNV');
  glUniform4ui64vNV := load('glUniform4ui64vNV');
  glGetUniformi64vNV := load('glGetUniformi64vNV');
  glProgramUniform1i64NV := load('glProgramUniform1i64NV');
  glProgramUniform2i64NV := load('glProgramUniform2i64NV');
  glProgramUniform3i64NV := load('glProgramUniform3i64NV');
  glProgramUniform4i64NV := load('glProgramUniform4i64NV');
  glProgramUniform1i64vNV := load('glProgramUniform1i64vNV');
  glProgramUniform2i64vNV := load('glProgramUniform2i64vNV');
  glProgramUniform3i64vNV := load('glProgramUniform3i64vNV');
  glProgramUniform4i64vNV := load('glProgramUniform4i64vNV');
  glProgramUniform1ui64NV := load('glProgramUniform1ui64NV');
  glProgramUniform2ui64NV := load('glProgramUniform2ui64NV');
  glProgramUniform3ui64NV := load('glProgramUniform3ui64NV');
  glProgramUniform4ui64NV := load('glProgramUniform4ui64NV');
  glProgramUniform1ui64vNV := load('glProgramUniform1ui64vNV');
  glProgramUniform2ui64vNV := load('glProgramUniform2ui64vNV');
  glProgramUniform3ui64vNV := load('glProgramUniform3ui64vNV');
  glProgramUniform4ui64vNV := load('glProgramUniform4ui64vNV');
end;

procedure load_GL_NV_instanced_arrays(load: TLoadProc);
begin
  if not GLAD_GL_NV_instanced_arrays then exit;
  glVertexAttribDivisorNV := load('glVertexAttribDivisorNV');
end;

procedure load_GL_NV_internalformat_sample_query(load: TLoadProc);
begin
  if not GLAD_GL_NV_internalformat_sample_query then exit;
  glGetInternalformatSampleivNV := load('glGetInternalformatSampleivNV');
end;

procedure load_GL_NV_memory_attachment(load: TLoadProc);
begin
  if not GLAD_GL_NV_memory_attachment then exit;
  glGetMemoryObjectDetachedResourcesuivNV := load('glGetMemoryObjectDetachedResourcesuivNV');
  glResetMemoryObjectParameterNV := load('glResetMemoryObjectParameterNV');
  glTexAttachMemoryNV := load('glTexAttachMemoryNV');
  glBufferAttachMemoryNV := load('glBufferAttachMemoryNV');
  glTextureAttachMemoryNV := load('glTextureAttachMemoryNV');
  glNamedBufferAttachMemoryNV := load('glNamedBufferAttachMemoryNV');
end;

procedure load_GL_NV_memory_object_sparse(load: TLoadProc);
begin
  if not GLAD_GL_NV_memory_object_sparse then exit;
  glBufferPageCommitmentMemNV := load('glBufferPageCommitmentMemNV');
  glTexPageCommitmentMemNV := load('glTexPageCommitmentMemNV');
  glNamedBufferPageCommitmentMemNV := load('glNamedBufferPageCommitmentMemNV');
  glTexturePageCommitmentMemNV := load('glTexturePageCommitmentMemNV');
end;

procedure load_GL_NV_mesh_shader(load: TLoadProc);
begin
  if not GLAD_GL_NV_mesh_shader then exit;
  glDrawMeshTasksNV := load('glDrawMeshTasksNV');
  glDrawMeshTasksIndirectNV := load('glDrawMeshTasksIndirectNV');
  glMultiDrawMeshTasksIndirectNV := load('glMultiDrawMeshTasksIndirectNV');
  glMultiDrawMeshTasksIndirectCountNV := load('glMultiDrawMeshTasksIndirectCountNV');
end;

procedure load_GL_NV_non_square_matrices(load: TLoadProc);
begin
  if not GLAD_GL_NV_non_square_matrices then exit;
  glUniformMatrix2x3fvNV := load('glUniformMatrix2x3fvNV');
  glUniformMatrix3x2fvNV := load('glUniformMatrix3x2fvNV');
  glUniformMatrix2x4fvNV := load('glUniformMatrix2x4fvNV');
  glUniformMatrix4x2fvNV := load('glUniformMatrix4x2fvNV');
  glUniformMatrix3x4fvNV := load('glUniformMatrix3x4fvNV');
  glUniformMatrix4x3fvNV := load('glUniformMatrix4x3fvNV');
end;

procedure load_GL_NV_path_rendering(load: TLoadProc);
begin
  if not GLAD_GL_NV_path_rendering then exit;
  glGenPathsNV := load('glGenPathsNV');
  glDeletePathsNV := load('glDeletePathsNV');
  glIsPathNV := load('glIsPathNV');
  glPathCommandsNV := load('glPathCommandsNV');
  glPathCoordsNV := load('glPathCoordsNV');
  glPathSubCommandsNV := load('glPathSubCommandsNV');
  glPathSubCoordsNV := load('glPathSubCoordsNV');
  glPathStringNV := load('glPathStringNV');
  glPathGlyphsNV := load('glPathGlyphsNV');
  glPathGlyphRangeNV := load('glPathGlyphRangeNV');
  glWeightPathsNV := load('glWeightPathsNV');
  glCopyPathNV := load('glCopyPathNV');
  glInterpolatePathsNV := load('glInterpolatePathsNV');
  glTransformPathNV := load('glTransformPathNV');
  glPathParameterivNV := load('glPathParameterivNV');
  glPathParameteriNV := load('glPathParameteriNV');
  glPathParameterfvNV := load('glPathParameterfvNV');
  glPathParameterfNV := load('glPathParameterfNV');
  glPathDashArrayNV := load('glPathDashArrayNV');
  glPathStencilFuncNV := load('glPathStencilFuncNV');
  glPathStencilDepthOffsetNV := load('glPathStencilDepthOffsetNV');
  glStencilFillPathNV := load('glStencilFillPathNV');
  glStencilStrokePathNV := load('glStencilStrokePathNV');
  glStencilFillPathInstancedNV := load('glStencilFillPathInstancedNV');
  glStencilStrokePathInstancedNV := load('glStencilStrokePathInstancedNV');
  glPathCoverDepthFuncNV := load('glPathCoverDepthFuncNV');
  glCoverFillPathNV := load('glCoverFillPathNV');
  glCoverStrokePathNV := load('glCoverStrokePathNV');
  glCoverFillPathInstancedNV := load('glCoverFillPathInstancedNV');
  glCoverStrokePathInstancedNV := load('glCoverStrokePathInstancedNV');
  glGetPathParameterivNV := load('glGetPathParameterivNV');
  glGetPathParameterfvNV := load('glGetPathParameterfvNV');
  glGetPathCommandsNV := load('glGetPathCommandsNV');
  glGetPathCoordsNV := load('glGetPathCoordsNV');
  glGetPathDashArrayNV := load('glGetPathDashArrayNV');
  glGetPathMetricsNV := load('glGetPathMetricsNV');
  glGetPathMetricRangeNV := load('glGetPathMetricRangeNV');
  glGetPathSpacingNV := load('glGetPathSpacingNV');
  glIsPointInFillPathNV := load('glIsPointInFillPathNV');
  glIsPointInStrokePathNV := load('glIsPointInStrokePathNV');
  glGetPathLengthNV := load('glGetPathLengthNV');
  glPointAlongPathNV := load('glPointAlongPathNV');
  glMatrixLoad3x2fNV := load('glMatrixLoad3x2fNV');
  glMatrixLoad3x3fNV := load('glMatrixLoad3x3fNV');
  glMatrixLoadTranspose3x3fNV := load('glMatrixLoadTranspose3x3fNV');
  glMatrixMult3x2fNV := load('glMatrixMult3x2fNV');
  glMatrixMult3x3fNV := load('glMatrixMult3x3fNV');
  glMatrixMultTranspose3x3fNV := load('glMatrixMultTranspose3x3fNV');
  glStencilThenCoverFillPathNV := load('glStencilThenCoverFillPathNV');
  glStencilThenCoverStrokePathNV := load('glStencilThenCoverStrokePathNV');
  glStencilThenCoverFillPathInstancedNV := load('glStencilThenCoverFillPathInstancedNV');
  glStencilThenCoverStrokePathInstancedNV := load('glStencilThenCoverStrokePathInstancedNV');
  glPathGlyphIndexRangeNV := load('glPathGlyphIndexRangeNV');
  glPathGlyphIndexArrayNV := load('glPathGlyphIndexArrayNV');
  glPathMemoryGlyphIndexArrayNV := load('glPathMemoryGlyphIndexArrayNV');
  glProgramPathFragmentInputGenNV := load('glProgramPathFragmentInputGenNV');
  glGetProgramResourcefvNV := load('glGetProgramResourcefvNV');
  glPathColorGenNV := load('glPathColorGenNV');
  glPathTexGenNV := load('glPathTexGenNV');
  glPathFogGenNV := load('glPathFogGenNV');
  glGetPathColorGenivNV := load('glGetPathColorGenivNV');
  glGetPathColorGenfvNV := load('glGetPathColorGenfvNV');
  glGetPathTexGenivNV := load('glGetPathTexGenivNV');
  glGetPathTexGenfvNV := load('glGetPathTexGenfvNV');
  glMatrixFrustumEXT := load('glMatrixFrustumEXT');
  glMatrixLoadIdentityEXT := load('glMatrixLoadIdentityEXT');
  glMatrixLoadTransposefEXT := load('glMatrixLoadTransposefEXT');
  glMatrixLoadTransposedEXT := load('glMatrixLoadTransposedEXT');
  glMatrixLoadfEXT := load('glMatrixLoadfEXT');
  glMatrixLoaddEXT := load('glMatrixLoaddEXT');
  glMatrixMultTransposefEXT := load('glMatrixMultTransposefEXT');
  glMatrixMultTransposedEXT := load('glMatrixMultTransposedEXT');
  glMatrixMultfEXT := load('glMatrixMultfEXT');
  glMatrixMultdEXT := load('glMatrixMultdEXT');
  glMatrixOrthoEXT := load('glMatrixOrthoEXT');
  glMatrixPopEXT := load('glMatrixPopEXT');
  glMatrixPushEXT := load('glMatrixPushEXT');
  glMatrixRotatefEXT := load('glMatrixRotatefEXT');
  glMatrixRotatedEXT := load('glMatrixRotatedEXT');
  glMatrixScalefEXT := load('glMatrixScalefEXT');
  glMatrixScaledEXT := load('glMatrixScaledEXT');
  glMatrixTranslatefEXT := load('glMatrixTranslatefEXT');
  glMatrixTranslatedEXT := load('glMatrixTranslatedEXT');
end;

procedure load_GL_NV_polygon_mode(load: TLoadProc);
begin
  if not GLAD_GL_NV_polygon_mode then exit;
  glPolygonModeNV := load('glPolygonModeNV');
end;

procedure load_GL_NV_read_buffer(load: TLoadProc);
begin
  if not GLAD_GL_NV_read_buffer then exit;
  glReadBufferNV := load('glReadBufferNV');
end;

procedure load_GL_NV_sample_locations(load: TLoadProc);
begin
  if not GLAD_GL_NV_sample_locations then exit;
  glFramebufferSampleLocationsfvNV := load('glFramebufferSampleLocationsfvNV');
  glNamedFramebufferSampleLocationsfvNV := load('glNamedFramebufferSampleLocationsfvNV');
  glResolveDepthValuesNV := load('glResolveDepthValuesNV');
end;

procedure load_GL_NV_scissor_exclusive(load: TLoadProc);
begin
  if not GLAD_GL_NV_scissor_exclusive then exit;
  glScissorExclusiveNV := load('glScissorExclusiveNV');
  glScissorExclusiveArrayvNV := load('glScissorExclusiveArrayvNV');
end;

procedure load_GL_NV_shading_rate_image(load: TLoadProc);
begin
  if not GLAD_GL_NV_shading_rate_image then exit;
  glBindShadingRateImageNV := load('glBindShadingRateImageNV');
  glGetShadingRateImagePaletteNV := load('glGetShadingRateImagePaletteNV');
  glGetShadingRateSampleLocationivNV := load('glGetShadingRateSampleLocationivNV');
  glShadingRateImageBarrierNV := load('glShadingRateImageBarrierNV');
  glShadingRateImagePaletteNV := load('glShadingRateImagePaletteNV');
  glShadingRateSampleOrderNV := load('glShadingRateSampleOrderNV');
  glShadingRateSampleOrderCustomNV := load('glShadingRateSampleOrderCustomNV');
end;

procedure load_GL_NV_timeline_semaphore(load: TLoadProc);
begin
  if not GLAD_GL_NV_timeline_semaphore then exit;
  glCreateSemaphoresNV := load('glCreateSemaphoresNV');
  glSemaphoreParameterivNV := load('glSemaphoreParameterivNV');
  glGetSemaphoreParameterivNV := load('glGetSemaphoreParameterivNV');
end;

procedure load_GL_NV_viewport_array(load: TLoadProc);
begin
  if not GLAD_GL_NV_viewport_array then exit;
  glViewportArrayvNV := load('glViewportArrayvNV');
  glViewportIndexedfNV := load('glViewportIndexedfNV');
  glViewportIndexedfvNV := load('glViewportIndexedfvNV');
  glScissorArrayvNV := load('glScissorArrayvNV');
  glScissorIndexedNV := load('glScissorIndexedNV');
  glScissorIndexedvNV := load('glScissorIndexedvNV');
  glDepthRangeArrayfvNV := load('glDepthRangeArrayfvNV');
  glDepthRangeIndexedfNV := load('glDepthRangeIndexedfNV');
  glGetFloati_vNV := load('glGetFloati_vNV');
  glEnableiNV := load('glEnableiNV');
  glDisableiNV := load('glDisableiNV');
  glIsEnablediNV := load('glIsEnablediNV');
end;

procedure load_GL_NV_viewport_swizzle(load: TLoadProc);
begin
  if not GLAD_GL_NV_viewport_swizzle then exit;
  glViewportSwizzleNV := load('glViewportSwizzleNV');
end;

procedure load_GL_OES_EGL_image(load: TLoadProc);
begin
  if not GLAD_GL_OES_EGL_image then exit;
  glEGLImageTargetTexture2DOES := load('glEGLImageTargetTexture2DOES');
  glEGLImageTargetRenderbufferStorageOES := load('glEGLImageTargetRenderbufferStorageOES');
end;

procedure load_GL_OES_copy_image(load: TLoadProc);
begin
  if not GLAD_GL_OES_copy_image then exit;
  glCopyImageSubDataOES := load('glCopyImageSubDataOES');
end;

procedure load_GL_OES_draw_buffers_indexed(load: TLoadProc);
begin
  if not GLAD_GL_OES_draw_buffers_indexed then exit;
  glEnableiOES := load('glEnableiOES');
  glDisableiOES := load('glDisableiOES');
  glBlendEquationiOES := load('glBlendEquationiOES');
  glBlendEquationSeparateiOES := load('glBlendEquationSeparateiOES');
  glBlendFunciOES := load('glBlendFunciOES');
  glBlendFuncSeparateiOES := load('glBlendFuncSeparateiOES');
  glColorMaskiOES := load('glColorMaskiOES');
  glIsEnablediOES := load('glIsEnablediOES');
end;

procedure load_GL_OES_draw_elements_base_vertex(load: TLoadProc);
begin
  if not GLAD_GL_OES_draw_elements_base_vertex then exit;
  glDrawElementsBaseVertexOES := load('glDrawElementsBaseVertexOES');
  glDrawRangeElementsBaseVertexOES := load('glDrawRangeElementsBaseVertexOES');
  glDrawElementsInstancedBaseVertexOES := load('glDrawElementsInstancedBaseVertexOES');
  glMultiDrawElementsBaseVertexEXT := load('glMultiDrawElementsBaseVertexEXT');
end;

procedure load_GL_OES_geometry_shader(load: TLoadProc);
begin
  if not GLAD_GL_OES_geometry_shader then exit;
  glFramebufferTextureOES := load('glFramebufferTextureOES');
end;

procedure load_GL_OES_get_program_binary(load: TLoadProc);
begin
  if not GLAD_GL_OES_get_program_binary then exit;
  glGetProgramBinaryOES := load('glGetProgramBinaryOES');
  glProgramBinaryOES := load('glProgramBinaryOES');
end;

procedure load_GL_OES_mapbuffer(load: TLoadProc);
begin
  if not GLAD_GL_OES_mapbuffer then exit;
  glMapBufferOES := load('glMapBufferOES');
  glUnmapBufferOES := load('glUnmapBufferOES');
  glGetBufferPointervOES := load('glGetBufferPointervOES');
end;

procedure load_GL_OES_primitive_bounding_box(load: TLoadProc);
begin
  if not GLAD_GL_OES_primitive_bounding_box then exit;
  glPrimitiveBoundingBoxOES := load('glPrimitiveBoundingBoxOES');
end;

procedure load_GL_OES_sample_shading(load: TLoadProc);
begin
  if not GLAD_GL_OES_sample_shading then exit;
  glMinSampleShadingOES := load('glMinSampleShadingOES');
end;

procedure load_GL_OES_tessellation_shader(load: TLoadProc);
begin
  if not GLAD_GL_OES_tessellation_shader then exit;
  glPatchParameteriOES := load('glPatchParameteriOES');
end;

procedure load_GL_OES_texture_3D(load: TLoadProc);
begin
  if not GLAD_GL_OES_texture_3D then exit;
  glTexImage3DOES := load('glTexImage3DOES');
  glTexSubImage3DOES := load('glTexSubImage3DOES');
  glCopyTexSubImage3DOES := load('glCopyTexSubImage3DOES');
  glCompressedTexImage3DOES := load('glCompressedTexImage3DOES');
  glCompressedTexSubImage3DOES := load('glCompressedTexSubImage3DOES');
  glFramebufferTexture3DOES := load('glFramebufferTexture3DOES');
end;

procedure load_GL_OES_texture_border_clamp(load: TLoadProc);
begin
  if not GLAD_GL_OES_texture_border_clamp then exit;
  glTexParameterIivOES := load('glTexParameterIivOES');
  glTexParameterIuivOES := load('glTexParameterIuivOES');
  glGetTexParameterIivOES := load('glGetTexParameterIivOES');
  glGetTexParameterIuivOES := load('glGetTexParameterIuivOES');
  glSamplerParameterIivOES := load('glSamplerParameterIivOES');
  glSamplerParameterIuivOES := load('glSamplerParameterIuivOES');
  glGetSamplerParameterIivOES := load('glGetSamplerParameterIivOES');
  glGetSamplerParameterIuivOES := load('glGetSamplerParameterIuivOES');
end;

procedure load_GL_OES_texture_buffer(load: TLoadProc);
begin
  if not GLAD_GL_OES_texture_buffer then exit;
  glTexBufferOES := load('glTexBufferOES');
  glTexBufferRangeOES := load('glTexBufferRangeOES');
end;

procedure load_GL_OES_texture_storage_multisample_2d_array(load: TLoadProc);
begin
  if not GLAD_GL_OES_texture_storage_multisample_2d_array then exit;
  glTexStorage3DMultisampleOES := load('glTexStorage3DMultisampleOES');
end;

procedure load_GL_OES_texture_view(load: TLoadProc);
begin
  if not GLAD_GL_OES_texture_view then exit;
  glTextureViewOES := load('glTextureViewOES');
end;

procedure load_GL_OES_vertex_array_object(load: TLoadProc);
begin
  if not GLAD_GL_OES_vertex_array_object then exit;
  glBindVertexArrayOES := load('glBindVertexArrayOES');
  glDeleteVertexArraysOES := load('glDeleteVertexArraysOES');
  glGenVertexArraysOES := load('glGenVertexArraysOES');
  glIsVertexArrayOES := load('glIsVertexArrayOES');
end;

procedure load_GL_OES_viewport_array(load: TLoadProc);
begin
  if not GLAD_GL_OES_viewport_array then exit;
  glViewportArrayvOES := load('glViewportArrayvOES');
  glViewportIndexedfOES := load('glViewportIndexedfOES');
  glViewportIndexedfvOES := load('glViewportIndexedfvOES');
  glScissorArrayvOES := load('glScissorArrayvOES');
  glScissorIndexedOES := load('glScissorIndexedOES');
  glScissorIndexedvOES := load('glScissorIndexedvOES');
  glDepthRangeArrayfvOES := load('glDepthRangeArrayfvOES');
  glDepthRangeIndexedfOES := load('glDepthRangeIndexedfOES');
  glGetFloati_vOES := load('glGetFloati_vOES');
  glEnableiOES := load('glEnableiOES');
  glDisableiOES := load('glDisableiOES');
  glIsEnablediOES := load('glIsEnablediOES');
end;

procedure load_GL_OVR_multiview(load: TLoadProc);
begin
  if not GLAD_GL_OVR_multiview then exit;
  glFramebufferTextureMultiviewOVR := load('glFramebufferTextureMultiviewOVR');
  glNamedFramebufferTextureMultiviewOVR := load('glNamedFramebufferTextureMultiviewOVR');
end;

procedure load_GL_OVR_multiview_multisampled_render_to_texture(load: TLoadProc);
begin
  if not GLAD_GL_OVR_multiview_multisampled_render_to_texture then exit;
  glFramebufferTextureMultisampleMultiviewOVR := load('glFramebufferTextureMultisampleMultiviewOVR');
end;

procedure load_GL_QCOM_alpha_test(load: TLoadProc);
begin
  if not GLAD_GL_QCOM_alpha_test then exit;
  glAlphaFuncQCOM := load('glAlphaFuncQCOM');
end;

procedure load_GL_QCOM_driver_control(load: TLoadProc);
begin
  if not GLAD_GL_QCOM_driver_control then exit;
  glGetDriverControlsQCOM := load('glGetDriverControlsQCOM');
  glGetDriverControlStringQCOM := load('glGetDriverControlStringQCOM');
  glEnableDriverControlQCOM := load('glEnableDriverControlQCOM');
  glDisableDriverControlQCOM := load('glDisableDriverControlQCOM');
end;

procedure load_GL_QCOM_extended_get(load: TLoadProc);
begin
  if not GLAD_GL_QCOM_extended_get then exit;
  glExtGetTexturesQCOM := load('glExtGetTexturesQCOM');
  glExtGetBuffersQCOM := load('glExtGetBuffersQCOM');
  glExtGetRenderbuffersQCOM := load('glExtGetRenderbuffersQCOM');
  glExtGetFramebuffersQCOM := load('glExtGetFramebuffersQCOM');
  glExtGetTexLevelParameterivQCOM := load('glExtGetTexLevelParameterivQCOM');
  glExtTexObjectStateOverrideiQCOM := load('glExtTexObjectStateOverrideiQCOM');
  glExtGetTexSubImageQCOM := load('glExtGetTexSubImageQCOM');
  glExtGetBufferPointervQCOM := load('glExtGetBufferPointervQCOM');
end;

procedure load_GL_QCOM_extended_get2(load: TLoadProc);
begin
  if not GLAD_GL_QCOM_extended_get2 then exit;
  glExtGetShadersQCOM := load('glExtGetShadersQCOM');
  glExtGetProgramsQCOM := load('glExtGetProgramsQCOM');
  glExtIsProgramBinaryQCOM := load('glExtIsProgramBinaryQCOM');
  glExtGetProgramBinarySourceQCOM := load('glExtGetProgramBinarySourceQCOM');
end;

procedure load_GL_QCOM_frame_extrapolation(load: TLoadProc);
begin
  if not GLAD_GL_QCOM_frame_extrapolation then exit;
  glExtrapolateTex2DQCOM := load('glExtrapolateTex2DQCOM');
end;

procedure load_GL_QCOM_framebuffer_foveated(load: TLoadProc);
begin
  if not GLAD_GL_QCOM_framebuffer_foveated then exit;
  glFramebufferFoveationConfigQCOM := load('glFramebufferFoveationConfigQCOM');
  glFramebufferFoveationParametersQCOM := load('glFramebufferFoveationParametersQCOM');
end;

procedure load_GL_QCOM_motion_estimation(load: TLoadProc);
begin
  if not GLAD_GL_QCOM_motion_estimation then exit;
  glTexEstimateMotionQCOM := load('glTexEstimateMotionQCOM');
  glTexEstimateMotionRegionsQCOM := load('glTexEstimateMotionRegionsQCOM');
end;

procedure load_GL_QCOM_shader_framebuffer_fetch_noncoherent(load: TLoadProc);
begin
  if not GLAD_GL_QCOM_shader_framebuffer_fetch_noncoherent then exit;
  glFramebufferFetchBarrierQCOM := load('glFramebufferFetchBarrierQCOM');
end;

procedure load_GL_QCOM_shading_rate(load: TLoadProc);
begin
  if not GLAD_GL_QCOM_shading_rate then exit;
  glShadingRateQCOM := load('glShadingRateQCOM');
end;

procedure load_GL_QCOM_texture_foveated(load: TLoadProc);
begin
  if not GLAD_GL_QCOM_texture_foveated then exit;
  glTextureFoveationParametersQCOM := load('glTextureFoveationParametersQCOM');
end;

procedure load_GL_QCOM_tiled_rendering(load: TLoadProc);
begin
  if not GLAD_GL_QCOM_tiled_rendering then exit;
  glStartTilingQCOM := load('glStartTilingQCOM');
  glEndTilingQCOM := load('glEndTilingQCOM');
end;

procedure findExtensionsGLES2();
begin
  GLAD_GL_AMD_compressed_3DC_texture := hasExt('GL_AMD_compressed_3DC_texture');
  GLAD_GL_AMD_compressed_ATC_texture := hasExt('GL_AMD_compressed_ATC_texture');
  GLAD_GL_AMD_framebuffer_multisample_advanced := hasExt('GL_AMD_framebuffer_multisample_advanced');
  GLAD_GL_AMD_performance_monitor := hasExt('GL_AMD_performance_monitor');
  GLAD_GL_AMD_program_binary_Z400 := hasExt('GL_AMD_program_binary_Z400');
  GLAD_GL_ANDROID_extension_pack_es31a := hasExt('GL_ANDROID_extension_pack_es31a');
  GLAD_GL_ANGLE_depth_texture := hasExt('GL_ANGLE_depth_texture');
  GLAD_GL_ANGLE_framebuffer_blit := hasExt('GL_ANGLE_framebuffer_blit');
  GLAD_GL_ANGLE_framebuffer_multisample := hasExt('GL_ANGLE_framebuffer_multisample');
  GLAD_GL_ANGLE_instanced_arrays := hasExt('GL_ANGLE_instanced_arrays');
  GLAD_GL_ANGLE_pack_reverse_row_order := hasExt('GL_ANGLE_pack_reverse_row_order');
  GLAD_GL_ANGLE_program_binary := hasExt('GL_ANGLE_program_binary');
  GLAD_GL_ANGLE_texture_compression_dxt3 := hasExt('GL_ANGLE_texture_compression_dxt3');
  GLAD_GL_ANGLE_texture_compression_dxt5 := hasExt('GL_ANGLE_texture_compression_dxt5');
  GLAD_GL_ANGLE_texture_usage := hasExt('GL_ANGLE_texture_usage');
  GLAD_GL_ANGLE_translated_shader_source := hasExt('GL_ANGLE_translated_shader_source');
  GLAD_GL_APPLE_clip_distance := hasExt('GL_APPLE_clip_distance');
  GLAD_GL_APPLE_color_buffer_packed_float := hasExt('GL_APPLE_color_buffer_packed_float');
  GLAD_GL_APPLE_copy_texture_levels := hasExt('GL_APPLE_copy_texture_levels');
  GLAD_GL_APPLE_framebuffer_multisample := hasExt('GL_APPLE_framebuffer_multisample');
  GLAD_GL_APPLE_rgb_422 := hasExt('GL_APPLE_rgb_422');
  GLAD_GL_APPLE_sync := hasExt('GL_APPLE_sync');
  GLAD_GL_APPLE_texture_format_BGRA8888 := hasExt('GL_APPLE_texture_format_BGRA8888');
  GLAD_GL_APPLE_texture_max_level := hasExt('GL_APPLE_texture_max_level');
  GLAD_GL_APPLE_texture_packed_float := hasExt('GL_APPLE_texture_packed_float');
  GLAD_GL_ARM_mali_program_binary := hasExt('GL_ARM_mali_program_binary');
  GLAD_GL_ARM_mali_shader_binary := hasExt('GL_ARM_mali_shader_binary');
  GLAD_GL_ARM_rgba8 := hasExt('GL_ARM_rgba8');
  GLAD_GL_ARM_shader_core_properties := hasExt('GL_ARM_shader_core_properties');
  GLAD_GL_ARM_shader_framebuffer_fetch := hasExt('GL_ARM_shader_framebuffer_fetch');
  GLAD_GL_ARM_shader_framebuffer_fetch_depth_stencil := hasExt('GL_ARM_shader_framebuffer_fetch_depth_stencil');
  GLAD_GL_ARM_texture_unnormalized_coordinates := hasExt('GL_ARM_texture_unnormalized_coordinates');
  GLAD_GL_DMP_program_binary := hasExt('GL_DMP_program_binary');
  GLAD_GL_DMP_shader_binary := hasExt('GL_DMP_shader_binary');
  GLAD_GL_EXT_EGL_image_array := hasExt('GL_EXT_EGL_image_array');
  GLAD_GL_EXT_EGL_image_storage := hasExt('GL_EXT_EGL_image_storage');
  GLAD_GL_EXT_EGL_image_storage_compression := hasExt('GL_EXT_EGL_image_storage_compression');
  GLAD_GL_EXT_YUV_target := hasExt('GL_EXT_YUV_target');
  GLAD_GL_EXT_base_instance := hasExt('GL_EXT_base_instance');
  GLAD_GL_EXT_blend_func_extended := hasExt('GL_EXT_blend_func_extended');
  GLAD_GL_EXT_blend_minmax := hasExt('GL_EXT_blend_minmax');
  GLAD_GL_EXT_buffer_storage := hasExt('GL_EXT_buffer_storage');
  GLAD_GL_EXT_clear_texture := hasExt('GL_EXT_clear_texture');
  GLAD_GL_EXT_clip_control := hasExt('GL_EXT_clip_control');
  GLAD_GL_EXT_clip_cull_distance := hasExt('GL_EXT_clip_cull_distance');
  GLAD_GL_EXT_color_buffer_float := hasExt('GL_EXT_color_buffer_float');
  GLAD_GL_EXT_color_buffer_half_float := hasExt('GL_EXT_color_buffer_half_float');
  GLAD_GL_EXT_conservative_depth := hasExt('GL_EXT_conservative_depth');
  GLAD_GL_EXT_copy_image := hasExt('GL_EXT_copy_image');
  GLAD_GL_EXT_debug_label := hasExt('GL_EXT_debug_label');
  GLAD_GL_EXT_debug_marker := hasExt('GL_EXT_debug_marker');
  GLAD_GL_EXT_depth_clamp := hasExt('GL_EXT_depth_clamp');
  GLAD_GL_EXT_discard_framebuffer := hasExt('GL_EXT_discard_framebuffer');
  GLAD_GL_EXT_disjoint_timer_query := hasExt('GL_EXT_disjoint_timer_query');
  GLAD_GL_EXT_draw_buffers := hasExt('GL_EXT_draw_buffers');
  GLAD_GL_EXT_draw_buffers_indexed := hasExt('GL_EXT_draw_buffers_indexed');
  GLAD_GL_EXT_draw_elements_base_vertex := hasExt('GL_EXT_draw_elements_base_vertex');
  GLAD_GL_EXT_draw_instanced := hasExt('GL_EXT_draw_instanced');
  GLAD_GL_EXT_draw_transform_feedback := hasExt('GL_EXT_draw_transform_feedback');
  GLAD_GL_EXT_external_buffer := hasExt('GL_EXT_external_buffer');
  GLAD_GL_EXT_float_blend := hasExt('GL_EXT_float_blend');
  GLAD_GL_EXT_fragment_shading_rate := hasExt('GL_EXT_fragment_shading_rate');
  GLAD_GL_EXT_framebuffer_blit_layers := hasExt('GL_EXT_framebuffer_blit_layers');
  GLAD_GL_EXT_geometry_point_size := hasExt('GL_EXT_geometry_point_size');
  GLAD_GL_EXT_geometry_shader := hasExt('GL_EXT_geometry_shader');
  GLAD_GL_EXT_gpu_shader5 := hasExt('GL_EXT_gpu_shader5');
  GLAD_GL_EXT_instanced_arrays := hasExt('GL_EXT_instanced_arrays');
  GLAD_GL_EXT_map_buffer_range := hasExt('GL_EXT_map_buffer_range');
  GLAD_GL_EXT_memory_object := hasExt('GL_EXT_memory_object');
  GLAD_GL_EXT_memory_object_fd := hasExt('GL_EXT_memory_object_fd');
  GLAD_GL_EXT_memory_object_win32 := hasExt('GL_EXT_memory_object_win32');
  GLAD_GL_EXT_multi_draw_arrays := hasExt('GL_EXT_multi_draw_arrays');
  GLAD_GL_EXT_multi_draw_indirect := hasExt('GL_EXT_multi_draw_indirect');
  GLAD_GL_EXT_multisampled_compatibility := hasExt('GL_EXT_multisampled_compatibility');
  GLAD_GL_EXT_multisampled_render_to_texture := hasExt('GL_EXT_multisampled_render_to_texture');
  GLAD_GL_EXT_multisampled_render_to_texture2 := hasExt('GL_EXT_multisampled_render_to_texture2');
  GLAD_GL_EXT_multiview_draw_buffers := hasExt('GL_EXT_multiview_draw_buffers');
  GLAD_GL_EXT_multiview_tessellation_geometry_shader := hasExt('GL_EXT_multiview_tessellation_geometry_shader');
  GLAD_GL_EXT_multiview_texture_multisample := hasExt('GL_EXT_multiview_texture_multisample');
  GLAD_GL_EXT_multiview_timer_query := hasExt('GL_EXT_multiview_timer_query');
  GLAD_GL_EXT_occlusion_query_boolean := hasExt('GL_EXT_occlusion_query_boolean');
  GLAD_GL_EXT_polygon_offset_clamp := hasExt('GL_EXT_polygon_offset_clamp');
  GLAD_GL_EXT_post_depth_coverage := hasExt('GL_EXT_post_depth_coverage');
  GLAD_GL_EXT_primitive_bounding_box := hasExt('GL_EXT_primitive_bounding_box');
  GLAD_GL_EXT_protected_textures := hasExt('GL_EXT_protected_textures');
  GLAD_GL_EXT_pvrtc_sRGB := hasExt('GL_EXT_pvrtc_sRGB');
  GLAD_GL_EXT_raster_multisample := hasExt('GL_EXT_raster_multisample');
  GLAD_GL_EXT_read_format_bgra := hasExt('GL_EXT_read_format_bgra');
  GLAD_GL_EXT_render_snorm := hasExt('GL_EXT_render_snorm');
  GLAD_GL_EXT_robustness := hasExt('GL_EXT_robustness');
  GLAD_GL_EXT_sRGB := hasExt('GL_EXT_sRGB');
  GLAD_GL_EXT_sRGB_write_control := hasExt('GL_EXT_sRGB_write_control');
  GLAD_GL_EXT_semaphore := hasExt('GL_EXT_semaphore');
  GLAD_GL_EXT_semaphore_fd := hasExt('GL_EXT_semaphore_fd');
  GLAD_GL_EXT_semaphore_win32 := hasExt('GL_EXT_semaphore_win32');
  GLAD_GL_EXT_separate_depth_stencil := hasExt('GL_EXT_separate_depth_stencil');
  GLAD_GL_EXT_separate_shader_objects := hasExt('GL_EXT_separate_shader_objects');
  GLAD_GL_EXT_shader_framebuffer_fetch := hasExt('GL_EXT_shader_framebuffer_fetch');
  GLAD_GL_EXT_shader_framebuffer_fetch_non_coherent := hasExt('GL_EXT_shader_framebuffer_fetch_non_coherent');
  GLAD_GL_EXT_shader_group_vote := hasExt('GL_EXT_shader_group_vote');
  GLAD_GL_EXT_shader_implicit_conversions := hasExt('GL_EXT_shader_implicit_conversions');
  GLAD_GL_EXT_shader_integer_mix := hasExt('GL_EXT_shader_integer_mix');
  GLAD_GL_EXT_shader_io_blocks := hasExt('GL_EXT_shader_io_blocks');
  GLAD_GL_EXT_shader_non_constant_global_initializers := hasExt('GL_EXT_shader_non_constant_global_initializers');
  GLAD_GL_EXT_shader_pixel_local_storage := hasExt('GL_EXT_shader_pixel_local_storage');
  GLAD_GL_EXT_shader_pixel_local_storage2 := hasExt('GL_EXT_shader_pixel_local_storage2');
  GLAD_GL_EXT_shader_samples_identical := hasExt('GL_EXT_shader_samples_identical');
  GLAD_GL_EXT_shader_texture_lod := hasExt('GL_EXT_shader_texture_lod');
  GLAD_GL_EXT_shadow_samplers := hasExt('GL_EXT_shadow_samplers');
  GLAD_GL_EXT_sparse_texture := hasExt('GL_EXT_sparse_texture');
  GLAD_GL_EXT_sparse_texture2 := hasExt('GL_EXT_sparse_texture2');
  GLAD_GL_EXT_tessellation_point_size := hasExt('GL_EXT_tessellation_point_size');
  GLAD_GL_EXT_tessellation_shader := hasExt('GL_EXT_tessellation_shader');
  GLAD_GL_EXT_texture_border_clamp := hasExt('GL_EXT_texture_border_clamp');
  GLAD_GL_EXT_texture_buffer := hasExt('GL_EXT_texture_buffer');
  GLAD_GL_EXT_texture_compression_astc_decode_mode := hasExt('GL_EXT_texture_compression_astc_decode_mode');
  GLAD_GL_EXT_texture_compression_bptc := hasExt('GL_EXT_texture_compression_bptc');
  GLAD_GL_EXT_texture_compression_dxt1 := hasExt('GL_EXT_texture_compression_dxt1');
  GLAD_GL_EXT_texture_compression_rgtc := hasExt('GL_EXT_texture_compression_rgtc');
  GLAD_GL_EXT_texture_compression_s3tc := hasExt('GL_EXT_texture_compression_s3tc');
  GLAD_GL_EXT_texture_compression_s3tc_srgb := hasExt('GL_EXT_texture_compression_s3tc_srgb');
  GLAD_GL_EXT_texture_cube_map_array := hasExt('GL_EXT_texture_cube_map_array');
  GLAD_GL_EXT_texture_filter_anisotropic := hasExt('GL_EXT_texture_filter_anisotropic');
  GLAD_GL_EXT_texture_filter_minmax := hasExt('GL_EXT_texture_filter_minmax');
  GLAD_GL_EXT_texture_format_BGRA8888 := hasExt('GL_EXT_texture_format_BGRA8888');
  GLAD_GL_EXT_texture_format_sRGB_override := hasExt('GL_EXT_texture_format_sRGB_override');
  GLAD_GL_EXT_texture_mirror_clamp_to_edge := hasExt('GL_EXT_texture_mirror_clamp_to_edge');
  GLAD_GL_EXT_texture_norm16 := hasExt('GL_EXT_texture_norm16');
  GLAD_GL_EXT_texture_query_lod := hasExt('GL_EXT_texture_query_lod');
  GLAD_GL_EXT_texture_rg := hasExt('GL_EXT_texture_rg');
  GLAD_GL_EXT_texture_sRGB_R8 := hasExt('GL_EXT_texture_sRGB_R8');
  GLAD_GL_EXT_texture_sRGB_RG8 := hasExt('GL_EXT_texture_sRGB_RG8');
  GLAD_GL_EXT_texture_sRGB_decode := hasExt('GL_EXT_texture_sRGB_decode');
  GLAD_GL_EXT_texture_shadow_lod := hasExt('GL_EXT_texture_shadow_lod');
  GLAD_GL_EXT_texture_storage := hasExt('GL_EXT_texture_storage');
  GLAD_GL_EXT_texture_storage_compression := hasExt('GL_EXT_texture_storage_compression');
  GLAD_GL_EXT_texture_type_2_10_10_10_REV := hasExt('GL_EXT_texture_type_2_10_10_10_REV');
  GLAD_GL_EXT_texture_view := hasExt('GL_EXT_texture_view');
  GLAD_GL_EXT_unpack_subimage := hasExt('GL_EXT_unpack_subimage');
  GLAD_GL_EXT_win32_keyed_mutex := hasExt('GL_EXT_win32_keyed_mutex');
  GLAD_GL_EXT_window_rectangles := hasExt('GL_EXT_window_rectangles');
  GLAD_GL_FJ_shader_binary_GCCSO := hasExt('GL_FJ_shader_binary_GCCSO');
  GLAD_GL_IMG_bindless_texture := hasExt('GL_IMG_bindless_texture');
  GLAD_GL_IMG_framebuffer_downsample := hasExt('GL_IMG_framebuffer_downsample');
  GLAD_GL_IMG_multisampled_render_to_texture := hasExt('GL_IMG_multisampled_render_to_texture');
  GLAD_GL_IMG_program_binary := hasExt('GL_IMG_program_binary');
  GLAD_GL_IMG_read_format := hasExt('GL_IMG_read_format');
  GLAD_GL_IMG_shader_binary := hasExt('GL_IMG_shader_binary');
  GLAD_GL_IMG_texture_compression_pvrtc := hasExt('GL_IMG_texture_compression_pvrtc');
  GLAD_GL_IMG_texture_compression_pvrtc2 := hasExt('GL_IMG_texture_compression_pvrtc2');
  GLAD_GL_IMG_texture_filter_cubic := hasExt('GL_IMG_texture_filter_cubic');
  GLAD_GL_INTEL_blackhole_render := hasExt('GL_INTEL_blackhole_render');
  GLAD_GL_INTEL_conservative_rasterization := hasExt('GL_INTEL_conservative_rasterization');
  GLAD_GL_INTEL_framebuffer_CMAA := hasExt('GL_INTEL_framebuffer_CMAA');
  GLAD_GL_INTEL_performance_query := hasExt('GL_INTEL_performance_query');
  GLAD_GL_KHR_blend_equation_advanced := hasExt('GL_KHR_blend_equation_advanced');
  GLAD_GL_KHR_blend_equation_advanced_coherent := hasExt('GL_KHR_blend_equation_advanced_coherent');
  GLAD_GL_KHR_context_flush_control := hasExt('GL_KHR_context_flush_control');
  GLAD_GL_KHR_debug := hasExt('GL_KHR_debug');
  GLAD_GL_KHR_no_error := hasExt('GL_KHR_no_error');
  GLAD_GL_KHR_parallel_shader_compile := hasExt('GL_KHR_parallel_shader_compile');
  GLAD_GL_KHR_robust_buffer_access_behavior := hasExt('GL_KHR_robust_buffer_access_behavior');
  GLAD_GL_KHR_robustness := hasExt('GL_KHR_robustness');
  GLAD_GL_KHR_shader_subgroup := hasExt('GL_KHR_shader_subgroup');
  GLAD_GL_KHR_texture_compression_astc_hdr := hasExt('GL_KHR_texture_compression_astc_hdr');
  GLAD_GL_KHR_texture_compression_astc_ldr := hasExt('GL_KHR_texture_compression_astc_ldr');
  GLAD_GL_KHR_texture_compression_astc_sliced_3d := hasExt('GL_KHR_texture_compression_astc_sliced_3d');
  GLAD_GL_MESA_bgra := hasExt('GL_MESA_bgra');
  GLAD_GL_MESA_framebuffer_flip_x := hasExt('GL_MESA_framebuffer_flip_x');
  GLAD_GL_MESA_framebuffer_flip_y := hasExt('GL_MESA_framebuffer_flip_y');
  GLAD_GL_MESA_framebuffer_swap_xy := hasExt('GL_MESA_framebuffer_swap_xy');
  GLAD_GL_MESA_program_binary_formats := hasExt('GL_MESA_program_binary_formats');
  GLAD_GL_MESA_sampler_objects := hasExt('GL_MESA_sampler_objects');
  GLAD_GL_MESA_shader_integer_functions := hasExt('GL_MESA_shader_integer_functions');
  GLAD_GL_NVX_blend_equation_advanced_multi_draw_buffers := hasExt('GL_NVX_blend_equation_advanced_multi_draw_buffers');
  GLAD_GL_NV_bindless_texture := hasExt('GL_NV_bindless_texture');
  GLAD_GL_NV_blend_equation_advanced := hasExt('GL_NV_blend_equation_advanced');
  GLAD_GL_NV_blend_equation_advanced_coherent := hasExt('GL_NV_blend_equation_advanced_coherent');
  GLAD_GL_NV_blend_minmax_factor := hasExt('GL_NV_blend_minmax_factor');
  GLAD_GL_NV_clip_space_w_scaling := hasExt('GL_NV_clip_space_w_scaling');
  GLAD_GL_NV_compute_shader_derivatives := hasExt('GL_NV_compute_shader_derivatives');
  GLAD_GL_NV_conditional_render := hasExt('GL_NV_conditional_render');
  GLAD_GL_NV_conservative_raster := hasExt('GL_NV_conservative_raster');
  GLAD_GL_NV_conservative_raster_pre_snap := hasExt('GL_NV_conservative_raster_pre_snap');
  GLAD_GL_NV_conservative_raster_pre_snap_triangles := hasExt('GL_NV_conservative_raster_pre_snap_triangles');
  GLAD_GL_NV_copy_buffer := hasExt('GL_NV_copy_buffer');
  GLAD_GL_NV_coverage_sample := hasExt('GL_NV_coverage_sample');
  GLAD_GL_NV_depth_nonlinear := hasExt('GL_NV_depth_nonlinear');
  GLAD_GL_NV_draw_buffers := hasExt('GL_NV_draw_buffers');
  GLAD_GL_NV_draw_instanced := hasExt('GL_NV_draw_instanced');
  GLAD_GL_NV_draw_vulkan_image := hasExt('GL_NV_draw_vulkan_image');
  GLAD_GL_NV_explicit_attrib_location := hasExt('GL_NV_explicit_attrib_location');
  GLAD_GL_NV_fbo_color_attachments := hasExt('GL_NV_fbo_color_attachments');
  GLAD_GL_NV_fence := hasExt('GL_NV_fence');
  GLAD_GL_NV_fill_rectangle := hasExt('GL_NV_fill_rectangle');
  GLAD_GL_NV_fragment_coverage_to_color := hasExt('GL_NV_fragment_coverage_to_color');
  GLAD_GL_NV_fragment_shader_barycentric := hasExt('GL_NV_fragment_shader_barycentric');
  GLAD_GL_NV_fragment_shader_interlock := hasExt('GL_NV_fragment_shader_interlock');
  GLAD_GL_NV_framebuffer_blit := hasExt('GL_NV_framebuffer_blit');
  GLAD_GL_NV_framebuffer_mixed_samples := hasExt('GL_NV_framebuffer_mixed_samples');
  GLAD_GL_NV_framebuffer_multisample := hasExt('GL_NV_framebuffer_multisample');
  GLAD_GL_NV_generate_mipmap_sRGB := hasExt('GL_NV_generate_mipmap_sRGB');
  GLAD_GL_NV_geometry_shader_passthrough := hasExt('GL_NV_geometry_shader_passthrough');
  GLAD_GL_NV_gpu_shader5 := hasExt('GL_NV_gpu_shader5');
  GLAD_GL_NV_image_formats := hasExt('GL_NV_image_formats');
  GLAD_GL_NV_instanced_arrays := hasExt('GL_NV_instanced_arrays');
  GLAD_GL_NV_internalformat_sample_query := hasExt('GL_NV_internalformat_sample_query');
  GLAD_GL_NV_memory_attachment := hasExt('GL_NV_memory_attachment');
  GLAD_GL_NV_memory_object_sparse := hasExt('GL_NV_memory_object_sparse');
  GLAD_GL_NV_mesh_shader := hasExt('GL_NV_mesh_shader');
  GLAD_GL_NV_non_square_matrices := hasExt('GL_NV_non_square_matrices');
  GLAD_GL_NV_pack_subimage := hasExt('GL_NV_pack_subimage');
  GLAD_GL_NV_path_rendering := hasExt('GL_NV_path_rendering');
  GLAD_GL_NV_path_rendering_shared_edge := hasExt('GL_NV_path_rendering_shared_edge');
  GLAD_GL_NV_pixel_buffer_object := hasExt('GL_NV_pixel_buffer_object');
  GLAD_GL_NV_polygon_mode := hasExt('GL_NV_polygon_mode');
  GLAD_GL_NV_primitive_shading_rate := hasExt('GL_NV_primitive_shading_rate');
  GLAD_GL_NV_read_buffer := hasExt('GL_NV_read_buffer');
  GLAD_GL_NV_read_buffer_front := hasExt('GL_NV_read_buffer_front');
  GLAD_GL_NV_read_depth := hasExt('GL_NV_read_depth');
  GLAD_GL_NV_read_depth_stencil := hasExt('GL_NV_read_depth_stencil');
  GLAD_GL_NV_read_stencil := hasExt('GL_NV_read_stencil');
  GLAD_GL_NV_representative_fragment_test := hasExt('GL_NV_representative_fragment_test');
  GLAD_GL_NV_sRGB_formats := hasExt('GL_NV_sRGB_formats');
  GLAD_GL_NV_sample_locations := hasExt('GL_NV_sample_locations');
  GLAD_GL_NV_sample_mask_override_coverage := hasExt('GL_NV_sample_mask_override_coverage');
  GLAD_GL_NV_scissor_exclusive := hasExt('GL_NV_scissor_exclusive');
  GLAD_GL_NV_shader_atomic_fp16_vector := hasExt('GL_NV_shader_atomic_fp16_vector');
  GLAD_GL_NV_shader_noperspective_interpolation := hasExt('GL_NV_shader_noperspective_interpolation');
  GLAD_GL_NV_shader_subgroup_partitioned := hasExt('GL_NV_shader_subgroup_partitioned');
  GLAD_GL_NV_shader_texture_footprint := hasExt('GL_NV_shader_texture_footprint');
  GLAD_GL_NV_shading_rate_image := hasExt('GL_NV_shading_rate_image');
  GLAD_GL_NV_shadow_samplers_array := hasExt('GL_NV_shadow_samplers_array');
  GLAD_GL_NV_shadow_samplers_cube := hasExt('GL_NV_shadow_samplers_cube');
  GLAD_GL_NV_stereo_view_rendering := hasExt('GL_NV_stereo_view_rendering');
  GLAD_GL_NV_texture_border_clamp := hasExt('GL_NV_texture_border_clamp');
  GLAD_GL_NV_texture_compression_s3tc_update := hasExt('GL_NV_texture_compression_s3tc_update');
  GLAD_GL_NV_texture_npot_2D_mipmap := hasExt('GL_NV_texture_npot_2D_mipmap');
  GLAD_GL_NV_timeline_semaphore := hasExt('GL_NV_timeline_semaphore');
  GLAD_GL_NV_viewport_array := hasExt('GL_NV_viewport_array');
  GLAD_GL_NV_viewport_array2 := hasExt('GL_NV_viewport_array2');
  GLAD_GL_NV_viewport_swizzle := hasExt('GL_NV_viewport_swizzle');
  GLAD_GL_OES_EGL_image := hasExt('GL_OES_EGL_image');
  GLAD_GL_OES_EGL_image_external := hasExt('GL_OES_EGL_image_external');
  GLAD_GL_OES_EGL_image_external_essl3 := hasExt('GL_OES_EGL_image_external_essl3');
  GLAD_GL_OES_compressed_ETC1_RGB8_sub_texture := hasExt('GL_OES_compressed_ETC1_RGB8_sub_texture');
  GLAD_GL_OES_compressed_ETC1_RGB8_texture := hasExt('GL_OES_compressed_ETC1_RGB8_texture');
  GLAD_GL_OES_compressed_paletted_texture := hasExt('GL_OES_compressed_paletted_texture');
  GLAD_GL_OES_copy_image := hasExt('GL_OES_copy_image');
  GLAD_GL_OES_depth24 := hasExt('GL_OES_depth24');
  GLAD_GL_OES_depth32 := hasExt('GL_OES_depth32');
  GLAD_GL_OES_depth_texture := hasExt('GL_OES_depth_texture');
  GLAD_GL_OES_draw_buffers_indexed := hasExt('GL_OES_draw_buffers_indexed');
  GLAD_GL_OES_draw_elements_base_vertex := hasExt('GL_OES_draw_elements_base_vertex');
  GLAD_GL_OES_element_index_uint := hasExt('GL_OES_element_index_uint');
  GLAD_GL_OES_fbo_render_mipmap := hasExt('GL_OES_fbo_render_mipmap');
  GLAD_GL_OES_fragment_precision_high := hasExt('GL_OES_fragment_precision_high');
  GLAD_GL_OES_geometry_point_size := hasExt('GL_OES_geometry_point_size');
  GLAD_GL_OES_geometry_shader := hasExt('GL_OES_geometry_shader');
  GLAD_GL_OES_get_program_binary := hasExt('GL_OES_get_program_binary');
  GLAD_GL_OES_gpu_shader5 := hasExt('GL_OES_gpu_shader5');
  GLAD_GL_OES_mapbuffer := hasExt('GL_OES_mapbuffer');
  GLAD_GL_OES_packed_depth_stencil := hasExt('GL_OES_packed_depth_stencil');
  GLAD_GL_OES_primitive_bounding_box := hasExt('GL_OES_primitive_bounding_box');
  GLAD_GL_OES_required_internalformat := hasExt('GL_OES_required_internalformat');
  GLAD_GL_OES_rgb8_rgba8 := hasExt('GL_OES_rgb8_rgba8');
  GLAD_GL_OES_sample_shading := hasExt('GL_OES_sample_shading');
  GLAD_GL_OES_sample_variables := hasExt('GL_OES_sample_variables');
  GLAD_GL_OES_shader_image_atomic := hasExt('GL_OES_shader_image_atomic');
  GLAD_GL_OES_shader_io_blocks := hasExt('GL_OES_shader_io_blocks');
  GLAD_GL_OES_shader_multisample_interpolation := hasExt('GL_OES_shader_multisample_interpolation');
  GLAD_GL_OES_standard_derivatives := hasExt('GL_OES_standard_derivatives');
  GLAD_GL_OES_stencil1 := hasExt('GL_OES_stencil1');
  GLAD_GL_OES_stencil4 := hasExt('GL_OES_stencil4');
  GLAD_GL_OES_surfaceless_context := hasExt('GL_OES_surfaceless_context');
  GLAD_GL_OES_tessellation_point_size := hasExt('GL_OES_tessellation_point_size');
  GLAD_GL_OES_tessellation_shader := hasExt('GL_OES_tessellation_shader');
  GLAD_GL_OES_texture_3D := hasExt('GL_OES_texture_3D');
  GLAD_GL_OES_texture_border_clamp := hasExt('GL_OES_texture_border_clamp');
  GLAD_GL_OES_texture_buffer := hasExt('GL_OES_texture_buffer');
  GLAD_GL_OES_texture_compression_astc := hasExt('GL_OES_texture_compression_astc');
  GLAD_GL_OES_texture_cube_map_array := hasExt('GL_OES_texture_cube_map_array');
  GLAD_GL_OES_texture_float := hasExt('GL_OES_texture_float');
  GLAD_GL_OES_texture_float_linear := hasExt('GL_OES_texture_float_linear');
  GLAD_GL_OES_texture_half_float := hasExt('GL_OES_texture_half_float');
  GLAD_GL_OES_texture_half_float_linear := hasExt('GL_OES_texture_half_float_linear');
  GLAD_GL_OES_texture_npot := hasExt('GL_OES_texture_npot');
  GLAD_GL_OES_texture_stencil8 := hasExt('GL_OES_texture_stencil8');
  GLAD_GL_OES_texture_storage_multisample_2d_array := hasExt('GL_OES_texture_storage_multisample_2d_array');
  GLAD_GL_OES_texture_view := hasExt('GL_OES_texture_view');
  GLAD_GL_OES_vertex_array_object := hasExt('GL_OES_vertex_array_object');
  GLAD_GL_OES_vertex_half_float := hasExt('GL_OES_vertex_half_float');
  GLAD_GL_OES_vertex_type_10_10_10_2 := hasExt('GL_OES_vertex_type_10_10_10_2');
  GLAD_GL_OES_viewport_array := hasExt('GL_OES_viewport_array');
  GLAD_GL_OVR_multiview := hasExt('GL_OVR_multiview');
  GLAD_GL_OVR_multiview2 := hasExt('GL_OVR_multiview2');
  GLAD_GL_OVR_multiview_multisampled_render_to_texture := hasExt('GL_OVR_multiview_multisampled_render_to_texture');
  GLAD_GL_QCOM_YUV_texture_gather := hasExt('GL_QCOM_YUV_texture_gather');
  GLAD_GL_QCOM_alpha_test := hasExt('GL_QCOM_alpha_test');
  GLAD_GL_QCOM_binning_control := hasExt('GL_QCOM_binning_control');
  GLAD_GL_QCOM_driver_control := hasExt('GL_QCOM_driver_control');
  GLAD_GL_QCOM_extended_get := hasExt('GL_QCOM_extended_get');
  GLAD_GL_QCOM_extended_get2 := hasExt('GL_QCOM_extended_get2');
  GLAD_GL_QCOM_frame_extrapolation := hasExt('GL_QCOM_frame_extrapolation');
  GLAD_GL_QCOM_framebuffer_foveated := hasExt('GL_QCOM_framebuffer_foveated');
  GLAD_GL_QCOM_motion_estimation := hasExt('GL_QCOM_motion_estimation');
  GLAD_GL_QCOM_perfmon_global_mode := hasExt('GL_QCOM_perfmon_global_mode');
  GLAD_GL_QCOM_render_sRGB_R8_RG8 := hasExt('GL_QCOM_render_sRGB_R8_RG8');
  GLAD_GL_QCOM_render_shared_exponent := hasExt('GL_QCOM_render_shared_exponent');
  GLAD_GL_QCOM_shader_framebuffer_fetch_noncoherent := hasExt('GL_QCOM_shader_framebuffer_fetch_noncoherent');
  GLAD_GL_QCOM_shader_framebuffer_fetch_rate := hasExt('GL_QCOM_shader_framebuffer_fetch_rate');
  GLAD_GL_QCOM_shading_rate := hasExt('GL_QCOM_shading_rate');
  GLAD_GL_QCOM_texture_foveated := hasExt('GL_QCOM_texture_foveated');
  GLAD_GL_QCOM_texture_foveated2 := hasExt('GL_QCOM_texture_foveated2');
  GLAD_GL_QCOM_texture_foveated_subsampled_layout := hasExt('GL_QCOM_texture_foveated_subsampled_layout');
  GLAD_GL_QCOM_texture_lod_bias := hasExt('GL_QCOM_texture_lod_bias');
  GLAD_GL_QCOM_tiled_rendering := hasExt('GL_QCOM_tiled_rendering');
  GLAD_GL_QCOM_writeonly_rendering := hasExt('GL_QCOM_writeonly_rendering');
  GLAD_GL_QCOM_ycbcr_degamma := hasExt('GL_QCOM_ycbcr_degamma');
  GLAD_GL_VIV_shader_binary := hasExt('GL_VIV_shader_binary');
end;

procedure findCoreGLES2(glVersion: string);
{ Thank you @elmindreda
  https://github.com/elmindreda/greg/blob/master/templates/greg.c.in//L176
  https://github.com/glfw/glfw/blob/master/src/context.c//L36 }
const
  prefixes: array[0..2] of string = ('OpenGL ES-CM ', 'OpenGL ES-CL ', 'OpenGL ES ');
var
  version, p: string;
  major, minor: integer;
begin
  version := glVersion;
  for p in prefixes do
    if LeftStr(version, length(p)) = p then begin
      version := StringReplace(version, p, '', [rfReplaceAll]);
      break;
    end;

  major := ord(version[1]) - ord('0');
  minor := ord(version[3]) - ord('0');

  glVersionMajor := major;
  glVersionMinor := minor;

  GLAD_GL_ES_VERSION_2_0 := ((major = 2) and (minor >= 0)) or (major > 2);
  GLAD_GL_ES_VERSION_3_0 := ((major = 3) and (minor >= 0)) or (major > 3);
end;

function gladLoadGLES2(load: TLoadProc): boolean;
var
  glVersion: PAnsiChar;
begin
  glGetString := load('glGetString');  
  if not Assigned(glGetString) then exit(false);
  glVersion := PAnsiChar( glGetString(GL_VERSION) );
  if glVersion = nil then exit(false);

  findCoreGLES2(glVersion);
  load_GL_ES_VERSION_2_0(load);
  load_GL_ES_VERSION_3_0(load);

  findExtensionsGLES2();
  load_GL_AMD_framebuffer_multisample_advanced(load);
  load_GL_AMD_performance_monitor(load);
  load_GL_ANGLE_framebuffer_blit(load);
  load_GL_ANGLE_framebuffer_multisample(load);
  load_GL_ANGLE_instanced_arrays(load);
  load_GL_ANGLE_translated_shader_source(load);
  load_GL_APPLE_copy_texture_levels(load);
  load_GL_APPLE_framebuffer_multisample(load);
  load_GL_APPLE_sync(load);
  load_GL_ARM_shader_core_properties(load);
  load_GL_EXT_EGL_image_storage(load);
  load_GL_EXT_base_instance(load);
  load_GL_EXT_blend_func_extended(load);
  load_GL_EXT_blend_minmax(load);
  load_GL_EXT_buffer_storage(load);
  load_GL_EXT_clear_texture(load);
  load_GL_EXT_clip_control(load);
  load_GL_EXT_copy_image(load);
  load_GL_EXT_debug_label(load);
  load_GL_EXT_debug_marker(load);
  load_GL_EXT_discard_framebuffer(load);
  load_GL_EXT_disjoint_timer_query(load);
  load_GL_EXT_draw_buffers(load);
  load_GL_EXT_draw_buffers_indexed(load);
  load_GL_EXT_draw_elements_base_vertex(load);
  load_GL_EXT_draw_instanced(load);
  load_GL_EXT_draw_transform_feedback(load);
  load_GL_EXT_external_buffer(load);
  load_GL_EXT_fragment_shading_rate(load);
  load_GL_EXT_framebuffer_blit_layers(load);
  load_GL_EXT_geometry_shader(load);
  load_GL_EXT_instanced_arrays(load);
  load_GL_EXT_map_buffer_range(load);
  load_GL_EXT_memory_object(load);
  load_GL_EXT_memory_object_fd(load);
  load_GL_EXT_memory_object_win32(load);
  load_GL_EXT_multi_draw_arrays(load);
  load_GL_EXT_multi_draw_indirect(load);
  load_GL_EXT_multisampled_render_to_texture(load);
  load_GL_EXT_multiview_draw_buffers(load);
  load_GL_EXT_occlusion_query_boolean(load);
  load_GL_EXT_polygon_offset_clamp(load);
  load_GL_EXT_primitive_bounding_box(load);
  load_GL_EXT_raster_multisample(load);
  load_GL_EXT_robustness(load);
  load_GL_EXT_semaphore(load);
  load_GL_EXT_semaphore_fd(load);
  load_GL_EXT_semaphore_win32(load);
  load_GL_EXT_separate_shader_objects(load);
  load_GL_EXT_shader_framebuffer_fetch_non_coherent(load);
  load_GL_EXT_shader_pixel_local_storage2(load);
  load_GL_EXT_sparse_texture(load);
  load_GL_EXT_tessellation_shader(load);
  load_GL_EXT_texture_border_clamp(load);
  load_GL_EXT_texture_buffer(load);
  load_GL_EXT_texture_storage(load);
  load_GL_EXT_texture_storage_compression(load);
  load_GL_EXT_texture_view(load);
  load_GL_EXT_win32_keyed_mutex(load);
  load_GL_EXT_window_rectangles(load);
  load_GL_IMG_bindless_texture(load);
  load_GL_IMG_framebuffer_downsample(load);
  load_GL_IMG_multisampled_render_to_texture(load);
  load_GL_INTEL_framebuffer_CMAA(load);
  load_GL_INTEL_performance_query(load);
  load_GL_KHR_blend_equation_advanced(load);
  load_GL_KHR_debug(load);
  load_GL_KHR_parallel_shader_compile(load);
  load_GL_KHR_robustness(load);
  load_GL_MESA_framebuffer_flip_y(load);
  load_GL_MESA_sampler_objects(load);
  load_GL_NV_bindless_texture(load);
  load_GL_NV_blend_equation_advanced(load);
  load_GL_NV_clip_space_w_scaling(load);
  load_GL_NV_conditional_render(load);
  load_GL_NV_conservative_raster(load);
  load_GL_NV_conservative_raster_pre_snap_triangles(load);
  load_GL_NV_copy_buffer(load);
  load_GL_NV_coverage_sample(load);
  load_GL_NV_draw_buffers(load);
  load_GL_NV_draw_instanced(load);
  load_GL_NV_draw_vulkan_image(load);
  load_GL_NV_fence(load);
  load_GL_NV_fragment_coverage_to_color(load);
  load_GL_NV_framebuffer_blit(load);
  load_GL_NV_framebuffer_mixed_samples(load);
  load_GL_NV_framebuffer_multisample(load);
  load_GL_NV_gpu_shader5(load);
  load_GL_NV_instanced_arrays(load);
  load_GL_NV_internalformat_sample_query(load);
  load_GL_NV_memory_attachment(load);
  load_GL_NV_memory_object_sparse(load);
  load_GL_NV_mesh_shader(load);
  load_GL_NV_non_square_matrices(load);
  load_GL_NV_path_rendering(load);
  load_GL_NV_polygon_mode(load);
  load_GL_NV_read_buffer(load);
  load_GL_NV_sample_locations(load);
  load_GL_NV_scissor_exclusive(load);
  load_GL_NV_shading_rate_image(load);
  load_GL_NV_timeline_semaphore(load);
  load_GL_NV_viewport_array(load);
  load_GL_NV_viewport_swizzle(load);
  load_GL_OES_EGL_image(load);
  load_GL_OES_copy_image(load);
  load_GL_OES_draw_buffers_indexed(load);
  load_GL_OES_draw_elements_base_vertex(load);
  load_GL_OES_geometry_shader(load);
  load_GL_OES_get_program_binary(load);
  load_GL_OES_mapbuffer(load);
  load_GL_OES_primitive_bounding_box(load);
  load_GL_OES_sample_shading(load);
  load_GL_OES_tessellation_shader(load);
  load_GL_OES_texture_3D(load);
  load_GL_OES_texture_border_clamp(load);
  load_GL_OES_texture_buffer(load);
  load_GL_OES_texture_storage_multisample_2d_array(load);
  load_GL_OES_texture_view(load);
  load_GL_OES_vertex_array_object(load);
  load_GL_OES_viewport_array(load);
  load_GL_OVR_multiview(load);
  load_GL_OVR_multiview_multisampled_render_to_texture(load);
  load_GL_QCOM_alpha_test(load);
  load_GL_QCOM_driver_control(load);
  load_GL_QCOM_extended_get(load);
  load_GL_QCOM_extended_get2(load);
  load_GL_QCOM_frame_extrapolation(load);
  load_GL_QCOM_framebuffer_foveated(load);
  load_GL_QCOM_motion_estimation(load);
  load_GL_QCOM_shader_framebuffer_fetch_noncoherent(load);
  load_GL_QCOM_shading_rate(load);
  load_GL_QCOM_texture_foveated(load);
  load_GL_QCOM_tiled_rendering(load);

  result := (glVersionMajor <> 0) or (glVersionMinor <> 0);
end;

end.
